

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="None" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="None" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; QuTiP: Quantum Toolbox in Python 4.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="API documentation" href="apidoc.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#qobj">Qobj</a></li>
<li class="toctree-l3"><a class="reference internal" href="#eseries">eseries</a></li>
<li class="toctree-l3"><a class="reference internal" href="#bloch-sphere">Bloch sphere</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#cubic-spline">Cubic Spline</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#non-markovian-solvers">Non-Markovian Solvers</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#solver-options-and-results">Solver Options and Results</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#distribution-functions">Distribution functions</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-information-processing">Quantum information processing</a><ul class="simple">
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#optimal-control">Optimal control</a><ul class="simple">
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="functions.html">Functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="apidoc.html">API documentation</a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/apidoc/classes.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<span id="id1"></span><h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<div class="section" id="qobj">
<span id="classes-qobj"></span><h2>Qobj<a class="headerlink" href="#qobj" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.Qobj">
<em class="property">class </em><code class="descclassname">qutip.</code><code class="descname">Qobj</code><span class="sig-paren">(</span><em>inpt=None, dims=[[], []], shape=[], type=None, isherm=None, copy=True, fast=False, superrep=None, isunitary=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representing quantum objects, such as quantum operators
and states.</p>
<p>The Qobj class is the QuTiP representation of quantum operators and state
vectors. This class also implements math operations +,-,* between Qobj
instances (and / by a C-number), as well as a collection of common
operator/state operations.  The Qobj constructor optionally takes a
dimension <code class="docutils literal notranslate"><span class="pre">list</span></code> and/or shape <code class="docutils literal notranslate"><span class="pre">list</span></code> as arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>inpt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Data for vector/matrix representation of the quantum object.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of object used for tensor products.</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Shape of underlying data structure (matrix shape).</p>
</dd>
<dt><strong>copy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Flag specifying whether Qobj should get a copy of the
input data, or use the original.</p>
</dd>
<dt><strong>fast</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Flag for fast qobj creation when running ode solvers.
This parameter is used internally only.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Sparse matrix characterizing the quantum object.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of dimensions keeping track of the tensor structure.</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Shape of the underlying <cite>data</cite> array.</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Type of quantum object: 'bra', 'ket', 'oper', 'operator-ket',
'operator-bra', or 'super'.</p>
</dd>
<dt><strong>superrep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Representation used if <cite>type</cite> is 'super'. One of 'super'
(Liouville form) or 'choi' (Choi matrix with tr = dimension).</p>
</dd>
<dt><strong>isherm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if quantum object represents Hermitian operator.</p>
</dd>
<dt><strong>isunitary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indictaes if quantum object represents unitary operator.</p>
</dd>
<dt><strong>iscp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a map, and if that map is
completely positive (CP).</p>
</dd>
<dt><strong>ishp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a map, and if that map is
hermicity preserving (HP).</p>
</dd>
<dt><strong>istp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a map, and if that map is
trace preserving (TP).</p>
</dd>
<dt><strong>iscptp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a map that is completely
positive and trace preserving (CPTP).</p>
</dd>
<dt><strong>isket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a ket.</p>
</dd>
<dt><strong>isbra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a bra.</p>
</dd>
<dt><strong>isoper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents an operator.</p>
</dd>
<dt><strong>issuper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents a superoperator.</p>
</dd>
<dt><strong>isoperket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents an operator in column vector
form.</p>
</dd>
<dt><strong>isoperbra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Indicates if the quantum object represents an operator in row vector
form.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="48%" />
<col width="52%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>copy()</strong></td>
<td>Create copy of Qobj</td>
</tr>
<tr class="row-even"><td><strong>conj()</strong></td>
<td>Conjugate of quantum object.</td>
</tr>
<tr class="row-odd"><td><strong>cosm()</strong></td>
<td>Cosine of quantum object.</td>
</tr>
<tr class="row-even"><td><strong>dag()</strong></td>
<td>Adjoint (dagger) of quantum object.</td>
</tr>
<tr class="row-odd"><td><strong>dnorm()</strong></td>
<td>Diamond norm of quantum operator.</td>
</tr>
<tr class="row-even"><td><strong>dual_chan()</strong></td>
<td>Dual channel of quantum object representing a CP map.</td>
</tr>
<tr class="row-odd"><td><strong>eigenenergies(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)</strong></td>
<td>Returns eigenenergies (eigenvalues) of a quantum object.</td>
</tr>
<tr class="row-even"><td><strong>eigenstates(sparse=False, sort='low', eigvals=0, tol=0, maxiter=100000)</strong></td>
<td>Returns eigenenergies and eigenstates of quantum object.</td>
</tr>
<tr class="row-odd"><td><strong>expm()</strong></td>
<td>Matrix exponential of quantum object.</td>
</tr>
<tr class="row-even"><td><strong>full(order='C')</strong></td>
<td>Returns dense array of quantum object <cite>data</cite> attribute.</td>
</tr>
<tr class="row-odd"><td><strong>groundstate(sparse=False, tol=0, maxiter=100000)</strong></td>
<td>Returns eigenvalue and eigenket for the groundstate of a quantum object.</td>
</tr>
<tr class="row-even"><td><strong>matrix_element(bra, ket)</strong></td>
<td>Returns the matrix element of operator between <cite>bra</cite> and <cite>ket</cite> vectors.</td>
</tr>
<tr class="row-odd"><td><strong>norm(norm='tr', sparse=False, tol=0, maxiter=100000)</strong></td>
<td>Returns norm of a ket or an operator.</td>
</tr>
<tr class="row-even"><td><strong>permute(order)</strong></td>
<td>Returns composite qobj with indices reordered.</td>
</tr>
<tr class="row-odd"><td><strong>proj()</strong></td>
<td>Computes the projector for a ket or bra vector.</td>
</tr>
<tr class="row-even"><td><strong>ptrace(sel)</strong></td>
<td>Returns quantum object for selected dimensions after performing partial trace.</td>
</tr>
<tr class="row-odd"><td><strong>sinm()</strong></td>
<td>Sine of quantum object.</td>
</tr>
<tr class="row-even"><td><strong>sqrtm()</strong></td>
<td>Matrix square root of quantum object.</td>
</tr>
<tr class="row-odd"><td><strong>tidyup(atol=1e-12)</strong></td>
<td>Removes small elements from quantum object.</td>
</tr>
<tr class="row-even"><td><strong>tr()</strong></td>
<td>Trace of quantum object.</td>
</tr>
<tr class="row-odd"><td><strong>trans()</strong></td>
<td>Transpose of quantum object.</td>
</tr>
<tr class="row-even"><td><strong>transform(inpt, inverse=False)</strong></td>
<td>Performs a basis transformation defined by <cite>inpt</cite> matrix.</td>
</tr>
<tr class="row-odd"><td><strong>trunc_neg(method='clip')</strong></td>
<td>Removes negative eigenvalues and returns a new Qobj that is a valid density operator.</td>
</tr>
<tr class="row-even"><td><strong>unit(norm='tr', sparse=False, tol=0, maxiter=100000)</strong></td>
<td>Returns normalized quantum object.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.Qobj.check_herm">
<code class="descname">check_herm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.check_herm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.check_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the quantum object is hermitian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>isherm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Returns the new value of isherm property.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.check_isunitary">
<code class="descname">check_isunitary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.check_isunitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.check_isunitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether qobj is a unitary matrix</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.conj">
<code class="descname">conj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.conj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.conj" title="Permalink to this definition">¶</a></dt>
<dd><p>Conjugate operator of quantum object.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.copy">
<code class="descname">copy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.copy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create identical copy</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.cosm">
<code class="descname">cosm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.cosm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.cosm" title="Permalink to this definition">¶</a></dt>
<dd><p>Cosine of a quantum operator.</p>
<p>Operator must be square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Matrix cosine of operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError</strong></dt>
<dd><p class="first last">Quantum object is not square.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Uses the Q.expm() method.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.dag">
<code class="descname">dag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.dag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.dag" title="Permalink to this definition">¶</a></dt>
<dd><p>Adjoint operator of quantum object.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.diag">
<code class="descname">diag</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.diag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.diag" title="Permalink to this definition">¶</a></dt>
<dd><p>Diagonal elements of quantum object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>diags</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Returns array of <code class="docutils literal notranslate"><span class="pre">real</span></code> values if operators is Hermitian,
otherwise <code class="docutils literal notranslate"><span class="pre">complex</span></code> values are returned.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.dnorm">
<code class="descname">dnorm</code><span class="sig-paren">(</span><em>B=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.dnorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.dnorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the diamond norm, or the diamond distance to another
operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or None</span></dt>
<dd><p class="first last">If B is not None, the diamond distance d(A, B) = dnorm(A - B) between
this operator and B is returned instead of the diamond norm.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Either the diamond norm of this operator, or the diamond distance
from this operator to B.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.dual_chan">
<code class="descname">dual_chan</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.dual_chan"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.dual_chan" title="Permalink to this definition">¶</a></dt>
<dd><p>Dual channel of quantum object representing a completely positive
map.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.eigenenergies">
<code class="descname">eigenenergies</code><span class="sig-paren">(</span><em>sparse=False</em>, <em>sort='low'</em>, <em>eigvals=0</em>, <em>tol=0</em>, <em>maxiter=100000</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.eigenenergies"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.eigenenergies" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenenergies of a quantum object.</p>
<p>Eigenenergies (eigenvalues) are defined for operators or superoperators
only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse Eigensolver</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Sort eigenvalues 'low' to high, or 'high' to low.</p>
</dd>
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of requested eigenvalues. Default is all eigenvalues.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used by sparse Eigensolver (0=machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of eigenvalues for operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.eigenstates">
<code class="descname">eigenstates</code><span class="sig-paren">(</span><em>sparse=False</em>, <em>sort='low'</em>, <em>eigvals=0</em>, <em>tol=0</em>, <em>maxiter=100000</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.eigenstates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.eigenstates" title="Permalink to this definition">¶</a></dt>
<dd><p>Eigenstates and eigenenergies.</p>
<p>Eigenstates and eigenenergies are defined for operators and
superoperators only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse Eigensolver</p>
</dd>
<dt><strong>sort</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Sort eigenvalues (and vectors) 'low' to high, or 'high' to low.</p>
</dd>
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of requested eigenvalues. Default is all eigenvalues.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used by sparse Eigensolver (0 = machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigvals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of eigenvalues for operator.</p>
</dd>
<dt><strong>eigvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of quantum operators representing the oprator eigenkets.
Order of eigenkets is determined by order of eigenvalues.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.eliminate_states">
<code class="descname">eliminate_states</code><span class="sig-paren">(</span><em>states_inds</em>, <em>normalize=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.eliminate_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.eliminate_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new quantum object with states in state_inds eliminated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>states_inds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of integer</span></dt>
<dd><p class="first last">The states that should be removed.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">True / False</span></dt>
<dd><p class="first last">Weather or not the new Qobj instance should be normalized (default
is False). For Qobjs that represents density matrices or state
vectors normalized should probably be set to True, but for Qobjs
that represents operators in for example an Hamiltonian, normalize
should be False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A new instance of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> that contains only the states
corresponding to indices that are <strong>not</strong> in <cite>state_inds</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="qutip.Qobj.evaluate">
<em class="property">static </em><code class="descname">evaluate</code><span class="sig-paren">(</span><em>qobj_list</em>, <em>t</em>, <em>args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.evaluate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.evaluate" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a time-dependent quantum object in list format. For
example,</p>
<blockquote>
<div>qobj_list = [H0, [H1, func_t]]</div></blockquote>
<p>is evaluated to</p>
<blockquote>
<div>Qobj(t) = H0 + H1 * func_t(t, args)</div></blockquote>
<p>and</p>
<blockquote>
<div>qobj_list = [H0, [H1, 'sin(w * t)']]</div></blockquote>
<p>is evaluated to</p>
<blockquote>
<div>Qobj(t) = H0 + H1 * sin(args['w'] * t)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qobj_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A nested list of Qobj instances and corresponding time-dependent
coefficients.</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time for which to evaluate the time-dependent Qobj instance.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">A dictionary with parameter values required to evaluate the
time-dependent Qobj intance.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A Qobj instance that represents the value of qobj_list at time t.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.expm">
<code class="descname">expm</code><span class="sig-paren">(</span><em>method='dense'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.expm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.expm" title="Permalink to this definition">¶</a></dt>
<dd><p>Matrix exponential of quantum operator.</p>
<p>Input operator must be square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'dense', 'sparse'}</span></dt>
<dd><p class="first last">Use set method to use to calculate the matrix exponentiation. The
available choices includes 'dense' and 'sparse'.  Since the
exponential of a matrix is nearly always dense, method='dense'
is set as default.s</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Exponentiated quantum operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError</strong></dt>
<dd><p class="first last">Quantum operator is not square.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.extract_states">
<code class="descname">extract_states</code><span class="sig-paren">(</span><em>states_inds</em>, <em>normalize=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.extract_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.extract_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Qobj with states in state_inds only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>states_inds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of integer</span></dt>
<dd><p class="first last">The states that should be kept.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">True / False</span></dt>
<dd><p class="first last">Weather or not the new Qobj instance should be normalized (default
is False). For Qobjs that represents density matrices or state
vectors normalized should probably be set to True, but for Qobjs
that represents operators in for example an Hamiltonian, normalize
should be False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A new instance of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> that contains only the states
corresponding to the indices in <cite>state_inds</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.full">
<code class="descname">full</code><span class="sig-paren">(</span><em>order='C'</em>, <em>squeeze=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.full"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.full" title="Permalink to this definition">¶</a></dt>
<dd><p>Dense array from quantum object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'C', 'F'}</span></dt>
<dd><p class="first last">Return array in C (default) or Fortran ordering.</p>
</dd>
<dt><strong>squeeze</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Squeeze output array.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of complex data from quantum objects <cite>data</cite> attribute.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.groundstate">
<code class="descname">groundstate</code><span class="sig-paren">(</span><em>sparse=False</em>, <em>tol=0</em>, <em>maxiter=100000</em>, <em>safe=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.groundstate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.groundstate" title="Permalink to this definition">¶</a></dt>
<dd><p>Ground state Eigenvalue and Eigenvector.</p>
<p>Defined for quantum operators or superoperators only.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse Eigensolver</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used by sparse Eigensolver (0 = machine precision).
The sparse solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations performed by sparse solver (if used).</p>
</dd>
<dt><strong>safe</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (default=True)</span></dt>
<dd><p class="first last">Check for degenerate ground state</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigval</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Eigenvalue for the ground state of quantum operator.</p>
</dd>
<dt><strong>eigvec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Eigenket for the ground state of quantum operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.matrix_element">
<code class="descname">matrix_element</code><span class="sig-paren">(</span><em>bra</em>, <em>ket</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.matrix_element"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.matrix_element" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a matrix element.</p>
<p>Gives the matrix element for the quantum object sandwiched between a
<cite>bra</cite> and <cite>ket</cite> vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object of type 'bra' or 'ket'</p>
</dd>
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object of type 'ket'.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>elem</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex</span></dt>
<dd><p class="first last">Complex valued matrix element.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.norm">
<code class="descname">norm</code><span class="sig-paren">(</span><em>norm=None</em>, <em>sparse=False</em>, <em>tol=0</em>, <em>maxiter=100000</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Norm of a quantum object.</p>
<p>Default norm is L2-norm for kets and trace-norm for operators.
Other ket and operator norms may be specified using the <cite>norm</cite> and
argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Which norm to use for ket/bra vectors: L2 'l2', max norm 'max',
or for operators: trace 'tr', Frobius 'fro', one 'one', or max
'max'.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse eigenvalue solver for trace norm.  Other norms are not
affected by this parameter.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance for sparse solver (if used) for trace norm. The sparse
solver may not converge if the tolerance is set too low.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations performed by sparse solver (if used)
for trace norm.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The requested norm of the operator or state quantum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.overlap">
<code class="descname">overlap</code><span class="sig-paren">(</span><em>other</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.overlap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.overlap" title="Permalink to this definition">¶</a></dt>
<dd><p>Overlap between two state vectors or two operators.</p>
<p>Gives the overlap (inner product) between the current bra or ket Qobj
and and another bra or ket Qobj. It gives the Hilbert-Schmidt overlap
when one of the Qobj is an operator/density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>other</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object for a state vector of type 'ket', 'bra' or density
matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>overlap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex</span></dt>
<dd><p class="first last">Complex valued overlap.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError</strong></dt>
<dd><p class="first last">Can only calculate overlap between a bra, ket and density matrix
quantum objects.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Since QuTiP mainly deals with ket vectors, the most efficient inner
product call is the ket-ket version that computes the product
&lt;self|other&gt; with both vectors expressed as kets.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.permute">
<code class="descname">permute</code><span class="sig-paren">(</span><em>order</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.permute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.permute" title="Permalink to this definition">¶</a></dt>
<dd><p>Permutes a composite quantum object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">List specifying new tensor order.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>P</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Permuted quantum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.proj">
<code class="descname">proj</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.proj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.proj" title="Permalink to this definition">¶</a></dt>
<dd><p>Form the projector from a given ket or bra vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Input bra or ket vector</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>P</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Projection operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.ptrace">
<code class="descname">ptrace</code><span class="sig-paren">(</span><em>sel</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.ptrace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.ptrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Partial trace of the quantum object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/list</span></dt>
<dd><p class="first last">An <code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of components to keep after partial trace.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representing partial trace with selected components
remaining.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is identical to the <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.qobj.ptrace()</span></code> function
that has been deprecated.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.sinm">
<code class="descname">sinm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.sinm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.sinm" title="Permalink to this definition">¶</a></dt>
<dd><p>Sine of a quantum operator.</p>
<p>Operator must be square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Matrix sine of operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError</strong></dt>
<dd><p class="first last">Quantum object is not square.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Uses the Q.expm() method.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.sqrtm">
<code class="descname">sqrtm</code><span class="sig-paren">(</span><em>sparse=False</em>, <em>tol=0</em>, <em>maxiter=100000</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.sqrtm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.sqrtm" title="Permalink to this definition">¶</a></dt>
<dd><p>Sqrt of a quantum operator.</p>
<p>Operator must be square.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse eigenvalue/vector solver.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used by sparse solver (0 = machine precision).</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum number of iterations used by sparse solver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Matrix square root of operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError</strong></dt>
<dd><p class="first last">Quantum object is not square.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The sparse eigensolver is much slower than the dense version.
Use sparse only if memory requirements demand it.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.tidyup">
<code class="descname">tidyup</code><span class="sig-paren">(</span><em>atol=1e-12</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.tidyup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.tidyup" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes small elements from the quantum object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Absolute tolerance used by tidyup. Default is set
via qutip global settings parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object with small elements removed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.tr">
<code class="descname">tr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.tr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.tr" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace of a quantum object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>trace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Returns <code class="docutils literal notranslate"><span class="pre">real</span></code> if operator is Hermitian, returns <code class="docutils literal notranslate"><span class="pre">complex</span></code>
otherwise.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.trans">
<code class="descname">trans</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.trans"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.trans" title="Permalink to this definition">¶</a></dt>
<dd><p>Transposed operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Transpose of input operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.transform">
<code class="descname">transform</code><span class="sig-paren">(</span><em>inpt</em>, <em>inverse=False</em>, <em>sparse=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis transform defined by input array.</p>
<p>Input array can be a <code class="docutils literal notranslate"><span class="pre">matrix</span></code> defining the transformation,
or a <code class="docutils literal notranslate"><span class="pre">list</span></code> of kets that defines the new basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>inpt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">A <code class="docutils literal notranslate"><span class="pre">matrix</span></code> or <code class="docutils literal notranslate"><span class="pre">list</span></code> of kets defining the transformation.</p>
</dd>
<dt><strong>inverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether to return inverse transformation.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse matrices when possible. Can be slower.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Operator in new basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function is still in development.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.trunc_neg">
<code class="descname">trunc_neg</code><span class="sig-paren">(</span><em>method='clip'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.trunc_neg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.trunc_neg" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncates negative eigenvalues and renormalizes.</p>
<p>Returns a new Qobj by removing the negative eigenvalues
of this instance, then renormalizing to obtain a valid density
operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Algorithm to use to remove negative eigenvalues. &quot;clip&quot;
simply discards negative eigenvalues, then renormalizes.
&quot;sgs&quot; uses the SGS algorithm (doi:10/bb76) to find the
positive operator that is nearest in the Shatten 2-norm.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A valid density operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.Qobj.unit">
<code class="descname">unit</code><span class="sig-paren">(</span><em>inplace=False</em>, <em>norm=None</em>, <em>sparse=False</em>, <em>tol=0</em>, <em>maxiter=100000</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qobj.html#Qobj.unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.Qobj.unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Operator or state normalized to unity.</p>
<p>Uses norm from Qobj.norm().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>inplace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Do an in-place normalization</p>
</dd>
<dt><strong>norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Requested norm for states / operators.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use sparse eigensolver for trace norm. Does not affect other norms.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used by sparse eigensolver.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of maximum iterations performed by sparse eigensolver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Normalized quantum object if not in-place,
else None.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="eseries">
<span id="classes-eseries"></span><h2>eseries<a class="headerlink" href="#eseries" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.eseries">
<em class="property">class </em><code class="descclassname">qutip.</code><code class="descname">eseries</code><span class="sig-paren">(</span><em>q=None</em>, <em>s=array([]</em>, <em>dtype=float64)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/eseries.html#eseries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.eseries" title="Permalink to this definition">¶</a></dt>
<dd><p>Class representation of an exponential-series expansion of
time-dependent quantum objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ampl</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array of amplitudes for exponential series.</p>
</dd>
<dt><strong>rates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array of rates for exponential series.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of exponential series components</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Shape corresponding to exponential series components</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="82%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>value(tlist)</strong></td>
<td>Evaluate an exponential series at the times listed in tlist</td>
</tr>
<tr class="row-even"><td><strong>spec(wlist)</strong></td>
<td>Evaluate the spectrum of an exponential series at frequencies in wlist.</td>
</tr>
<tr class="row-odd"><td><strong>tidyup()</strong></td>
<td>Returns a tidier version of the exponential series</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.eseries.spec">
<code class="descname">spec</code><span class="sig-paren">(</span><em>wlist</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/eseries.html#eseries.spec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.eseries.spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the spectrum of an exponential series at frequencies
in <code class="docutils literal notranslate"><span class="pre">wlist</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>wlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Array/list of frequenies.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>val_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Values of exponential series at frequencies in <code class="docutils literal notranslate"><span class="pre">wlist</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.eseries.tidyup">
<code class="descname">tidyup</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/eseries.html#eseries.tidyup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.eseries.tidyup" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a tidier version of exponential series.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.eseries.value">
<code class="descname">value</code><span class="sig-paren">(</span><em>tlist</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/eseries.html#eseries.value"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.eseries.value" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates an exponential series at the times listed in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Times at which to evaluate exponential series.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>val_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Values of exponential at times in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="bloch-sphere">
<span id="classes-bloch"></span><h2>Bloch sphere<a class="headerlink" href="#bloch-sphere" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.bloch.Bloch">
<em class="property">class </em><code class="descclassname">qutip.bloch.</code><code class="descname">Bloch</code><span class="sig-paren">(</span><em>fig=None</em>, <em>axes=None</em>, <em>view=None</em>, <em>figsize=None</em>, <em>background=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for plotting data on the Bloch sphere.  Valid data can be
either points, vectors, or qobj objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance {None}</span></dt>
<dd><p class="first last">User supplied Matplotlib axes for Bloch sphere animation.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance {None}</span></dt>
<dd><p class="first last">User supplied Matplotlib Figure instance for plotting Bloch sphere.</p>
</dd>
<dt><strong>font_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'black'}</span></dt>
<dd><p class="first last">Color of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>font_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {20}</span></dt>
<dd><p class="first last">Size of font used for Bloch sphere labels.</p>
</dd>
<dt><strong>frame_alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {0.1}</span></dt>
<dd><p class="first last">Sets transparency of Bloch sphere frame.</p>
</dd>
<dt><strong>frame_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'gray'}</span></dt>
<dd><p class="first last">Color of sphere wireframe.</p>
</dd>
<dt><strong>frame_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {1}</span></dt>
<dd><p class="first last">Width of wireframe.</p>
</dd>
<dt><strong>point_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[&quot;b&quot;,&quot;r&quot;,&quot;g&quot;,&quot;#CC6600&quot;]}</span></dt>
<dd><p class="first last">List of colors for Bloch sphere point markers to cycle through.
i.e. By default, points 0 and 4 will both be blue ('b').</p>
</dd>
<dt><strong>point_marker</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[&quot;o&quot;,&quot;s&quot;,&quot;d&quot;,&quot;^&quot;]}</span></dt>
<dd><p class="first last">List of point marker shapes to cycle through.</p>
</dd>
<dt><strong>point_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[25,32,35,45]}</span></dt>
<dd><p class="first last">List of point marker sizes. Note, not all point markers look
the same size when plotted!</p>
</dd>
<dt><strong>sphere_alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {0.2}</span></dt>
<dd><p class="first last">Transparency of Bloch sphere itself.</p>
</dd>
<dt><strong>sphere_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'#FFDDDD'}</span></dt>
<dd><p class="first last">Color of Bloch sphere.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[7,7]}</span></dt>
<dd><p class="first last">Figure size of Bloch sphere plot.  Best to have both numbers the same;
otherwise you will have a Bloch sphere that looks like a football.</p>
</dd>
<dt><strong>vector_color</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[&quot;g&quot;,&quot;#CC6600&quot;,&quot;b&quot;,&quot;r&quot;]}</span></dt>
<dd><p class="first last">List of vector colors to cycle through.</p>
</dd>
<dt><strong>vector_width</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {5}</span></dt>
<dd><p class="first last">Width of displayed vectors.</p>
</dd>
<dt><strong>vector_style</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'-<a href="#id2"><span class="problematic" id="id3">|</span></a>&gt;', 'simple', 'fancy', ''}</span></dt>
<dd><p class="first last">Vector arrowhead style (from matplotlib's arrow style).</p>
</dd>
<dt><strong>vector_mutation</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {20}</span></dt>
<dd><p class="first last">Width of vectors arrowhead.</p>
</dd>
<dt><strong>view</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[-60,30]}</span></dt>
<dd><p class="first last">Azimuthal and Elevation viewing angles.</p>
</dd>
<dt><strong>xlabel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[&quot;$x$&quot;,&quot;&quot;]}</span></dt>
<dd><p class="first last">List of strings corresponding to +x and -x axes labels, respectively.</p>
</dd>
<dt><strong>xlpos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[1.1,-1.1]}</span></dt>
<dd><p class="first last">Positions of +x and -x labels respectively.</p>
</dd>
<dt><strong>ylabel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[&quot;$y$&quot;,&quot;&quot;]}</span></dt>
<dd><p class="first last">List of strings corresponding to +y and -y axes labels, respectively.</p>
</dd>
<dt><strong>ylpos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[1.2,-1.2]}</span></dt>
<dd><p class="first last">Positions of +y and -y labels respectively.</p>
</dd>
<dt><strong>zlabel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[r'$\left|0\right&gt;$',r'$\left|1\right&gt;$']}</span></dt>
<dd><p class="first last">List of strings corresponding to +z and -z axes labels, respectively.</p>
</dd>
<dt><strong>zlpos</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list {[1.2,-1.2]}</span></dt>
<dd><p class="first last">Positions of +z and -z labels respectively.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.bloch.Bloch.add_annotation" title="qutip.bloch.Bloch.add_annotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_annotation</span></code></a>(state_or_vector,&nbsp;text,&nbsp;**kwargs)</td>
<td>Add a text or LaTeX annotation to Bloch sphere, parametrized by a qubit state or a vector.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.bloch.Bloch.add_points" title="qutip.bloch.Bloch.add_points"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_points</span></code></a>(points[,&nbsp;meth])</td>
<td>Add a list of data points to bloch sphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.bloch.Bloch.add_states" title="qutip.bloch.Bloch.add_states"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_states</span></code></a>(state[,&nbsp;kind])</td>
<td>Add a state vector Qobj to Bloch sphere.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.bloch.Bloch.add_vectors" title="qutip.bloch.Bloch.add_vectors"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_vectors</span></code></a>(vectors)</td>
<td>Add a list of vectors to Bloch sphere.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.bloch.Bloch.clear" title="qutip.bloch.Bloch.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</td>
<td>Resets Bloch sphere data sets to empty.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.bloch.Bloch.make_sphere" title="qutip.bloch.Bloch.make_sphere"><code class="xref py py-obj docutils literal notranslate"><span class="pre">make_sphere</span></code></a>()</td>
<td>Plots Bloch sphere and data sets.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.bloch.Bloch.render" title="qutip.bloch.Bloch.render"><code class="xref py py-obj docutils literal notranslate"><span class="pre">render</span></code></a>([fig,&nbsp;axes])</td>
<td>Render the Bloch sphere and its data sets in on given figure and axes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.bloch.Bloch.save" title="qutip.bloch.Bloch.save"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save</span></code></a>([name,&nbsp;format,&nbsp;dirc])</td>
<td>Saves Bloch sphere to file of type <code class="docutils literal notranslate"><span class="pre">format</span></code> in directory <code class="docutils literal notranslate"><span class="pre">dirc</span></code>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.bloch.Bloch.set_label_convention" title="qutip.bloch.Bloch.set_label_convention"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_label_convention</span></code></a>(convention)</td>
<td>Set x, y and z labels according to one of conventions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.bloch.Bloch.show" title="qutip.bloch.Bloch.show"><code class="xref py py-obj docutils literal notranslate"><span class="pre">show</span></code></a>()</td>
<td>Display Bloch sphere and corresponding data sets.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>plot_annotations</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>plot_axes</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>plot_axes_labels</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>plot_back</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>plot_front</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>plot_points</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>plot_vectors</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.bloch.Bloch.add_annotation">
<code class="descname">add_annotation</code><span class="sig-paren">(</span><em>state_or_vector</em>, <em>text</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.add_annotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_annotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a text or LaTeX annotation to Bloch sphere,
parametrized by a qubit state or a vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state_or_vector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj/array/list/tuple</span></dt>
<dd><p class="first last">Position for the annotaion.
Qobj of a qubit or a vector of 3 elements.</p>
</dd>
<dt><strong>text</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str/unicode</span></dt>
<dd><p class="first last">Annotation text.
You can use LaTeX, but remember to use raw string
e.g. r&quot;$langle x rangle$&quot;
or escape backslashes
e.g. &quot;$\langle x \rangle$&quot;.</p>
</dd>
<dt><strong>**kwargs :</strong></dt>
<dd><p class="first last">Options as for mplot3d.axes3d.text, including:
fontsize, color, horizontalalignment, verticalalignment.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.add_points">
<code class="descname">add_points</code><span class="sig-paren">(</span><em>points</em>, <em>meth='s'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.add_points"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of data points to bloch sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>points</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array/list</span></dt>
<dd><p class="first last">Collection of data points.</p>
</dd>
<dt><strong>meth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'s', 'm', 'l'}</span></dt>
<dd><p class="first last">Type of points to plot, use 'm' for multicolored, 'l' for points
connected with a line.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.add_states">
<code class="descname">add_states</code><span class="sig-paren">(</span><em>state</em>, <em>kind='vector'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.add_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a state vector Qobj to Bloch sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Input state vector.</p>
</dd>
<dt><strong>kind</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'vector','point'}</span></dt>
<dd><p class="first last">Type of object to plot.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.add_vectors">
<code class="descname">add_vectors</code><span class="sig-paren">(</span><em>vectors</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.add_vectors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.add_vectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a list of vectors to Bloch sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Array with vectors of unit length or smaller.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets Bloch sphere data sets to empty.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.make_sphere">
<code class="descname">make_sphere</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.make_sphere"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.make_sphere" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots Bloch sphere and data sets.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.render">
<code class="descname">render</code><span class="sig-paren">(</span><em>fig=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.render"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.render" title="Permalink to this definition">¶</a></dt>
<dd><p>Render the Bloch sphere and its data sets in on given figure and axes.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.save">
<code class="descname">save</code><span class="sig-paren">(</span><em>name=None</em>, <em>format='png'</em>, <em>dirc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.save"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves Bloch sphere to file of type <code class="docutils literal notranslate"><span class="pre">format</span></code> in directory <code class="docutils literal notranslate"><span class="pre">dirc</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of saved image. Must include path and format as well.
i.e. '/Users/Paul/Desktop/bloch.png'
This overrides the 'format' and 'dirc' arguments.</p>
</dd>
<dt><strong>format</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Format of output image.</p>
</dd>
<dt><strong>dirc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Directory for output images. Defaults to current working directory.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>File containing plot of Bloch sphere.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.set_label_convention">
<code class="descname">set_label_convention</code><span class="sig-paren">(</span><em>convention</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.set_label_convention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.set_label_convention" title="Permalink to this definition">¶</a></dt>
<dd><p>Set x, y and z labels according to one of conventions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>convention</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">One of the following:</p>
<blockquote class="last">
<div><ul class="simple">
<li>&quot;original&quot;</li>
<li>&quot;xyz&quot;</li>
<li>&quot;sx sy sz&quot;</li>
<li>&quot;01&quot;</li>
<li>&quot;polarization jones&quot;</li>
<li>&quot;polarization jones letters&quot; 
see also: <a class="reference external" href="http://en.wikipedia.org/wiki/Jones_calculus">http://en.wikipedia.org/wiki/Jones_calculus</a></li>
<li>&quot;polarization stokes&quot;
see also: <a class="reference external" href="http://en.wikipedia.org/wiki/Stokes_parameters">http://en.wikipedia.org/wiki/Stokes_parameters</a></li>
</ul>
</div></blockquote>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.bloch.Bloch.show">
<code class="descname">show</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch.html#Bloch.show"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch.Bloch.show" title="Permalink to this definition">¶</a></dt>
<dd><p>Display Bloch sphere and corresponding data sets.</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.bloch.Bloch.vector_mutation">
<code class="descname">vector_mutation</code><em class="property"> = None</em><a class="headerlink" href="#qutip.bloch.Bloch.vector_mutation" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the width of the vectors arrowhead</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.bloch.Bloch.vector_style">
<code class="descname">vector_style</code><em class="property"> = None</em><a class="headerlink" href="#qutip.bloch.Bloch.vector_style" title="Permalink to this definition">¶</a></dt>
<dd><p>Style of Bloch vectors, default = '-<a href="#id4"><span class="problematic" id="id5">|</span></a>&gt;' (or 'simple')</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.bloch.Bloch.vector_width">
<code class="descname">vector_width</code><em class="property"> = None</em><a class="headerlink" href="#qutip.bloch.Bloch.vector_width" title="Permalink to this definition">¶</a></dt>
<dd><p>Width of Bloch vectors, default = 5</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="cubic-spline">
<h2>Cubic Spline<a class="headerlink" href="#cubic-spline" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.interpolate.Cubic_Spline">
<em class="property">class </em><code class="descclassname">qutip.interpolate.</code><code class="descname">Cubic_Spline</code><span class="sig-paren">(</span><em>a</em>, <em>b</em>, <em>y</em>, <em>alpha=0</em>, <em>beta=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/interpolate.html#Cubic_Spline"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.interpolate.Cubic_Spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates coefficients for a cubic spline
interpolation of a given data set.</p>
<p>This function assumes that the data is sampled
uniformly over a given interval.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Lower bound of the interval.</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Upper bound of the interval.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Function values at interval points.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Second-order derivative at a. Default is 0.</p>
</dd>
<dt><strong>beta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Second-order derivative at b. Default is 0.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This object can be called like a normal function with a
single or array of input points at which to evaluate
the interplating function.</p>
<p>Habermann &amp; Kindermann, &quot;Multidimensional Spline Interpolation: 
Theory and Applications&quot;, Comput Econ 30, 153 (2007).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Lower bound of the interval.</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Upper bound of the interval.</p>
</dd>
<dt><strong>coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array of coeffcients defining cubic spline.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">__call__</span></code>(pnts,&nbsp;*args)</td>
<td>Call self as a function.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="non-markovian-solvers">
<span id="classes-non-markov"></span><h2>Non-Markovian Solvers<a class="headerlink" href="#non-markovian-solvers" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.nonmarkov.heom.HEOMSolver">
<em class="property">class </em><code class="descclassname">qutip.nonmarkov.heom.</code><code class="descname">HEOMSolver</code><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HEOMSolver"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver" title="Permalink to this definition">¶</a></dt>
<dd><p>This is superclass for all solvers that use the HEOM method for
calculating the dynamics evolution. There are many references for this.
A good introduction, and perhaps closest to the notation used here is:
DOI:10.1103/PhysRevLett.104.250401
A more canonical reference, with full derivation is:
DOI: 10.1103/PhysRevA.41.6676
The method can compute open system dynamics without using any Markovian
or rotating wave approximation (RWA) for systems where the bath
correlations can be approximated to a sum of complex eponentials.
The method builds a matrix of linked differential equations, which are
then solved used the same ODE solvers as other qutip solvers (e.g. mesolve)</p>
<p>This class should be treated as abstract. Currently the only subclass
implemented is that for the Drude-Lorentz spectral density. This covers
the majority of the work that has been done using this model, and there
are some performance advantages to assuming this model where it is
appropriate.</p>
<p>There are opportunities to develop a more general spectral density code.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_sys</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">System Hamiltonian</p>
</dd>
<dt><strong>coup_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Operator describing the coupling between system and bath.</p>
</dd>
<dt><strong>coup_strength</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Coupling strength.</p>
</dd>
<dt><strong>temperature</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Bath temperature, in units corresponding to planck</p>
</dd>
<dt><strong>N_cut</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Cutoff parameter for the bath</p>
</dd>
<dt><strong>N_exp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of exponential terms used to approximate the bath correlation
functions</p>
</dd>
<dt><strong>planck</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">reduced Planck constant</p>
</dd>
<dt><strong>boltzmann</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Boltzmann's constant</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt>
<dd><p class="first last">Generic solver options.
If set to None the default options will be used</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
<dt><strong>stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Stats" title="qutip.solver.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Stats</span></code></a></span></dt>
<dd><p class="first last">optional container for holding performance statitics
If None is set, then statistics are not collected
There may be an overhead in collecting statistics</p>
</dd>
<dt><strong>exp_coeff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of complex</span></dt>
<dd><p class="first last">Coefficients for the exponential series terms</p>
</dd>
<dt><strong>exp_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of complex</span></dt>
<dd><p class="first last">Frequencies for the exponential series terms</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver.configure" title="qutip.nonmarkov.heom.HEOMSolver.configure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">configure</span></code></a>(H_sys,&nbsp;coup_op,&nbsp;coup_strength,&nbsp;...)</td>
<td>Configure the solver using the passed parameters The parameters are described in the class attributes, unless there is some specific behaviour</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver.create_new_stats" title="qutip.nonmarkov.heom.HEOMSolver.create_new_stats"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_new_stats</span></code></a>()</td>
<td>Creates a new stats object suitable for use with this solver Note: this solver expects the stats object to have sections     config     integrate</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver.reset" title="qutip.nonmarkov.heom.HEOMSolver.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>Reset any attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.nonmarkov.heom.HEOMSolver.configure">
<code class="descname">configure</code><span class="sig-paren">(</span><em>H_sys</em>, <em>coup_op</em>, <em>coup_strength</em>, <em>temperature</em>, <em>N_cut</em>, <em>N_exp</em>, <em>planck=None</em>, <em>boltzmann=None</em>, <em>renorm=None</em>, <em>bnd_cut_approx=None</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>stats=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HEOMSolver.configure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure the solver using the passed parameters
The parameters are described in the class attributes, unless there
is some specific behaviour</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt>
<dd><p class="first last">Generic solver options.
If set to None the default options will be used</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.
If set to None, then the default progress bar will be used
Set to False for no progress bar</p>
</dd>
<dt><strong>stats: :class:`qutip.solver.Stats`</strong></dt>
<dd><p class="first last">Optional instance of solver.Stats, or a subclass thereof, for
storing performance statistics for the solver
If set to True, then the default Stats for this class will be used
Set to False for no stats</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.heom.HEOMSolver.create_new_stats">
<code class="descname">create_new_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HEOMSolver.create_new_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver.create_new_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new stats object suitable for use with this solver
Note: this solver expects the stats object to have sections</p>
<blockquote>
<div>config
integrate</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.heom.HEOMSolver.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HEOMSolver.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HEOMSolver.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset any attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.nonmarkov.heom.HSolverDL">
<em class="property">class </em><code class="descclassname">qutip.nonmarkov.heom.</code><code class="descname">HSolverDL</code><span class="sig-paren">(</span><em>H_sys</em>, <em>coup_op</em>, <em>coup_strength</em>, <em>temperature</em>, <em>N_cut</em>, <em>N_exp</em>, <em>cut_freq</em>, <em>planck=1.0</em>, <em>boltzmann=1.0</em>, <em>renorm=True</em>, <em>bnd_cut_approx=True</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>stats=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HSolverDL"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HSolverDL" title="Permalink to this definition">¶</a></dt>
<dd><p>HEOM solver based on the Drude-Lorentz model for spectral density.
Drude-Lorentz bath the correlation functions can be exactly analytically
expressed as an infinite sum of exponentials which depend on the
temperature, these are called the Matsubara terms or Matsubara frequencies</p>
<p>For practical computation purposes an approximation must be used based
on a small number of Matsubara terms (typically &lt; 4).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cut_freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Bath spectral density cutoff frequency.</p>
</dd>
<dt><strong>renorm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Apply renormalisation to coupling terms
Can be useful if using SI units for planck and boltzmann</p>
</dd>
<dt><strong>bnd_cut_approx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Use boundary cut off approximation
Can be</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.nonmarkov.heom.HSolverDL.configure" title="qutip.nonmarkov.heom.HSolverDL.configure"><code class="xref py py-obj docutils literal notranslate"><span class="pre">configure</span></code></a>(H_sys,&nbsp;coup_op,&nbsp;coup_strength,&nbsp;...)</td>
<td>Calls configure from <a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver" title="qutip.nonmarkov.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> and sets any attributes that are specific to this subclass</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_new_stats</span></code>()</td>
<td>Creates a new stats object suitable for use with this solver Note: this solver expects the stats object to have sections     config     integrate</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.nonmarkov.heom.HSolverDL.reset" title="qutip.nonmarkov.heom.HSolverDL.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>Reset any attributes to default values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.nonmarkov.heom.HSolverDL.run" title="qutip.nonmarkov.heom.HSolverDL.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>(rho0,&nbsp;tlist)</td>
<td>Function to solve for an open quantum system using the HEOM model.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.nonmarkov.heom.HSolverDL.configure">
<code class="descname">configure</code><span class="sig-paren">(</span><em>H_sys</em>, <em>coup_op</em>, <em>coup_strength</em>, <em>temperature</em>, <em>N_cut</em>, <em>N_exp</em>, <em>cut_freq</em>, <em>planck=None</em>, <em>boltzmann=None</em>, <em>renorm=None</em>, <em>bnd_cut_approx=None</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>stats=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HSolverDL.configure"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HSolverDL.configure" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls configure from <a class="reference internal" href="#qutip.nonmarkov.heom.HEOMSolver" title="qutip.nonmarkov.heom.HEOMSolver"><code class="xref py py-class docutils literal notranslate"><span class="pre">HEOMSolver</span></code></a> and sets any attributes
that are specific to this subclass</p>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.heom.HSolverDL.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HSolverDL.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HSolverDL.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset any attributes to default values</p>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.heom.HSolverDL.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>rho0</em>, <em>tlist</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/heom.html#HSolverDL.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.heom.HSolverDL.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to solve for an open quantum system using the
HEOM model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state (density matrix) of the system.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Time over which system evolves.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>results</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt>
<dd><p class="first last">Object storing all results from the simulation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade">
<em class="property">class </em><code class="descclassname">qutip.nonmarkov.memorycascade.</code><code class="descname">MemoryCascade</code><span class="sig-paren">(</span><em>H_S</em>, <em>L1</em>, <em>L2</em>, <em>S_matrix=None</em>, <em>c_ops_markov=None</em>, <em>integrator='propagator'</em>, <em>parallel=False</em>, <em>options=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/memorycascade.html#MemoryCascade"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for running memory cascade simulations of open quantum systems
with time-delayed coherent feedback.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H_S</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System Hamiltonian (can also be a Liouvillian)</p>
</dd>
<dt><strong>L1</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System operators coupling into the feedback loop. Can be a single
operator or a list of operators.</p>
</dd>
<dt><strong>L2</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System operators coupling out of the feedback loop. Can be a single
operator or a list of operators. L2 must have the same length as L1.</p>
</dd>
<dt><strong>S_matrix: *array*</strong></dt>
<dd><p class="first last">S matrix describing which operators in L1 are coupled to which
operators in L2 by the feedback channel. Defaults to an n by n identity
matrix where n is the number of elements in L1/L2.</p>
</dd>
<dt><strong>c_ops_markov</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Decay operators describing conventional Markovian decay channels.
Can be a single operator or a list of operators.</p>
</dd>
<dt><strong>integrator</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'propagator', 'mesolve'}</span></dt>
<dd><p class="first last">Integrator method to use. Defaults to 'propagator' which tends to be 
faster for long times (i.e., large Hilbert space).</p>
</dd>
<dt><strong>parallel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Run integrator in parallel if True. Only implemented for 'propagator'
as the integrator method.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt>
<dd><p class="first last">Generic solver options.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.nonmarkov.memorycascade.MemoryCascade.outfieldcorr" title="qutip.nonmarkov.memorycascade.MemoryCascade.outfieldcorr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outfieldcorr</span></code></a>(rho0,&nbsp;blist,&nbsp;tlist,&nbsp;tau[,&nbsp;c1,&nbsp;c2])</td>
<td>Compute output field expectation value &lt;O_n(tn)...O_2(t2)O_1(t1)&gt; for times t1,t2,...</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.nonmarkov.memorycascade.MemoryCascade.outfieldpropagator" title="qutip.nonmarkov.memorycascade.MemoryCascade.outfieldpropagator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outfieldpropagator</span></code></a>(blist,&nbsp;tlist,&nbsp;tau[,&nbsp;c1,&nbsp;...])</td>
<td>Compute propagator for computing output field expectation values &lt;O_n(tn)...O_2(t2)O_1(t1)&gt; for times t1,t2,...</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.nonmarkov.memorycascade.MemoryCascade.propagator" title="qutip.nonmarkov.memorycascade.MemoryCascade.propagator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propagator</span></code></a>(t,&nbsp;tau[,&nbsp;notrace])</td>
<td>Compute propagator for time t and time-delay tau</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.nonmarkov.memorycascade.MemoryCascade.rhot" title="qutip.nonmarkov.memorycascade.MemoryCascade.rhot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rhot</span></code></a>(rho0,&nbsp;t,&nbsp;tau)</td>
<td>Compute the reduced system density matrix <span class="math notranslate nohighlight">\(\rho(t)\)</span></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.outfieldcorr">
<code class="descname">outfieldcorr</code><span class="sig-paren">(</span><em>rho0</em>, <em>blist</em>, <em>tlist</em>, <em>tau</em>, <em>c1=None</em>, <em>c2=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.outfieldcorr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.outfieldcorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute output field expectation value
&lt;O_n(tn)...O_2(t2)O_1(t1)&gt; for times t1,t2,... and
O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>blist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of integers specifying the field operators:
0: I (nothing)
1: b_out
2: b_out^dagger
3: b_loop
4: b_loop^dagger</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of corresponding times t1,..,tn at which to evaluate the field
operators</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">time-delay</p>
</dd>
<dt><strong>c1</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">system collapse operator that couples to the in-loop field in
question (only needs to be specified if self.L1 has more than one
element)</p>
</dd>
<dt><strong>c2</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">system collapse operator that couples to the output field in
question (only needs to be specified if self.L2 has more than one
element)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>: complex</strong></dt>
<dd><p class="first last">expectation value of field correlation function</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.outfieldpropagator">
<code class="descname">outfieldpropagator</code><span class="sig-paren">(</span><em>blist</em>, <em>tlist</em>, <em>tau</em>, <em>c1=None</em>, <em>c2=None</em>, <em>notrace=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.outfieldpropagator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.outfieldpropagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute propagator for computing output field expectation values
&lt;O_n(tn)...O_2(t2)O_1(t1)&gt; for times t1,t2,... and
O_i = I, b_out, b_out^dagger, b_loop, b_loop^dagger</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>blist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of integers specifying the field operators:
0: I (nothing)
1: b_out
2: b_out^dagger
3: b_loop
4: b_loop^dagger</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of corresponding times t1,..,tn at which to evaluate the field
operators</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">time-delay</p>
</dd>
<dt><strong>c1</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">system collapse operator that couples to the in-loop field in
question (only needs to be specified if self.L1 has more than one
element)</p>
</dd>
<dt><strong>c2</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">system collapse operator that couples to the output field in
question (only needs to be specified if self.L2 has more than one
element)</p>
</dd>
<dt><strong>notrace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False}</span></dt>
<dd><p class="first last">If this optional is set to True, a propagator is returned for a
cascade of k systems, where <span class="math notranslate nohighlight">\((k-1) tau &lt; t &lt; k tau\)</span>.
If set to False (default), a generalized partial trace is performed
and a propagator for a single system is returned.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>: :class:`qutip.Qobj`</strong></dt>
<dd><p class="first last">time-propagator for computing field correlation function</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.propagator">
<code class="descname">propagator</code><span class="sig-paren">(</span><em>t</em>, <em>tau</em>, <em>notrace=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.propagator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute propagator for time t and time-delay tau</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>float</em></span></dt>
<dd><p class="first last">current time</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>float</em></span></dt>
<dd><p class="first last">time-delay</p>
</dd>
<dt><strong>notrace</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>bool</em> {False}</span></dt>
<dd><p class="first last">If this optional is set to True, a propagator is returned for a
cascade of k systems, where <span class="math notranslate nohighlight">\((k-1) tau &lt; t &lt; k tau\)</span>.
If set to False (default), a generalized partial trace is performed
and a propagator for a single system is returned.</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>-------</strong></dt>
<dd></dd>
<dt><strong>: :class:`qutip.Qobj`</strong></dt>
<dd><p class="first last">time-propagator for reduced system dynamics</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.nonmarkov.memorycascade.MemoryCascade.rhot">
<code class="descname">rhot</code><span class="sig-paren">(</span><em>rho0</em>, <em>t</em>, <em>tau</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/memorycascade.html#MemoryCascade.rhot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.memorycascade.MemoryCascade.rhot" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the reduced system density matrix <span class="math notranslate nohighlight">\(\rho(t)\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">initial density matrix or state vector (ket)</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">current time</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">time-delay</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>: :class:`qutip.Qobj`</strong></dt>
<dd><p class="first last">density matrix at time <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.nonmarkov.transfertensor.TTMSolverOptions">
<em class="property">class </em><code class="descclassname">qutip.nonmarkov.transfertensor.</code><code class="descname">TTMSolverOptions</code><span class="sig-paren">(</span><em>dynmaps=None</em>, <em>times=[]</em>, <em>learningtimes=[]</em>, <em>thres=0.0</em>, <em>options=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/transfertensor.html#TTMSolverOptions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.transfertensor.TTMSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of options for the Transfer Tensor Method solver.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dynmaps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">List of precomputed dynamical maps (superoperators),
or a callback function that returns the
superoperator at a given time.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of times <span class="math notranslate nohighlight">\(t_n\)</span> at which to calculate <span class="math notranslate nohighlight">\(\rho(t_n)\)</span></p>
</dd>
<dt><strong>learningtimes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of times <span class="math notranslate nohighlight">\(t_k\)</span> to use as learning times if argument
<cite>dynmaps</cite> is a callback function.</p>
</dd>
<dt><strong>thres</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Threshold for halting. Halts if  <span class="math notranslate nohighlight">\(||T_{n}-T_{n-1}||\)</span> is below
treshold.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt>
<dd><p class="first last">Generic solver options.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="solver-options-and-results">
<span id="classes-odeoptions"></span><h2>Solver Options and Results<a class="headerlink" href="#solver-options-and-results" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.solver.Options">
<em class="property">class </em><code class="descclassname">qutip.solver.</code><code class="descname">Options</code><span class="sig-paren">(</span><em>atol=1e-08</em>, <em>rtol=1e-06</em>, <em>method='adams'</em>, <em>order=12</em>, <em>nsteps=1000</em>, <em>first_step=0</em>, <em>max_step=0</em>, <em>min_step=0</em>, <em>average_expect=True</em>, <em>average_states=False</em>, <em>tidy=True</em>, <em>num_cpus=0</em>, <em>norm_tol=0.001</em>, <em>norm_steps=5</em>, <em>rhs_reuse=False</em>, <em>rhs_filename=None</em>, <em>ntraj=500</em>, <em>gui=False</em>, <em>rhs_with_state=False</em>, <em>store_final_state=False</em>, <em>store_states=False</em>, <em>seeds=None</em>, <em>steady_state_average=False</em>, <em>normalize_output=True</em>, <em>use_openmp=None</em>, <em>openmp_threads=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Options"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Options" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of options for evolution solvers such as <a class="reference internal" href="functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve()</span></code></a> and
<a class="reference internal" href="functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve()</span></code></a>. Options can be specified either as arguments to the
constructor:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>or by changing the class attributes after creation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">opts</span> <span class="o">=</span> <span class="n">Options</span><span class="p">()</span>
<span class="n">opts</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>Returns options class to be used as options in evolution solvers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {1e-8}</span></dt>
<dd><p class="first last">Absolute tolerance.</p>
</dd>
<dt><strong>rtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {1e-6}</span></dt>
<dd><p class="first last">Relative tolerance.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'adams','bdf'}</span></dt>
<dd><p class="first last">Integration method.</p>
</dd>
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {12}</span></dt>
<dd><p class="first last">Order of integrator (&lt;=12 'adams', &lt;=5 'bdf')</p>
</dd>
<dt><strong>nsteps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {2500}</span></dt>
<dd><p class="first last">Max. number of internal steps/call.</p>
</dd>
<dt><strong>first_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {0}</span></dt>
<dd><p class="first last">Size of initial step (0 = automatic).</p>
</dd>
<dt><strong>min_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {0}</span></dt>
<dd><p class="first last">Minimum step size (0 = automatic).</p>
</dd>
<dt><strong>max_step</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {0}</span></dt>
<dd><p class="first last">Maximum step size (0 = automatic)</p>
</dd>
<dt><strong>tidy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True,False}</span></dt>
<dd><p class="first last">Tidyup Hamiltonian and initial state by removing small terms.</p>
</dd>
<dt><strong>num_cpus</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of cpus used by mcsolver (default = # of cpus).</p>
</dd>
<dt><strong>norm_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used when finding wavefunction norm in mcsolve.</p>
</dd>
<dt><strong>norm_steps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Max. number of steps used to find wavefunction norm to within norm_tol
in mcsolve.</p>
</dd>
<dt><strong>average_states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False}</span></dt>
<dd><p class="first last">Average states values over trajectories in stochastic solvers.</p>
</dd>
<dt><strong>average_expect</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True}</span></dt>
<dd><p class="first last">Average expectation values over trajectories for stochastic solvers.</p>
</dd>
<dt><strong>mc_corr_eps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {1e-10}</span></dt>
<dd><p class="first last">Arbitrarily small value for eliminating any divide-by-zero errors in
correlation calculations when using mcsolve.</p>
</dd>
<dt><strong>ntraj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {500}</span></dt>
<dd><p class="first last">Number of trajectories in stochastic solvers.</p>
</dd>
<dt><strong>openmp_threads</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of OPENMP threads to use. Default is number of cpu cores.</p>
</dd>
<dt><strong>rhs_reuse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False,True}</span></dt>
<dd><p class="first last">Reuse Hamiltonian data.</p>
</dd>
<dt><strong>rhs_with_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False,True}</span></dt>
<dd><p class="first last">Whether or not to include the state in the Hamiltonian function
callback signature.</p>
</dd>
<dt><strong>rhs_filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name for compiled Cython file.</p>
</dd>
<dt><strong>seeds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array containing random number seeds for mcsolver.</p>
</dd>
<dt><strong>store_final_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Whether or not to store the final state of the evolution in the
result class.</p>
</dd>
<dt><strong>store_states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Whether or not to store the state vectors or density matrices in the
result class, even if expectation values operators are given. If no
expectation are provided, then states are stored by default and this
option has no effect.</p>
</dd>
<dt><strong>use_openmp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True, False}</span></dt>
<dd><p class="first last">Use OPENMP for sparse matrix vector multiplication. Default
None means auto check.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.solver.Result">
<em class="property">class </em><code class="descclassname">qutip.solver.</code><code class="descname">Result</code><a class="reference internal" href="../_modules/qutip/solver.html#Result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Result" title="Permalink to this definition">¶</a></dt>
<dd><p>Class for storing simulation results from any of the dynamics solvers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Which solver was used [e.g., 'mesolve', 'mcsolve', 'brmesolve', ...]</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Times at which simulation data was collected.</p>
</dd>
<dt><strong>expect</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Expectation values (if requested) for simulation.</p>
</dd>
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">State of the simulation (density matrix or ket) evaluated at <code class="docutils literal notranslate"><span class="pre">times</span></code>.</p>
</dd>
<dt><strong>num_expect</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of expectation value operators in simulation.</p>
</dd>
<dt><strong>num_collapse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of collapse operators in simualation.</p>
</dd>
<dt><strong>ntraj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/list</span></dt>
<dd><p class="first last">Number of trajectories (for stochastic solvers). A list indicates
that averaging of expectation values was done over a subset of total
number of trajectories.</p>
</dd>
<dt><strong>col_times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Times at which state collpase occurred. Only for Monte Carlo solver.</p>
</dd>
<dt><strong>col_which</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Which collapse operator was responsible for each collapse in
<code class="docutils literal notranslate"><span class="pre">col_times</span></code>. Only for Monte Carlo solver.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.solver.Stats">
<em class="property">class </em><code class="descclassname">qutip.solver.</code><code class="descname">Stats</code><span class="sig-paren">(</span><em>section_names=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Statistical information on the solver performance
Statistics can be grouped into sections.
If no section names are given in the the contructor, then all statistics
will be added to one section 'main'</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>section_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of keys that will be used as keys for the sections
These keys will also be used as names for the sections
The text in the output can be overidden by setting the header property
of the section
If no names are given then one section called 'main' is created</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sections</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OrderedDict of _StatsSection</span></dt>
<dd><p class="first last">These are the sections that are created automatically on instantiation
or added using add_section</p>
</dd>
<dt><strong>header</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Some text that will be used as the heading in the report
By default there is None</p>
</dd>
<dt><strong>total_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Time in seconds for the solver to complete processing
Can be None, meaning that total timing percentages will be reported</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.solver.Stats.add_section" title="qutip.solver.Stats.add_section"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_section</span></code></a>(name)</td>
<td>Add another section with the given name</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.solver.Stats.add_count" title="qutip.solver.Stats.add_count"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_count</span></code></a>(key,&nbsp;value[,&nbsp;section])</td>
<td>Add value to count.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.solver.Stats.add_timing" title="qutip.solver.Stats.add_timing"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_timing</span></code></a>(key,&nbsp;value[,&nbsp;section])</td>
<td>Add value to timing.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.solver.Stats.add_message" title="qutip.solver.Stats.add_message"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_message</span></code></a>(key,&nbsp;value[,&nbsp;section,&nbsp;sep])</td>
<td>Add value to message.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>report:</strong></td>
<td>Output the statistics report to console or file.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.solver.Stats.add_count">
<code class="descname">add_count</code><span class="sig-paren">(</span><em>key</em>, <em>value</em>, <em>section=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.add_count"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.add_count" title="Permalink to this definition">¶</a></dt>
<dd><p>Add value to count. If key does not already exist in section then
it is created with this value.
If key already exists it is increased by the give value
value is expected to be an integer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">key for the section.counts dictionary
reusing a key will result in numerical addition of value</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Initial value of the count, or added to an existing count</p>
</dd>
<dt><strong>section: string or `class`</strong> <span class="classifier-delimiter">:</span> <span class="classifier">_StatsSection</span></dt>
<dd><p class="first last">Section which to add the count to.
If None given, the default (first) section will be used</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.solver.Stats.add_message">
<code class="descname">add_message</code><span class="sig-paren">(</span><em>key</em>, <em>value</em>, <em>section=None</em>, <em>sep=';'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.add_message"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.add_message" title="Permalink to this definition">¶</a></dt>
<dd><p>Add value to message. If key does not already exist in section then
it is created with this value.
If key already exists the value is added to the message
The value will be converted to a string</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">key for the section.messages dictionary
reusing a key will result in concatenation of value</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Initial value of the message, or added to an existing message</p>
</dd>
<dt><strong>sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Message will be prefixed with this string when concatenating</p>
</dd>
<dt><strong>section: string or `class`</strong> <span class="classifier-delimiter">:</span> <span class="classifier">_StatsSection</span></dt>
<dd><p class="first last">Section which to add the message to.
If None given, the default (first) section will be used</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.solver.Stats.add_section">
<code class="descname">add_section</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.add_section"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.add_section" title="Permalink to this definition">¶</a></dt>
<dd><p>Add another section with the given name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">will be used as key for sections dict
will also be the header for the section</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>section</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><cite>class</cite></span></dt>
<dd><p class="first last">The new section</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.solver.Stats.add_timing">
<code class="descname">add_timing</code><span class="sig-paren">(</span><em>key</em>, <em>value</em>, <em>section=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.add_timing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.add_timing" title="Permalink to this definition">¶</a></dt>
<dd><p>Add value to timing. If key does not already exist in section then
it is created with this value.
If key already exists it is increased by the give value
value is expected to be a float, and given in seconds.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">key for the section.timings dictionary
reusing a key will result in numerical addition of value</p>
</dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Initial value of the timing, or added to an existing timing</p>
</dd>
<dt><strong>section: string or `class`</strong> <span class="classifier-delimiter">:</span> <span class="classifier">_StatsSection</span></dt>
<dd><p class="first last">Section which to add the timing to.
If None given, the default (first) section will be used</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.solver.Stats.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear counts, timings and messages from all sections</p>
</dd></dl>

<dl class="method">
<dt id="qutip.solver.Stats.report">
<code class="descname">report</code><span class="sig-paren">(</span><em>output=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='UTF-8'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Report the counts, timings and messages from the sections.
Sections are reported in the order that the names were supplied
in the constructor.
The counts, timings and messages are reported in the order that they
are added to the sections
The output can be written to anything that supports a write method,
e.g. a file or the console (default)
The output is intended to in markdown format</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">stream</span></dt>
<dd><p class="first last">file or console stream - anything that support write - where
the output will be written</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.solver.Stats.set_total_time">
<code class="descname">set_total_time</code><span class="sig-paren">(</span><em>value</em>, <em>section=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/solver.html#Stats.set_total_time"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.solver.Stats.set_total_time" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the total time for the complete solve or for a specific section
value is expected to be a float, and given in seconds</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Time in seconds to complete the solver section</p>
</dd>
<dt><strong>section</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or <cite>class</cite></span></dt>
<dd><p class="first last">Section which to set the total_time for
If None given, the total_time for complete solve is set</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.stochastic.StochasticSolverOptions">
<em class="property">class </em><code class="descclassname">qutip.stochastic.</code><code class="descname">StochasticSolverOptions</code><span class="sig-paren">(</span><em>me</em>, <em>H=None</em>, <em>c_ops=[]</em>, <em>sc_ops=[]</em>, <em>state0=None</em>, <em>e_ops=[]</em>, <em>m_ops=None</em>, <em>store_all_expect=False</em>, <em>store_measurement=False</em>, <em>dW_factors=None</em>, <em>solver=None</em>, <em>method='homodyne'</em>, <em>normalize=None</em>, <em>times=None</em>, <em>nsubsteps=1</em>, <em>ntraj=1</em>, <em>tol=None</em>, <em>generate_noise=None</em>, <em>noise=None</em>, <em>progress_bar=None</em>, <em>map_func=None</em>, <em>map_kwargs=None</em>, <em>args={}</em>, <em>options=None</em>, <em>noiseDepth=20</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#StochasticSolverOptions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.StochasticSolverOptions" title="Permalink to this definition">¶</a></dt>
<dd><p>Class of options for stochastic solvers such as
<a class="reference internal" href="functions.html#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.ssesolve()</span></code></a>, <a class="reference internal" href="functions.html#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.smesolve()</span></code></a>, etc.</p>
<p>The stochastic solvers <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.general_stochastic()</span></code>,
<a class="reference internal" href="functions.html#qutip.stochastic.ssesolve" title="qutip.stochastic.ssesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.ssesolve()</span></code></a>, <a class="reference internal" href="functions.html#qutip.stochastic.smesolve" title="qutip.stochastic.smesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.smesolve()</span></code></a>,
<code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.photocurrent_sesolve()</span></code> and
<code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.photocurrent_mesolve()</span></code>
all take the same keyword arguments as
the constructor of these class, and internally they use these arguments to
construct an instance of this class, so it is rarely needed to explicitly
create an instance of this class.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, time-dependent Qobj as a list*</span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>state0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Initial state vector (ket) or density matrix.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code> or [Qobj, coeff*]</span></dt>
<dd><p class="first last">List of deterministic collapse operators.</p>
</dd>
<dt><strong>sc_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.QobjEvo</span></code> or [Qobj, coeff*]</span></dt>
<dd><p class="first last">List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the equation of motion according to how the d1 and d2 functions
are defined.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>m_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">List of operators representing the measurement operators. The expected
format is a nested list with one measurement operator for each
stochastic increament, for each stochastic collapse operator.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of parameters for time dependent systems.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance of the solver for implicit methods.</p>
</dd>
<dt><strong>ntraj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of trajectors.</p>
</dd>
<dt><strong>nsubsteps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of sub steps between each time-spep given in <cite>times</cite>.</p>
</dd>
<dt><strong>dW_factors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of length len(sc_ops), containing scaling factors for each
measurement operator in m_ops.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of the solver method to use for solving the stochastic
equations. Valid values are:
order 1/2 algorithms: 'euler-maruyama', 'pc-euler', 'pc-euler-imp'
order 1 algorithms: 'milstein', 'platen', 'milstein-imp', 'rouchon'
order 3/2 algorithms: 'taylor1.5', 'taylor1.5-imp', 'explicit1.5'
order 2 algorithms: 'taylor2.0'
call help of <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.stochastic.stochastic_solvers()</span></code>
for a description of the solvers.
Implicit methods can adjust tolerance via the kw 'tol'
default is {'tol':1e-6}</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string ('homodyne', 'heterodyne')</span></dt>
<dd><p class="first last">The name of the type of measurement process that give rise to the
stochastic equation to solve.</p>
</dd>
<dt><strong>store_all_expect</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (default False)</span></dt>
<dd><p class="first last">Whether or not to store the e_ops expect values for all paths.</p>
</dd>
<dt><strong>store_measurement</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (default False)</span></dt>
<dd><p class="first last">Whether or not to store the measurement results in the
<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.SolverResult</span></code> instance returned by the solver.</p>
</dd>
<dt><strong>noise</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, array[int, 1d], array[double, 4d]</span></dt>
<dd><p class="first">int : seed of the noise
array[int, 1d], length = ntraj, seeds for each trajectories
array[double, 4d] (ntraj, len(times), nsubsteps, len(sc_ops)*[1|2])</p>
<blockquote class="last">
<div><p>vector for the noise, the len of the last dimensions is doubled for
solvers of order 1.5. The correspond to results.noise</p>
</div></blockquote>
</dd>
<dt><strong>noiseDepth</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of terms kept of the truncated series used to create the
noise used by taylor2.0 solver.</p>
</dd>
<dt><strong>normalize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">(default True for (photo)ssesolve, False for (photo)smesolve)
Whether or not to normalize the wave function during the evolution.
Normalizing density matrices introduce numerical errors.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt>
<dd><p class="first last">Generic solver options. Only options.average_states and
options.store_states are used.</p>
</dd>
<dt><strong>map_func: function</strong></dt>
<dd><p class="first last">A map function or managing the calls to single-trajactory solvers.</p>
</dd>
<dt><strong>map_kwargs: dictionary</strong></dt>
<dd><p class="first last">Optional keyword arguments to the map_func function function.</p>
</dd>
<dt><strong>progress_bar</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.ui.BaseProgressBar</span></code></span></dt>
<dd><p class="first last">Optional progress bar class instance.</p>
</dd>
</dl>
<blockquote>
<div></div></blockquote>
<dl class="last docutils">
<dt><strong>time-dependent Qobj can be used for H, c_ops and sc_ops.</strong></dt>
<dd></dd>
<dt><strong>The format for time-dependent system hamiltonian is:</strong></dt>
<dd></dd>
<dt><strong>H = [Qobj0,[Qobj1,coeff1],[Qobj2,coeff2],...]</strong></dt>
<dd><p class="first last">= Qobj0 + Qobj1 * coeff1(t) + Qobj2 * coeff2(t)</p>
</dd>
<dt><strong>coeff function can be:</strong></dt>
<dd><p class="first last">function: coeff(t, args) -&gt; complex
str: &quot;sin(1j*w*t)&quot;
np.array[complex, 1d] of length equal to the times array</p>
</dd>
<dt><strong>The argument args for the function coeff is the args keyword argument of</strong></dt>
<dd><p class="first last">the stochastic solver.</p>
</dd>
<dt><strong>Likewisem in str cases, the parameters ('w' in this case) are taken from</strong></dt>
<dd><p class="first last">the args keywords argument.</p>
</dd>
<dt><strong>*While mixing coeff type does not results in errors, it is not recommended.*</strong></dt>
<dd></dd>
<dt><strong>For the collapse operators (c_ops, sc_ops):</strong></dt>
<dd></dd>
<dt><strong>Each operators can only be composed of 1 Qobj.</strong></dt>
<dd></dd>
<dt><strong>c_ops = [c_op1, c_op2, ...]</strong></dt>
<dd></dd>
<dt><strong>where, c_opN = Qobj or [Qobj,coeff]</strong></dt>
<dd></dd>
<dt><strong>The coeff format is the same as for the Hamiltonian.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>set_solver</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="distribution-functions">
<span id="classes-distributions"></span><h2>Distribution functions<a class="headerlink" href="#distribution-functions" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.distributions.Distribution">
<em class="property">class </em><code class="descclassname">qutip.distributions.</code><code class="descname">Distribution</code><span class="sig-paren">(</span><em>data=None</em>, <em>xvecs=[]</em>, <em>xlabels=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#Distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.Distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>A class for representation spatial distribution functions.</p>
<p>The Distribution class can be used to prepresent spatial distribution
functions of arbitray dimension (although only 1D and 2D distributions
are used so far).</p>
<p>It is indented as a base class for specific distribution function, and
provide implementation of basic functions that are shared among all
Distribution functions, such as visualization, calculating marginal
distributions, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Data for the distribution. The dimensions must match the lengths of
the coordinate arrays in xvecs.</p>
</dd>
<dt><strong>xvecs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of arrays that spans the space for each coordinate.</p>
</dd>
<dt><strong>xlabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of labels for each coordinate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.distributions.Distribution.marginal" title="qutip.distributions.Distribution.marginal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">marginal</span></code></a>([dim])</td>
<td>Calculate the marginal distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.distributions.Distribution.project" title="qutip.distributions.Distribution.project"><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code></a>([dim])</td>
<td>Calculate the projection (max value) distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.distributions.Distribution.visualize" title="qutip.distributions.Distribution.visualize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualize</span></code></a>([fig,&nbsp;ax,&nbsp;figsize,&nbsp;colorbar,&nbsp;...])</td>
<td>Visualize the data of the distribution in 1D or 2D, depending on the dimensionality of the underlaying distribution.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>visualize_1d</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_2d_colormap</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>visualize_2d_surface</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.distributions.Distribution.marginal">
<code class="descname">marginal</code><span class="sig-paren">(</span><em>dim=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#Distribution.marginal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.Distribution.marginal" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the marginal distribution function along the dimension
<cite>dim</cite>. Return a new Distribution instance describing this reduced-
dimensionality distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The dimension (coordinate index) along which to obtain the
marginal distribution.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distributions</span></dt>
<dd><p class="first last">A new instances of Distribution that describes the marginal
distribution.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.distributions.Distribution.project">
<code class="descname">project</code><span class="sig-paren">(</span><em>dim=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#Distribution.project"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.Distribution.project" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the projection (max value) distribution function along the
dimension <cite>dim</cite>. Return a new Distribution instance describing this
reduced-dimensionality distribution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The dimension (coordinate index) along which to obtain the
projected distribution.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Distributions</span></dt>
<dd><p class="first last">A new instances of Distribution that describes the projection.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.distributions.Distribution.visualize">
<code class="descname">visualize</code><span class="sig-paren">(</span><em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>colorbar=True</em>, <em>cmap=None</em>, <em>style='colormap'</em>, <em>show_xlabel=True</em>, <em>show_ylabel=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#Distribution.visualize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.Distribution.visualize" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the data of the distribution in 1D or 2D, depending
on the dimensionality of the underlaying distribution.</p>
<p>Parameters:</p>
<dl class="docutils">
<dt>fig <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib Figure instance</span></dt>
<dd>If given, use this figure instance for the visualization,</dd>
<dt>ax <span class="classifier-delimiter">:</span> <span class="classifier">matplotlib Axes instance</span></dt>
<dd>If given, render the visualization using this axis instance.</dd>
<dt>figsize <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd>Size of the new Figure instance, if one needs to be created.</dd>
<dt>colorbar: Bool</dt>
<dd>Whether or not the colorbar (in 2D visualization) should be used.</dd>
<dt>cmap: matplotlib colormap instance</dt>
<dd>If given, use this colormap for 2D visualizations.</dd>
<dt>style <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd>Type of visualization: 'colormap' (default) or 'surface'.</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of matplotlib figure and axes instances.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.distributions.WignerDistribution">
<em class="property">class </em><code class="descclassname">qutip.distributions.</code><code class="descname">WignerDistribution</code><span class="sig-paren">(</span><em>rho=None, extent=[[-5, 5], [-5, 5]], steps=250</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#WignerDistribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.WignerDistribution" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">marginal</span></code>([dim])</td>
<td>Calculate the marginal distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code>([dim])</td>
<td>Calculate the projection (max value) distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualize</span></code>([fig,&nbsp;ax,&nbsp;figsize,&nbsp;colorbar,&nbsp;...])</td>
<td>Visualize the data of the distribution in 1D or 2D, depending on the dimensionality of the underlaying distribution.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>update</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_1d</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>visualize_2d_colormap</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_2d_surface</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.distributions.QDistribution">
<em class="property">class </em><code class="descclassname">qutip.distributions.</code><code class="descname">QDistribution</code><span class="sig-paren">(</span><em>rho=None, extent=[[-5, 5], [-5, 5]], steps=250</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#QDistribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.QDistribution" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">marginal</span></code>([dim])</td>
<td>Calculate the marginal distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code>([dim])</td>
<td>Calculate the projection (max value) distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualize</span></code>([fig,&nbsp;ax,&nbsp;figsize,&nbsp;colorbar,&nbsp;...])</td>
<td>Visualize the data of the distribution in 1D or 2D, depending on the dimensionality of the underlaying distribution.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>update</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_1d</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>visualize_2d_colormap</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_2d_surface</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation">
<em class="property">class </em><code class="descclassname">qutip.distributions.</code><code class="descname">TwoModeQuadratureCorrelation</code><span class="sig-paren">(</span><em>state=None, theta1=0.0, theta2=0.0, extent=[[-5, 5], [-5, 5]], steps=250</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#TwoModeQuadratureCorrelation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">marginal</span></code>([dim])</td>
<td>Calculate the marginal distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code>([dim])</td>
<td>Calculate the projection (max value) distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.distributions.TwoModeQuadratureCorrelation.update" title="qutip.distributions.TwoModeQuadratureCorrelation.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(state)</td>
<td>calculate probability distribution for quadrature measurement outcomes given a two-mode wavefunction or density matrix</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.distributions.TwoModeQuadratureCorrelation.update_psi" title="qutip.distributions.TwoModeQuadratureCorrelation.update_psi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_psi</span></code></a>(psi)</td>
<td>calculate probability distribution for quadrature measurement outcomes given a two-mode wavefunction</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.distributions.TwoModeQuadratureCorrelation.update_rho" title="qutip.distributions.TwoModeQuadratureCorrelation.update_rho"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_rho</span></code></a>(rho)</td>
<td>calculate probability distribution for quadrature measurement outcomes given a two-mode density matrix</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualize</span></code>([fig,&nbsp;ax,&nbsp;figsize,&nbsp;colorbar,&nbsp;...])</td>
<td>Visualize the data of the distribution in 1D or 2D, depending on the dimensionality of the underlaying distribution.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>visualize_1d</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_2d_colormap</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>visualize_2d_surface</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#TwoModeQuadratureCorrelation.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation.update" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate probability distribution for quadrature measurement
outcomes given a two-mode wavefunction or density matrix</p>
</dd></dl>

<dl class="method">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation.update_psi">
<code class="descname">update_psi</code><span class="sig-paren">(</span><em>psi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#TwoModeQuadratureCorrelation.update_psi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation.update_psi" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate probability distribution for quadrature measurement
outcomes given a two-mode wavefunction</p>
</dd></dl>

<dl class="method">
<dt id="qutip.distributions.TwoModeQuadratureCorrelation.update_rho">
<code class="descname">update_rho</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#TwoModeQuadratureCorrelation.update_rho"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.TwoModeQuadratureCorrelation.update_rho" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate probability distribution for quadrature measurement
outcomes given a two-mode density matrix</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.distributions.HarmonicOscillatorWaveFunction">
<em class="property">class </em><code class="descclassname">qutip.distributions.</code><code class="descname">HarmonicOscillatorWaveFunction</code><span class="sig-paren">(</span><em>psi=None, omega=1.0, extent=[-5, 5], steps=250</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#HarmonicOscillatorWaveFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorWaveFunction" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">marginal</span></code>([dim])</td>
<td>Calculate the marginal distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code>([dim])</td>
<td>Calculate the projection (max value) distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.distributions.HarmonicOscillatorWaveFunction.update" title="qutip.distributions.HarmonicOscillatorWaveFunction.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(psi)</td>
<td>Calculate the wavefunction for the given state of an harmonic oscillator</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualize</span></code>([fig,&nbsp;ax,&nbsp;figsize,&nbsp;colorbar,&nbsp;...])</td>
<td>Visualize the data of the distribution in 1D or 2D, depending on the dimensionality of the underlaying distribution.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>visualize_1d</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_2d_colormap</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>visualize_2d_surface</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.distributions.HarmonicOscillatorWaveFunction.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>psi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#HarmonicOscillatorWaveFunction.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorWaveFunction.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the wavefunction for the given state of an harmonic
oscillator</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.distributions.HarmonicOscillatorProbabilityFunction">
<em class="property">class </em><code class="descclassname">qutip.distributions.</code><code class="descname">HarmonicOscillatorProbabilityFunction</code><span class="sig-paren">(</span><em>rho=None, omega=1.0, extent=[-5, 5], steps=250</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#HarmonicOscillatorProbabilityFunction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorProbabilityFunction" title="Permalink to this definition">¶</a></dt>
<dd><p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">marginal</span></code>([dim])</td>
<td>Calculate the marginal distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">project</span></code>([dim])</td>
<td>Calculate the projection (max value) distribution function along the dimension <cite>dim</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.distributions.HarmonicOscillatorProbabilityFunction.update" title="qutip.distributions.HarmonicOscillatorProbabilityFunction.update"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update</span></code></a>(rho)</td>
<td>Calculate the probability function for the given state of an harmonic oscillator (as density matrix)</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">visualize</span></code>([fig,&nbsp;ax,&nbsp;figsize,&nbsp;colorbar,&nbsp;...])</td>
<td>Visualize the data of the distribution in 1D or 2D, depending on the dimensionality of the underlaying distribution.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>visualize_1d</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>visualize_2d_colormap</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>visualize_2d_surface</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.distributions.HarmonicOscillatorProbabilityFunction.update">
<code class="descname">update</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/distributions.html#HarmonicOscillatorProbabilityFunction.update"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.distributions.HarmonicOscillatorProbabilityFunction.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the probability function for the given state of an harmonic
oscillator (as density matrix)</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="quantum-information-processing">
<span id="classes-qip"></span><h2>Quantum information processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.qip.circuit.Gate">
<em class="property">class </em><code class="descclassname">qutip.qip.circuit.</code><code class="descname">Gate</code><span class="sig-paren">(</span><em>name</em>, <em>targets=None</em>, <em>controls=None</em>, <em>arg_value=None</em>, <em>arg_label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#Gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.Gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of a quantum gate, with its required parametrs, and target
and control qubits.</p>
</dd></dl>

<dl class="class">
<dt id="qutip.qip.circuit.QubitCircuit">
<em class="property">class </em><code class="descclassname">qutip.qip.circuit.</code><code class="descname">QubitCircuit</code><span class="sig-paren">(</span><em>N</em>, <em>input_states=None</em>, <em>output_states=None</em>, <em>reverse_states=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of a quantum program/algorithm, maintaining a sequence
of gates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>png</strong></dt>
<dd></dd>
<dt><strong>svg</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.add_1q_gate" title="qutip.qip.circuit.QubitCircuit.add_1q_gate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_1q_gate</span></code></a>(name[,&nbsp;start,&nbsp;end,&nbsp;qubits,&nbsp;...])</td>
<td>Adds a single qubit gate with specified parameters on a variable number of qubits in the circuit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.add_circuit" title="qutip.qip.circuit.QubitCircuit.add_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_circuit</span></code></a>(qc[,&nbsp;start])</td>
<td>Adds a block of a qubit circuit to the main circuit.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.add_gate" title="qutip.qip.circuit.QubitCircuit.add_gate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_gate</span></code></a>(gate[,&nbsp;targets,&nbsp;controls,&nbsp;...])</td>
<td>Adds a gate with specified parameters to the circuit.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.add_state" title="qutip.qip.circuit.QubitCircuit.add_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_state</span></code></a>(state[,&nbsp;targets,&nbsp;state_type])</td>
<td>Add an input or ouput state to the circuit.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.adjacent_gates" title="qutip.qip.circuit.QubitCircuit.adjacent_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacent_gates</span></code></a>()</td>
<td>Method to resolve two qubit gates with non-adjacent control/s or target/s in terms of gates with adjacent interactions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.propagators" title="qutip.qip.circuit.QubitCircuit.propagators"><code class="xref py py-obj docutils literal notranslate"><span class="pre">propagators</span></code></a>()</td>
<td>Propagator matrix calculator for N qubits returning the individual steps as unitary matrices operating from left to right.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.remove_gate" title="qutip.qip.circuit.QubitCircuit.remove_gate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_gate</span></code></a>([index,&nbsp;end,&nbsp;name,&nbsp;remove])</td>
<td>Removes a gate from a specific index or between two indexes or the first, last or all instances of a particular gate.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.resolve_gates" title="qutip.qip.circuit.QubitCircuit.resolve_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">resolve_gates</span></code></a>([basis])</td>
<td>Unitary matrix calculator for N qubits returning the individual steps as unitary matrices operating from left to right in the specified basis.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.circuit.QubitCircuit.reverse_circuit" title="qutip.qip.circuit.QubitCircuit.reverse_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse_circuit</span></code></a>()</td>
<td>Reverses an entire circuit of unitary gates.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="58%" />
<col width="42%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>latex_code</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>qasm</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.add_1q_gate">
<code class="descname">add_1q_gate</code><span class="sig-paren">(</span><em>name</em>, <em>start=0</em>, <em>end=None</em>, <em>qubits=None</em>, <em>arg_value=None</em>, <em>arg_label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.add_1q_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_1q_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a single qubit gate with specified parameters on a variable
number of qubits in the circuit. By default, it applies the given gate
to all the qubits in the register.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">String</span></dt>
<dd><p class="first last">Gate name.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Integer</span></dt>
<dd><p class="first last">Starting location of qubits.</p>
</dd>
<dt><strong>end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Integer</span></dt>
<dd><p class="first last">Last qubit for the gate.</p>
</dd>
<dt><strong>qubits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List</span></dt>
<dd><p class="first last">Specific qubits for applying gates.</p>
</dd>
<dt><strong>arg_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Float</span></dt>
<dd><p class="first last">Argument value(phi).</p>
</dd>
<dt><strong>arg_label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">String</span></dt>
<dd><p class="first last">Label for gate representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.add_circuit">
<code class="descname">add_circuit</code><span class="sig-paren">(</span><em>qc</em>, <em>start=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.add_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a block of a qubit circuit to the main circuit.
Globalphase gates are not added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QubitCircuit</span></dt>
<dd><p class="first last">The circuit block to be added to the main circuit.</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Integer</span></dt>
<dd><p class="first last">The qubit on which the first gate is applied.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.add_gate">
<code class="descname">add_gate</code><span class="sig-paren">(</span><em>gate</em>, <em>targets=None</em>, <em>controls=None</em>, <em>arg_value=None</em>, <em>arg_label=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.add_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a gate with specified parameters to the circuit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gate: String or `Gate`</strong></dt>
<dd><p class="first last">Gate name. If gate is an instance of <cite>Gate</cite>, parameters are
unpacked and added.</p>
</dd>
<dt><strong>targets: List</strong></dt>
<dd><p class="first last">Gate targets.</p>
</dd>
<dt><strong>controls: List</strong></dt>
<dd><p class="first last">Gate controls.</p>
</dd>
<dt><strong>arg_value: Float</strong></dt>
<dd><p class="first last">Argument value(phi).</p>
</dd>
<dt><strong>arg_label: String</strong></dt>
<dd><p class="first last">Label for gate representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.add_state">
<code class="descname">add_state</code><span class="sig-paren">(</span><em>state</em>, <em>targets=None</em>, <em>state_type='input'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.add_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.add_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an input or ouput state to the circuit. By default all the input
and output states will be initialized to <cite>None</cite>. A particular state can
be added by specifying the state and the qubit where it has to be added
along with the type as input or output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state: str</strong></dt>
<dd><p class="first last">The state that has to be added. It can be any string such as <cite>0</cite>,
'+', &quot;A&quot;, &quot;Y&quot;</p>
</dd>
<dt><strong>targets: list</strong></dt>
<dd><p class="first last">A list of qubit positions where the given state has to be added.</p>
</dd>
<dt><strong>state_type: str</strong></dt>
<dd><p class="first last">One of either &quot;input&quot; or &quot;output&quot;. This specifies whether the state
to be added is an input or output.
default: &quot;input&quot;</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.adjacent_gates">
<code class="descname">adjacent_gates</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.adjacent_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve two qubit gates with non-adjacent control/s or
target/s in terms of gates with adjacent interactions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QubitCircuit</span></dt>
<dd><p class="first last">Returns QubitCircuit of the gates for the qubit circuit with the
resolved non-adjacent gates.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.propagators">
<code class="descname">propagators</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.propagators"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.propagators" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagator matrix calculator for N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Returns list of unitary matrices for the qubit circuit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.remove_gate">
<code class="descname">remove_gate</code><span class="sig-paren">(</span><em>index=None</em>, <em>end=None</em>, <em>name=None</em>, <em>remove='first'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.remove_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.remove_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes a gate from a specific index or between two indexes or the
first, last or all instances of a particular gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Integer</span></dt>
<dd><p class="first last">Location of gate to be removed.</p>
</dd>
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">String</span></dt>
<dd><p class="first last">Gate name to be removed.</p>
</dd>
<dt><strong>remove</strong> <span class="classifier-delimiter">:</span> <span class="classifier">String</span></dt>
<dd><p class="first last">If first or all gate are to be removed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.resolve_gates">
<code class="descname">resolve_gates</code><span class="sig-paren">(</span><em>basis=['CNOT', 'RX', 'RY', 'RZ']</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.resolve_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.resolve_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Unitary matrix calculator for N qubits returning the individual
steps as unitary matrices operating from left to right in the specified
basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>basis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list.</span></dt>
<dd><p class="first last">Basis of the resolved circuit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QubitCircuit</span></dt>
<dd><p class="first last">Returns QubitCircuit of resolved gates for the qubit circuit in the
desired basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.circuit.QubitCircuit.reverse_circuit">
<code class="descname">reverse_circuit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/circuit.html#QubitCircuit.reverse_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.circuit.QubitCircuit.reverse_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverses an entire circuit of unitary gates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc</strong> <span class="classifier-delimiter">:</span> <span class="classifier">QubitCircuit</span></dt>
<dd><p class="first last">Returns QubitCircuit of resolved gates for the qubit circuit in the
reverse order.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.qip.models.CircuitProcessor">
<em class="property">class </em><code class="descclassname">qutip.qip.models.</code><code class="descname">CircuitProcessor</code><span class="sig-paren">(</span><em>N</em>, <em>correct_global_phase</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for representation of the physical implementation of a quantum
program/algorithm on a specified qubit system.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.adjacent_gates" title="qutip.qip.models.CircuitProcessor.adjacent_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacent_gates</span></code></a>(qc,&nbsp;setup)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.get_ops_and_u" title="qutip.qip.models.CircuitProcessor.get_ops_and_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_and_u</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding values by stacking them together.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.get_ops_labels" title="qutip.qip.models.CircuitProcessor.get_ops_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_labels</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding labels by stacking them together.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.load_circuit" title="qutip.qip.models.CircuitProcessor.load_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_circuit</span></code></a>(qc)</td>
<td>Translates an abstract quantum circuit to its corresponding Hamiltonian for a specific model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.optimize_circuit" title="qutip.qip.models.CircuitProcessor.optimize_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_circuit</span></code></a>(qc)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.plot_pulses" title="qutip.qip.models.CircuitProcessor.plot_pulses"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_pulses</span></code></a>()</td>
<td>Maps the physical interaction between the circuit components for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.pulse_matrix" title="qutip.qip.models.CircuitProcessor.pulse_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pulse_matrix</span></code></a>()</td>
<td>Generates the pulse matrix for the desired physical system.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.run" title="qutip.qip.models.CircuitProcessor.run"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code></a>([qc])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.CircuitProcessor.run_state" title="qutip.qip.models.CircuitProcessor.run_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_state</span></code></a>([qc,&nbsp;states])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system with the given initial state of the qubit register.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="74%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>eliminate_auxillary_modes</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.adjacent_gates">
<code class="descname">adjacent_gates</code><span class="sig-paren">(</span><em>qc</em>, <em>setup</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.adjacent_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
<dt><strong>setup: String</strong></dt>
<dd><p class="first last">Takes the nature of the spin chain; linear or circular.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">The resolved circuit representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.get_ops_and_u">
<code class="descname">get_ops_and_u</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.get_ops_and_u"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding values by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.get_ops_labels">
<code class="descname">get_ops_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.get_ops_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.get_ops_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding labels by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.load_circuit">
<code class="descname">load_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.load_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates an abstract quantum circuit to its corresponding Hamiltonian
for a specific model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.optimize_circuit">
<code class="descname">optimize_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.optimize_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">The optimal circuit representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.plot_pulses">
<code class="descname">plot_pulses</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.plot_pulses"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.plot_pulses" title="Permalink to this definition">¶</a></dt>
<dd><p>Maps the physical interaction between the circuit components for the
desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax: Figure</strong></dt>
<dd><p class="first last">Maps the physical interaction between the circuit components.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.pulse_matrix">
<code class="descname">pulse_matrix</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.pulse_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.pulse_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the pulse matrix for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>t, u, labels:</strong></dt>
<dd><p class="first last">Returns the total time and label for every operation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>qc=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the propagator matrix by running the Hamiltonian for the
appropriate time duration for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_list: list</strong></dt>
<dd><p class="first last">The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.CircuitProcessor.run_state">
<code class="descname">run_state</code><span class="sig-paren">(</span><em>qc=None</em>, <em>states=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/circuitprocessor.html#CircuitProcessor.run_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.CircuitProcessor.run_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the propagator matrix by running the Hamiltonian for the
appropriate time duration for the desired physical system with the
given initial state of the qubit register.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
<dt><strong>states: Qobj</strong></dt>
<dd><p class="first last">Initial state of the qubits in the register.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_list: list</strong></dt>
<dd><p class="first last">The propagator matrix obtained from the physical implementation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.qip.models.spinchain.SpinChain">
<em class="property">class </em><code class="descclassname">qutip.qip.models.spinchain.</code><code class="descname">SpinChain</code><span class="sig-paren">(</span><em>N</em>, <em>correct_global_phase=True</em>, <em>sx=None</em>, <em>sz=None</em>, <em>sxsy=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#SpinChain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.SpinChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the physical implementation of a quantum
program/algorithm on a spin chain qubit system.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.spinchain.SpinChain.adjacent_gates" title="qutip.qip.models.spinchain.SpinChain.adjacent_gates"><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacent_gates</span></code></a>(qc[,&nbsp;setup])</td>
<td>Method to resolve 2 qubit gates with non-adjacent control/s or target/s in terms of gates with adjacent interactions for linear/circular spin chain system.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.spinchain.SpinChain.get_ops_and_u" title="qutip.qip.models.spinchain.SpinChain.get_ops_and_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_and_u</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding values by stacking them together.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_labels</span></code>()</td>
<td>Returns the Hamiltonian operators and corresponding labels by stacking them together.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.spinchain.SpinChain.load_circuit" title="qutip.qip.models.spinchain.SpinChain.load_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_circuit</span></code></a>(qc)</td>
<td>Translates an abstract quantum circuit to its corresponding Hamiltonian for a specific model.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_circuit</span></code>(qc)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_pulses</span></code>()</td>
<td>Maps the physical interaction between the circuit components for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">pulse_matrix</span></code>()</td>
<td>Generates the pulse matrix for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>([qc])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_state</span></code>([qc,&nbsp;states])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system with the given initial state of the qubit register.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="74%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>eliminate_auxillary_modes</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.qip.models.spinchain.SpinChain.adjacent_gates">
<code class="descname">adjacent_gates</code><span class="sig-paren">(</span><em>qc</em>, <em>setup='linear'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#SpinChain.adjacent_gates"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.SpinChain.adjacent_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve 2 qubit gates with non-adjacent control/s or target/s
in terms of gates with adjacent interactions for linear/circular spin
chain system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">The circular spin chain circuit to be resolved</p>
</dd>
<dt><strong>setup: Boolean</strong></dt>
<dd><p class="first last">Linear of Circular spin chain setup</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Returns QubitCircuit of resolved gates for the qubit circuit in the
desired basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.spinchain.SpinChain.get_ops_and_u">
<code class="descname">get_ops_and_u</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#SpinChain.get_ops_and_u"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.SpinChain.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding values by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.spinchain.SpinChain.load_circuit">
<code class="descname">load_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#SpinChain.load_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.SpinChain.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates an abstract quantum circuit to its corresponding Hamiltonian
for a specific model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.qip.models.spinchain.LinearSpinChain">
<em class="property">class </em><code class="descclassname">qutip.qip.models.spinchain.</code><code class="descname">LinearSpinChain</code><span class="sig-paren">(</span><em>N</em>, <em>correct_global_phase=True</em>, <em>sx=None</em>, <em>sz=None</em>, <em>sxsy=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#LinearSpinChain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.LinearSpinChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the physical implementation of a quantum
program/algorithm on a spin chain qubit system arranged in a linear
formation. It is a sub-class of SpinChain.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacent_gates</span></code>(qc[,&nbsp;setup])</td>
<td>Method to resolve 2 qubit gates with non-adjacent control/s or target/s in terms of gates with adjacent interactions for linear/circular spin chain system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_and_u</span></code>()</td>
<td>Returns the Hamiltonian operators and corresponding values by stacking them together.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.spinchain.LinearSpinChain.get_ops_labels" title="qutip.qip.models.spinchain.LinearSpinChain.get_ops_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_labels</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding labels by stacking them together.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_circuit</span></code>(qc)</td>
<td>Translates an abstract quantum circuit to its corresponding Hamiltonian for a specific model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.spinchain.LinearSpinChain.optimize_circuit" title="qutip.qip.models.spinchain.LinearSpinChain.optimize_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_circuit</span></code></a>(qc)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_pulses</span></code>()</td>
<td>Maps the physical interaction between the circuit components for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">pulse_matrix</span></code>()</td>
<td>Generates the pulse matrix for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>([qc])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_state</span></code>([qc,&nbsp;states])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system with the given initial state of the qubit register.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="74%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>eliminate_auxillary_modes</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.qip.models.spinchain.LinearSpinChain.get_ops_labels">
<code class="descname">get_ops_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#LinearSpinChain.get_ops_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.LinearSpinChain.get_ops_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding labels by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.spinchain.LinearSpinChain.optimize_circuit">
<code class="descname">optimize_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#LinearSpinChain.optimize_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.LinearSpinChain.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">The optimal circuit representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.qip.models.spinchain.CircularSpinChain">
<em class="property">class </em><code class="descclassname">qutip.qip.models.spinchain.</code><code class="descname">CircularSpinChain</code><span class="sig-paren">(</span><em>N</em>, <em>correct_global_phase=True</em>, <em>sx=None</em>, <em>sz=None</em>, <em>sxsy=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#CircularSpinChain"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.CircularSpinChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the physical implementation of a quantum
program/algorithm on a spin chain qubit system arranged in a circular
formation. It is a sub-class of SpinChain.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacent_gates</span></code>(qc[,&nbsp;setup])</td>
<td>Method to resolve 2 qubit gates with non-adjacent control/s or target/s in terms of gates with adjacent interactions for linear/circular spin chain system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_and_u</span></code>()</td>
<td>Returns the Hamiltonian operators and corresponding values by stacking them together.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.spinchain.CircularSpinChain.get_ops_labels" title="qutip.qip.models.spinchain.CircularSpinChain.get_ops_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_labels</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding labels by stacking them together.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_circuit</span></code>(qc)</td>
<td>Translates an abstract quantum circuit to its corresponding Hamiltonian for a specific model.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.spinchain.CircularSpinChain.optimize_circuit" title="qutip.qip.models.spinchain.CircularSpinChain.optimize_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_circuit</span></code></a>(qc)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_pulses</span></code>()</td>
<td>Maps the physical interaction between the circuit components for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">pulse_matrix</span></code>()</td>
<td>Generates the pulse matrix for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>([qc])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_state</span></code>([qc,&nbsp;states])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system with the given initial state of the qubit register.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="74%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>eliminate_auxillary_modes</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.qip.models.spinchain.CircularSpinChain.get_ops_labels">
<code class="descname">get_ops_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#CircularSpinChain.get_ops_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.CircularSpinChain.get_ops_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding labels by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.spinchain.CircularSpinChain.optimize_circuit">
<code class="descname">optimize_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/spinchain.html#CircularSpinChain.optimize_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.spinchain.CircularSpinChain.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">The optimal circuit representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.qip.models.cqed.DispersivecQED">
<em class="property">class </em><code class="descclassname">qutip.qip.models.cqed.</code><code class="descname">DispersivecQED</code><span class="sig-paren">(</span><em>N</em>, <em>correct_global_phase=True</em>, <em>Nres=None</em>, <em>deltamax=None</em>, <em>epsmax=None</em>, <em>w0=None</em>, <em>wq=None</em>, <em>eps=None</em>, <em>delta=None</em>, <em>g=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/cqed.html#DispersivecQED"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.cqed.DispersivecQED" title="Permalink to this definition">¶</a></dt>
<dd><p>Representation of the physical implementation of a quantum
program/algorithm on a dispersive cavity-QED system.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">adjacent_gates</span></code>(qc,&nbsp;setup)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.cqed.DispersivecQED.dispersive_gate_correction" title="qutip.qip.models.cqed.DispersivecQED.dispersive_gate_correction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dispersive_gate_correction</span></code></a>(qc1[,&nbsp;rwa])</td>
<td>Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding single qubit gates to get the correct output matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.cqed.DispersivecQED.get_ops_and_u" title="qutip.qip.models.cqed.DispersivecQED.get_ops_and_u"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_and_u</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding values by stacking them together.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.cqed.DispersivecQED.get_ops_labels" title="qutip.qip.models.cqed.DispersivecQED.get_ops_labels"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ops_labels</span></code></a>()</td>
<td>Returns the Hamiltonian operators and corresponding labels by stacking them together.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.qip.models.cqed.DispersivecQED.load_circuit" title="qutip.qip.models.cqed.DispersivecQED.load_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">load_circuit</span></code></a>(qc)</td>
<td>Translates an abstract quantum circuit to its corresponding Hamiltonian for a specific model.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.qip.models.cqed.DispersivecQED.optimize_circuit" title="qutip.qip.models.cqed.DispersivecQED.optimize_circuit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_circuit</span></code></a>(qc)</td>
<td>Function to take a quantum circuit/algorithm and convert it into the optimal form/basis for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot_pulses</span></code>()</td>
<td>Maps the physical interaction between the circuit components for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">pulse_matrix</span></code>()</td>
<td>Generates the pulse matrix for the desired physical system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run</span></code>([qc])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_state</span></code>([qc,&nbsp;states])</td>
<td>Generates the propagator matrix by running the Hamiltonian for the appropriate time duration for the desired physical system with the given initial state of the qubit register.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="74%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>eliminate_auxillary_modes</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.qip.models.cqed.DispersivecQED.dispersive_gate_correction">
<code class="descname">dispersive_gate_correction</code><span class="sig-paren">(</span><em>qc1</em>, <em>rwa=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/cqed.html#DispersivecQED.dispersive_gate_correction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.cqed.DispersivecQED.dispersive_gate_correction" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to resolve ISWAP and SQRTISWAP gates in a cQED system by adding
single qubit gates to get the correct output matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: Qobj</strong></dt>
<dd><p class="first last">The circular spin chain circuit to be resolved</p>
</dd>
<dt><strong>rwa: Boolean</strong></dt>
<dd><p class="first last">Specify if RWA is used or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Returns QubitCircuit of resolved gates for the qubit circuit in the
desired basis.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.cqed.DispersivecQED.get_ops_and_u">
<code class="descname">get_ops_and_u</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/cqed.html#DispersivecQED.get_ops_and_u"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.cqed.DispersivecQED.get_ops_and_u" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding values by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.cqed.DispersivecQED.get_ops_labels">
<code class="descname">get_ops_labels</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/cqed.html#DispersivecQED.get_ops_labels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.cqed.DispersivecQED.get_ops_labels" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hamiltonian operators and corresponding labels by stacking
them together.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.cqed.DispersivecQED.load_circuit">
<code class="descname">load_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/cqed.html#DispersivecQED.load_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.cqed.DispersivecQED.load_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates an abstract quantum circuit to its corresponding Hamiltonian
for a specific model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.qip.models.cqed.DispersivecQED.optimize_circuit">
<code class="descname">optimize_circuit</code><span class="sig-paren">(</span><em>qc</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/models/cqed.html#DispersivecQED.optimize_circuit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.models.cqed.DispersivecQED.optimize_circuit" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to take a quantum circuit/algorithm and convert it into the
optimal form/basis for the desired physical system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">Takes the quantum circuit to be implemented.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: QubitCircuit</strong></dt>
<dd><p class="first last">The optimal circuit representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="optimal-control">
<span id="classes-control"></span><h2>Optimal control<a class="headerlink" href="#optimal-control" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="qutip.control.optimizer.Optimizer">
<em class="property">class </em><code class="descclassname">qutip.control.optimizer.</code><code class="descname">Optimizer</code><span class="sig-paren">(</span><em>config</em>, <em>dyn</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all control pulse optimisers. This class should not be
instantiated, use its subclasses
This class implements the fidelity, gradient and interation callback
functions.
All subclass objects must be initialised with a</p>
<blockquote>
<div><p>OptimConfig instance - various configuration options
Dynamics instance - describes the dynamics of the (quantum) system</p>
<blockquote>
<div>to be control optimised</div></blockquote>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>params:  Dictionary</strong></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd>
<dt><strong>alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote class="last">
<div><p>'GRAPE' (default) - GRadient Ascent Pulse Engineering
'CRAB' - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">options that are specific to the pulse optim algorithm
that is GRAPE or CRAB</p>
</dd>
<dt><strong>disp_conv_msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Set true to display a convergence message
(for scipy.optimize.minimize methods anyway)</p>
</dd>
<dt><strong>optim_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error</p>
</dd>
<dt><strong>method_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">Options for the optim_method.
Note that where there is an equivalent attribute of this instance
or the termination_conditions (for example maxiter)
it will override an value in these options</p>
</dd>
<dt><strong>approx_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If set True then the method will approximate the gradient itself
(if it has requirement and facility for this)
This will mean that the fid_err_grad_wrapper will not get called
Note it should be left False when using the Dynamics
to calculate approximate gradients
Note it is set True automatically when the alg is CRAB</p>
</dd>
<dt><strong>amp_lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>bounds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of floats</span></dt>
<dd><p class="first last">Bounds for the parameters.
If not set before the run_optimization call then the list
is built automatically based on the amp_lbound and amp_ubound
attributes.
Setting this attribute directly allows specific bounds to be set
for individual parameters.
Note: Only some methods use bounds</p>
</dd>
<dt><strong>dynamics</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dynamics (subclass instance)</span></dt>
<dd><p class="first last">describes the dynamics of the (quantum) system to be control optimised
(see Dynamics classes for details)</p>
</dd>
<dt><strong>config</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OptimConfig instance</span></dt>
<dd><p class="first last">various configuration options
(see OptimConfig for details)</p>
</dd>
<dt><strong>termination_conditions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">TerminationCondition instance</span></dt>
<dd><p class="first last">attributes determine when the optimisation will end</p>
</dd>
<dt><strong>pulse_generator</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PulseGen (subclass instance)</span></dt>
<dd><p class="first last">(can be) used to create initial pulses
not used by the class, but set by pulseoptim.create_pulse_optimizer</p>
</dd>
<dt><strong>stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Stats</span></dt>
<dd><p class="first last">attributes of which give performance stats for the optimisation
set to None to reduce overhead of calculating stats.
Note it is (usually) shared with the Dynamics instance</p>
</dd>
<dt><strong>dump</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">dump.OptimDump</span></code></span></dt>
<dd><p class="first last">Container for data dumped during the optimisation.
Can be set by specifying the dumping level or set directly.
Note this is mainly intended for user and a development debugging
but could be used for status information during a long optimisation.</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.optimizer.Optimizer.dumping" title="qutip.control.optimizer.Optimizer.dumping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY.</p>
</dd>
<dt><strong>dump_to_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If set True then data will be dumped to file during the optimisation
dumping will be set to SUMMARY during init_optim
if dump_to_file is True and dumping not set.
Default is False</p>
</dd>
<dt><strong>dump_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Basically a link to dump.dump_dir. Exists so that it can be set through
optim_params.
If dump is None then will return None or will set dumping to SUMMARY
when setting a path</p>
</dd>
<dt><strong>iter_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="#qutip.control.optimizer.OptimIterSummary" title="qutip.control.optimizer.OptimIterSummary"><code class="xref py py-class docutils literal notranslate"><span class="pre">OptimIterSummary</span></code></a></span></dt>
<dd><p class="first last">Summary of the most recent iteration.
Note this is only set if dummping is on</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.apply_method_params" title="qutip.control.optimizer.Optimizer.apply_method_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_method_params</span></code></a>([params])</td>
<td>Loops through all the method_params (either passed here or the method_params attribute) If the name matches an attribute of this object or the termination conditions object, then the value of this attribute is set.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.apply_params" title="qutip.control.optimizer.Optimizer.apply_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code></a>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.fid_err_func_wrapper" title="qutip.control.optimizer.Optimizer.fid_err_func_wrapper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_func_wrapper</span></code></a>(*args)</td>
<td>Get the fidelity error achieved using the ctrl amplitudes passed in as the first argument.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.fid_err_grad_wrapper" title="qutip.control.optimizer.Optimizer.fid_err_grad_wrapper"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_grad_wrapper</span></code></a>(*args)</td>
<td>Get the gradient of the fidelity error with respect to all of the variables, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.init_optim" title="qutip.control.optimizer.Optimizer.init_optim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_optim</span></code></a>(term_conds)</td>
<td>Check optimiser attribute status and passed parameters before running the optimisation.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.iter_step_callback_func" title="qutip.control.optimizer.Optimizer.iter_step_callback_func"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_step_callback_func</span></code></a>(*args)</td>
<td>Check the elapsed wall time for the optimisation run so far.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.Optimizer.run_optimization" title="qutip.control.optimizer.Optimizer.run_optimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_optimization</span></code></a>([term_conds])</td>
<td>This default function optimisation method is a wrapper to the scipy.optimize.minimize function.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.apply_method_params">
<code class="descname">apply_method_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.apply_method_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.apply_method_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Loops through all the method_params
(either passed here or the method_params attribute)
If the name matches an attribute of this object or the
termination conditions object, then the value of this attribute
is set. Otherwise it is assumed to a method_option for the
scipy.optimize.minimize function</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.apply_params">
<code class="descname">apply_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.apply_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.optimizer.Optimizer.dumping">
<code class="descname">dumping</code><a class="headerlink" href="#qutip.control.optimizer.Optimizer.dumping" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>The level of data dumping that will occur during the optimisation</dt>
<dd><ul class="first last simple">
<li>NONE : No processing data dumped (Default)</li>
<li>SUMMARY : A summary at each iteration will be recorded</li>
<li>FULL : All logs will be generated and dumped</li>
<li>CUSTOM : Some customised level of dumping</li>
</ul>
</dd>
</dl>
<p>When first set to CUSTOM this is equivalent to SUMMARY. It is then up
to the user to specify which logs are dumped</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.fid_err_func_wrapper">
<code class="descname">fid_err_func_wrapper</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.fid_err_func_wrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.fid_err_func_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the fidelity error achieved using the ctrl amplitudes passed
in as the first argument.</p>
<p>This is called by generic optimisation algorithm as the
func to the minimised. The argument is the current
variable values, i.e. control amplitudes, passed as
a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]
and then used to update the stored ctrl values (if they have changed)</p>
<p>The error is checked against the target, and the optimisation is
terminated if the target has been achieved.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.fid_err_grad_wrapper">
<code class="descname">fid_err_grad_wrapper</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.fid_err_grad_wrapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.fid_err_grad_wrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the gradient of the fidelity error with respect to all of the
variables, i.e. the ctrl amplidutes in each timeslot</p>
<p>This is called by generic optimisation algorithm as the gradients of
func to the minimised wrt the variables. The argument is the current
variable values, i.e. control amplitudes, passed as
a flat array. Hence these are reshaped as [nTimeslots, n_ctrls]
and then used to update the stored ctrl values (if they have changed)</p>
<p>Although the optimisation algorithms have a check within them for
function convergence, i.e. local minima, the sum of the squares
of the normalised gradient is checked explicitly, and the
optimisation is terminated if this is below the min_gradient_norm
condition</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.init_optim">
<code class="descname">init_optim</code><span class="sig-paren">(</span><em>term_conds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.init_optim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.init_optim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check optimiser attribute status and passed parameters before
running the optimisation.
This is called by run_optimization, but could called independently
to check the configuration.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.iter_step_callback_func">
<code class="descname">iter_step_callback_func</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.iter_step_callback_func"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.iter_step_callback_func" title="Permalink to this definition">¶</a></dt>
<dd><p>Check the elapsed wall time for the optimisation run so far.
Terminate if this has exceeded the maximum allowed time</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.Optimizer.run_optimization">
<code class="descname">run_optimization</code><span class="sig-paren">(</span><em>term_conds=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#Optimizer.run_optimization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.Optimizer.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>This default function optimisation method is a wrapper to the
scipy.optimize.minimize function.</p>
<p>It will attempt to minimise the fidelity error with respect to some
parameters, which are determined by _get_optim_var_vals (see below)</p>
<p>The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, wall time, or
function call or iteration count exceeded. Note these
conditions include gradient minimum met (local minima) for
methods that use a gradient.</p>
<p>The function minimisation method is taken from the optim_method
attribute. Note that not all of these methods have been tested.
Note that some of these use a gradient and some do not.
See the scipy documentation for details. Options specific to the
method can be passed setting the method_params attribute.</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.optimizer.OptimizerBFGS">
<em class="property">class </em><code class="descclassname">qutip.control.optimizer.</code><code class="descname">OptimizerBFGS</code><span class="sig-paren">(</span><em>config</em>, <em>dyn</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerBFGS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerBFGS" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the run_optimization method using the BFGS algorithm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dump_dir</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></dt>
<dd><p class="first last">The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY.</p>
</dd>
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_method_params</span></code>([params])</td>
<td>Loops through all the method_params (either passed here or the method_params attribute) If the name matches an attribute of this object or the termination conditions object, then the value of this attribute is set.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_func_wrapper</span></code>(*args)</td>
<td>Get the fidelity error achieved using the ctrl amplitudes passed in as the first argument.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_grad_wrapper</span></code>(*args)</td>
<td>Get the gradient of the fidelity error with respect to all of the variables, i.e.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_optim</span></code>(term_conds)</td>
<td>Check optimiser attribute status and passed parameters before running the optimisation.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_step_callback_func</span></code>(*args)</td>
<td>Check the elapsed wall time for the optimisation run so far.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.OptimizerBFGS.run_optimization" title="qutip.control.optimizer.OptimizerBFGS.run_optimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_optimization</span></code></a>([term_conds])</td>
<td>Optimise the control pulse amplitudes to minimise the fidelity error using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm The optimisation end when one of the passed termination conditions has been met, e.g.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.optimizer.OptimizerBFGS.run_optimization">
<code class="descname">run_optimization</code><span class="sig-paren">(</span><em>term_conds=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerBFGS.run_optimization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerBFGS.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise the control pulse amplitudes to minimise the fidelity error
using the BFGS (Broyden–Fletcher–Goldfarb–Shanno) algorithm
The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, gradient minimum met
(local minima), wall time / iteration count exceeded.</p>
<p>Essentially this is wrapper to the:
scipy.optimize.fmin_bfgs
function</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.optimizer.OptimizerLBFGSB">
<em class="property">class </em><code class="descclassname">qutip.control.optimizer.</code><code class="descname">OptimizerLBFGSB</code><span class="sig-paren">(</span><em>config</em>, <em>dyn</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerLBFGSB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerLBFGSB" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the run_optimization method using the L-BFGS-B algorithm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>max_metric_corr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of variable metric corrections used to define
the limited memory matrix. That is the number of previous
gradient values that are used to approximate the Hessian
see the scipy.optimize.fmin_l_bfgs_b documentation for description
of m argument</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_method_params</span></code>([params])</td>
<td>Loops through all the method_params (either passed here or the method_params attribute) If the name matches an attribute of this object or the termination conditions object, then the value of this attribute is set.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_func_wrapper</span></code>(*args)</td>
<td>Get the fidelity error achieved using the ctrl amplitudes passed in as the first argument.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_grad_wrapper</span></code>(*args)</td>
<td>Get the gradient of the fidelity error with respect to all of the variables, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.OptimizerLBFGSB.init_optim" title="qutip.control.optimizer.OptimizerLBFGSB.init_optim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_optim</span></code></a>(term_conds)</td>
<td>Check optimiser attribute status and passed parameters before running the optimisation.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_step_callback_func</span></code>(*args)</td>
<td>Check the elapsed wall time for the optimisation run so far.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.OptimizerLBFGSB.run_optimization" title="qutip.control.optimizer.OptimizerLBFGSB.run_optimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_optimization</span></code></a>([term_conds])</td>
<td>Optimise the control pulse amplitudes to minimise the fidelity error using the L-BFGS-B algorithm, which is the constrained (bounded amplitude values), limited memory, version of the Broyden–Fletcher–Goldfarb–Shanno algorithm.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.optimizer.OptimizerLBFGSB.init_optim">
<code class="descname">init_optim</code><span class="sig-paren">(</span><em>term_conds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerLBFGSB.init_optim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerLBFGSB.init_optim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check optimiser attribute status and passed parameters before
running the optimisation.
This is called by run_optimization, but could called independently
to check the configuration.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.optimizer.OptimizerLBFGSB.run_optimization">
<code class="descname">run_optimization</code><span class="sig-paren">(</span><em>term_conds=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerLBFGSB.run_optimization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerLBFGSB.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise the control pulse amplitudes to minimise the fidelity error
using the L-BFGS-B algorithm, which is the constrained
(bounded amplitude values), limited memory, version of the
Broyden–Fletcher–Goldfarb–Shanno algorithm.</p>
<p>The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, gradient minimum met
(local minima), wall time / iteration count exceeded.</p>
<p>Essentially this is wrapper to the:
scipy.optimize.fmin_l_bfgs_b function
This in turn is a warpper for well established implementation of
the L-BFGS-B algorithm written in Fortran, which is therefore
very fast. See SciPy documentation for credit and details on
this function.</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.optimizer.OptimizerCrab">
<em class="property">class </em><code class="descclassname">qutip.control.optimizer.</code><code class="descname">OptimizerCrab</code><span class="sig-paren">(</span><em>config</em>, <em>dyn</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerCrab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrab" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimises the pulse using the CRAB algorithm [1].
It uses the scipy.optimize.minimize function with the method specified
by the optim_method attribute. See Optimizer.run_optimization for details
It minimises the fidelity error function with respect to the CRAB
basis function coefficients.</p>
<p>AJGP ToDo: Add citation here</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dump_dir</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></dt>
<dd><p class="first last">The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY.</p>
</dd>
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_method_params</span></code>([params])</td>
<td>Loops through all the method_params (either passed here or the method_params attribute) If the name matches an attribute of this object or the termination conditions object, then the value of this attribute is set.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_func_wrapper</span></code>(*args)</td>
<td>Get the fidelity error achieved using the ctrl amplitudes passed in as the first argument.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_grad_wrapper</span></code>(*args)</td>
<td>Get the gradient of the fidelity error with respect to all of the variables, i.e.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.OptimizerCrab.init_optim" title="qutip.control.optimizer.OptimizerCrab.init_optim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_optim</span></code></a>(term_conds)</td>
<td>Check optimiser attribute status and passed parameters before running the optimisation.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_step_callback_func</span></code>(*args)</td>
<td>Check the elapsed wall time for the optimisation run so far.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_optimization</span></code>([term_conds])</td>
<td>This default function optimisation method is a wrapper to the scipy.optimize.minimize function.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.optimizer.OptimizerCrab.init_optim">
<code class="descname">init_optim</code><span class="sig-paren">(</span><em>term_conds</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerCrab.init_optim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrab.init_optim" title="Permalink to this definition">¶</a></dt>
<dd><p>Check optimiser attribute status and passed parameters before
running the optimisation.
This is called by run_optimization, but could called independently
to check the configuration.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.optimizer.OptimizerCrabFmin">
<em class="property">class </em><code class="descclassname">qutip.control.optimizer.</code><code class="descname">OptimizerCrabFmin</code><span class="sig-paren">(</span><em>config</em>, <em>dyn</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerCrabFmin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrabFmin" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimises the pulse using the CRAB algorithm [1, 2].
It uses the scipy.optimize.fmin function which is effectively a wrapper
for the Nelder-mead method.
It minimises the fidelity error function with respect to the CRAB
basis function coefficients.
This is the default Optimizer for CRAB.</p>
<p class="rubric">Notes</p>
<dl class="docutils">
<dt>[1] P. Doria, T. Calarco &amp; S. Montangero. Phys. Rev. Lett. 106,</dt>
<dd>190501 (2011).</dd>
</dl>
<p>[2] T. Caneva, T. Calarco, &amp; S. Montangero. Phys. Rev. A 84, 022326 (2011).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dump_dir</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></dt>
<dd><p class="first last">The level of data dumping that will occur during the optimisation - NONE : No processing data dumped (Default) - SUMMARY : A summary at each iteration will be recorded - FULL : All logs will be generated and dumped - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY.</p>
</dd>
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_method_params</span></code>([params])</td>
<td>Loops through all the method_params (either passed here or the method_params attribute) If the name matches an attribute of this object or the termination conditions object, then the value of this attribute is set.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_func_wrapper</span></code>(*args)</td>
<td>Get the fidelity error achieved using the ctrl amplitudes passed in as the first argument.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">fid_err_grad_wrapper</span></code>(*args)</td>
<td>Get the gradient of the fidelity error with respect to all of the variables, i.e.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_optim</span></code>(term_conds)</td>
<td>Check optimiser attribute status and passed parameters before running the optimisation.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_step_callback_func</span></code>(*args)</td>
<td>Check the elapsed wall time for the optimisation run so far.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.optimizer.OptimizerCrabFmin.run_optimization" title="qutip.control.optimizer.OptimizerCrabFmin.run_optimization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">run_optimization</span></code></a>([term_conds])</td>
<td>This function optimisation method is a wrapper to the scipy.optimize.fmin function.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.optimizer.OptimizerCrabFmin.run_optimization">
<code class="descname">run_optimization</code><span class="sig-paren">(</span><em>term_conds=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimizerCrabFmin.run_optimization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimizerCrabFmin.run_optimization" title="Permalink to this definition">¶</a></dt>
<dd><p>This function optimisation method is a wrapper to the
scipy.optimize.fmin function.</p>
<p>It will attempt to minimise the fidelity error with respect to some
parameters, which are determined by _get_optim_var_vals which
in the case of CRAB are the basis function coefficients</p>
<p>The optimisation end when one of the passed termination conditions
has been met, e.g. target achieved, wall time, or
function call or iteration count exceeded. Specifically to the fmin
method, the optimisation will stop when change parameter values
is less than xtol or the change in function value is below ftol.</p>
<p>If the parameter term_conds=None, then the termination_conditions
attribute must already be set. It will be overwritten if the
parameter is not None</p>
<p>The result is returned in an OptimResult object, which includes
the final fidelity, time evolution, reason for termination etc</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.optimizer.OptimIterSummary">
<em class="property">class </em><code class="descclassname">qutip.control.optimizer.</code><code class="descname">OptimIterSummary</code><a class="reference internal" href="../_modules/qutip/control/optimizer.html#OptimIterSummary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimizer.OptimIterSummary" title="Permalink to this definition">¶</a></dt>
<dd><p>A summary of the most recent iteration of the pulse optimisation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>iter_num</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Iteration number of the pulse optimisation</p>
</dd>
<dt><strong>fid_func_call_num</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Fidelity function call number of the pulse optimisation</p>
</dd>
<dt><strong>grad_func_call_num</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Gradient function call number of the pulse optimisation</p>
</dd>
<dt><strong>fid_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity error</p>
</dd>
<dt><strong>grad_norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">fidelity gradient (wrt the control parameters) vector norm
that is the magnitude of the gradient</p>
</dd>
<dt><strong>wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Time spent computing the pulse optimisation so far
(in seconds of elapsed time)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="34%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_header_line</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_value_line</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.control.termcond.TerminationConditions">
<em class="property">class </em><code class="descclassname">qutip.control.termcond.</code><code class="descname">TerminationConditions</code><a class="reference internal" href="../_modules/qutip/control/termcond.html#TerminationConditions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.termcond.TerminationConditions" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all termination conditions
Used to determine when to stop the optimisation algorithm
Note different subclasses should be used to match the type of
optimisation being used</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fid_err_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Target fidelity error</p>
</dd>
<dt><strong>fid_goal</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">goal fidelity, e.g. 1 - self.fid_err_targ
It its typical to set this for unitary systems</p>
</dd>
<dt><strong>max_wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last"># maximum time for optimisation (seconds)</p>
</dd>
<dt><strong>min_gradient_norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum normalised gradient after which optimisation will terminate</p>
</dd>
<dt><strong>max_iterations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_fid_func_calls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum number of calls to the fidelity function during
the optimisation algorithm</p>
</dd>
<dt><strong>accuracy_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Determines the accuracy of the result.
Typical values for accuracy_factor are: 1e12 for low accuracy;
1e7 for moderate accuracy; 10.0 for extremely high accuracy
scipy.optimize.fmin_l_bfgs_b factr argument.
Only set for specific methods (fmin_l_bfgs_b) that uses this
Otherwise the same thing is passed as method_option ftol
(although the scale is different)
Hence it is not defined here, but may be set by the user</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.control.optimresult.OptimResult">
<em class="property">class </em><code class="descclassname">qutip.control.optimresult.</code><code class="descname">OptimResult</code><a class="reference internal" href="../_modules/qutip/control/optimresult.html#OptimResult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.optimresult.OptimResult" title="Permalink to this definition">¶</a></dt>
<dd><p>Attributes give the result of the pulse optimisation attempt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>termination_reason</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Description of the reason for terminating the optimisation</p>
</dd>
<dt><strong>fidelity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">final (normalised) fidelity that was achieved</p>
</dd>
<dt><strong>initial_fid_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">fidelity error before optimisation starting</p>
</dd>
<dt><strong>fid_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">final fidelity error that was achieved</p>
</dd>
<dt><strong>goal_achieved</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">True is the fidely error achieved was below the target</p>
</dd>
<dt><strong>grad_norm_final</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Final value of the sum of the squares of the (normalised) fidelity
error gradients</p>
</dd>
<dt><strong>grad_norm_min_reached</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">True if the optimisation terminated due to the minimum value
of the gradient being reached</p>
</dd>
<dt><strong>num_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of iterations of the optimisation algorithm completed</p>
</dd>
<dt><strong>max_iter_exceeded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">True if the iteration limit was reached</p>
</dd>
<dt><strong>max_fid_func_exceeded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">True if the fidelity function call limit was reached</p>
</dd>
<dt><strong>wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">time elapsed during the optimisation</p>
</dd>
<dt><strong>wall_time_limit_exceeded</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">True if the wall time limit was reached</p>
</dd>
<dt><strong>time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots+1] of float</span></dt>
<dd><p class="first last">Time are the start of each timeslot
with the final value being the total evolution time</p>
</dd>
<dt><strong>initial_amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots, n_ctrls]</span></dt>
<dd><p class="first last">The amplitudes at the start of the optimisation</p>
</dd>
<dt><strong>final_amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots, n_ctrls]</span></dt>
<dd><p class="first last">The amplitudes at the end of the optimisation</p>
</dd>
<dt><strong>evo_full_final</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">The evolution operator from t=0 to t=T based on the final amps</p>
</dd>
<dt><strong>evo_full_initial</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">The evolution operator from t=0 to t=T based on the initial amps</p>
</dd>
<dt><strong>stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Stats</span></dt>
<dd><p class="first last">Object contaning the stats for the run (if any collected)</p>
</dd>
<dt><strong>optimizer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Optimizer</span></dt>
<dd><p class="first last">Instance of the Optimizer used to generate the result</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.control.dynamics.Dynamics">
<em class="property">class </em><code class="descclassname">qutip.control.dynamics.</code><code class="descname">Dynamics</code><span class="sig-paren">(</span><em>optimconfig</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a base class only. See subclass descriptions and choose an
appropriate one for the application.</p>
<p>Note that initialize_controls must be called before most of the methods
can be used. init_timeslots can be called sometimes earlier in order
to access timeslot related attributes</p>
<p>This acts as a container for the operators that are used to calculate
time evolution of the system under study. That is the dynamics generators
(Hamiltonians, Lindbladians etc), the propagators from one timeslot to
the next, and the evolution operators. Due to the large number of matrix
additions and multiplications, for small systems at least, the optimisation
performance is much better using ndarrays to represent these operators.
However</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>params:  Dictionary</strong></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd>
<dt><strong>stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Stats</span></dt>
<dd><p class="first last">Attributes of which give performance stats for the optimisation
set to None to reduce overhead of calculating stats.
Note it is (usually) shared with the Optimizer object</p>
</dd>
<dt><strong>tslot_computer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">TimeslotComputer (subclass instance)</span></dt>
<dd><p class="first last">Used to manage when the timeslot dynamics
generators, propagators, gradients etc are updated</p>
</dd>
<dt><strong>prop_computer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">PropagatorComputer (subclass instance)</span></dt>
<dd><p class="first last">Used to compute the propagators and their gradients</p>
</dd>
<dt><strong>fid_computer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">FidelityComputer (subclass instance)</span></dt>
<dd><p class="first last">Used to computer the fidelity error and the fidelity error
gradient.</p>
</dd>
<dt><strong>memory_optimization</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Level of memory optimisation. Setting to 0 (default) means that
execution speed is prioritized over memory.
Setting to 1 means that some memory prioritisation steps will be
taken, for instance using Qobj (and hence sparse arrays) as the
the internal operator data type, and not caching some operators
Potentially further memory saving maybe made with
memory_optimization &gt; 1.
The options are processed in _set_memory_optimizations, see
this for more information. Individual memory saving  options can be
switched by settting them directly (see below)</p>
</dd>
<dt><strong>oper_dtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">type</span></dt>
<dd><p class="first last">Data type for internal dynamics generators, propagators and time
evolution operators. This can be ndarray or Qobj, or (in theory) any
other representaion that supports typical matrix methods (e.g. dot)
ndarray performs best for smaller quantum systems.
Qobj may perform better for larger systems, and will also
perform better when (custom) fidelity measures use Qobj methods
such as partial trace.
See _choose_oper_dtype for how this is chosen when not specified</p>
</dd>
<dt><strong>cache_phased_dyn_gen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True then the dynamics generators will be saved with and
without the propagation prefactor (if there is one)
Defaults to True when memory_optimization=0, otherwise False</p>
</dd>
<dt><strong>cache_prop_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If the True then the propagator gradients (for exact gradients) will
be computed when the propagator are computed and cache until
the are used by the fidelity computer. If False then the
fidelity computer will calculate them as needed.
Defaults to True when memory_optimization=0, otherwise False</p>
</dd>
<dt><strong>cache_dyn_gen_eigenvectors_adj: bool</strong></dt>
<dd><p class="first last">If True then DynamicsUnitary will cached the adjoint of
the Hamiltion eignvector matrix
Defaults to True when memory_optimization=0, otherwise False</p>
</dd>
<dt><strong>sparse_eigen_decomp: bool</strong></dt>
<dd><p class="first last">If True then DynamicsUnitary will use the sparse eigenvalue
decomposition.
Defaults to True when memory_optimization&lt;=1, otherwise False</p>
</dd>
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of timeslots (aka timeslices)</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.num_ctrls" title="qutip.control.dynamics.Dynamics.num_ctrls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_ctrls</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">calculate the of controls from the length of the control list</p>
</dd>
<dt><strong>evo_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total time for the evolution</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of float</span></dt>
<dd><p class="first last">Duration of each timeslot
Note that if this is set before initialize_controls is called
then num_tslots and evo_time are calculated from tau, otherwise
tau is generated from num_tslots and evo_time, that is
equal size time slices</p>
</dd>
<dt><strong>time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots+1] of float</span></dt>
<dd><p class="first last">Cumulative time for the evolution, that is the time at the start
of each time slice</p>
</dd>
<dt><strong>drift_dyn_gen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or list of Qobj</span></dt>
<dd><p class="first last">Drift or system dynamics generator (Hamiltonian)
Matrix defining the underlying dynamics of the system
Can also be a list of Qobj (length num_tslots) for time varying
drift dynamics</p>
</dd>
<dt><strong>ctrl_dyn_gen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">Control dynamics generator (Hamiltonians)
List of matrices defining the control dynamics</p>
</dd>
<dt><strong>initial</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Starting state / gate
The matrix giving the initial state / gate, i.e. at time 0
Typically the identity for gate evolution</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Target state / gate:
The matrix giving the desired state / gate for the evolution</p>
</dd>
<dt><strong>ctrl_amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots, num_ctrls] of float</span></dt>
<dd><p class="first last">Control amplitudes
The amplitude (scale factor) for each control in each timeslot</p>
</dd>
<dt><strong>initial_ctrl_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scale factor applied to be applied the control amplitudes
when they are initialised
This is used by the PulseGens rather than in any fucntions in
this class</p>
</dd>
<dt><strong>initial_ctrl_offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear offset applied to be applied the control amplitudes
when they are initialised
This is used by the PulseGens rather than in any fucntions in
this class</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.dyn_gen" title="qutip.control.dynamics.Dynamics.dyn_gen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dyn_gen</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">List of combined dynamics generators (Qobj) for each timeslot</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.prop" title="qutip.control.dynamics.Dynamics.prop"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prop</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">list of Qobj</span></dt>
<dd><p class="first last">List of propagators (Qobj) for each timeslot</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.prop_grad" title="qutip.control.dynamics.Dynamics.prop_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prop_grad</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots, num_ctrls] of Qobj</span></dt>
<dd><p class="first last">Array of propagator gradients (Qobj) for each timeslot, control</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.fwd_evo" title="qutip.control.dynamics.Dynamics.fwd_evo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwd_evo</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.onwd_evo" title="qutip.control.dynamics.Dynamics.onwd_evo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">onwd_evo</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.onto_evo" title="qutip.control.dynamics.Dynamics.onto_evo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">onto_evo</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><strong>evo_current</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">Used to flag that the dynamics used to calculate the evolution
operators is current. It is set to False when the amplitudes
change</p>
</dd>
<dt><strong>fact_mat_round_prec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Rounding precision used when calculating the factor matrix
to determine if two eigenvalues are equivalent
Only used when the PropagatorComputer uses diagonalisation</p>
</dd>
<dt><strong>def_amps_fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Default name for the output used when save_amps is called</p>
</dd>
<dt><strong>unitarity_check_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">If &gt; 0 then unitarity of the system evolution is checked at at
evolution recomputation.
level 1 checks all propagators
level 2 checks eigen basis as well
Default is 0</p>
</dd>
<dt><strong>unitarity_tol :</strong></dt>
<dd><p class="first last">Tolerance used in checking if operator is unitary
Default is 1e-10</p>
</dd>
<dt><strong>dump</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">dump.DynamicsDump</span></code></span></dt>
<dd><p class="first last">Store of historical calculation data.
Set to None (Default) for no storing of historical data
Use dumping property to set level of data dumping</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dynamics.Dynamics.dumping" title="qutip.control.dynamics.Dynamics.dumping"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The level of data dumping that will occur during the time evolution calculation.</p>
</dd>
<dt><strong>dump_to_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If set True then data will be dumped to file during the calculations
dumping will be set to SUMMARY during init_evo if dump_to_file is True
and dumping not set.
Default is False</p>
</dd>
<dt><strong>dump_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Basically a link to dump.dump_dir. Exists so that it can be set through
dyn_params.
If dump is None then will return None or will set dumping to SUMMARY
when setting a path</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.apply_params" title="qutip.control.dynamics.Dynamics.apply_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code></a>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.combine_dyn_gen" title="qutip.control.dynamics.Dynamics.combine_dyn_gen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_dyn_gen</span></code></a>(k)</td>
<td>Computes the dynamics generator for a given timeslot The is the combined Hamiltion for unitary systems</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.compute_evolution" title="qutip.control.dynamics.Dynamics.compute_evolution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_evolution</span></code></a>()</td>
<td>Recalculate the time evolution operators Dynamics generators (e.g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.flag_system_changed" title="qutip.control.dynamics.Dynamics.flag_system_changed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code></a>()</td>
<td>Flag evolution, fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.get_ctrl_dyn_gen" title="qutip.control.dynamics.Dynamics.get_ctrl_dyn_gen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ctrl_dyn_gen</span></code></a>(j)</td>
<td>Get the dynamics generator for the control Not implemented in the base class.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.get_drift_dim" title="qutip.control.dynamics.Dynamics.get_drift_dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_drift_dim</span></code></a>()</td>
<td>Returns the size of the matrix that defines the drift dynamics that is assuming the drift is NxN, then this returns N</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.get_dyn_gen" title="qutip.control.dynamics.Dynamics.get_dyn_gen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dyn_gen</span></code></a>(k)</td>
<td>Get the combined dynamics generator for the timeslot Not implemented in the base class.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.get_num_ctrls" title="qutip.control.dynamics.Dynamics.get_num_ctrls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_num_ctrls</span></code></a>()</td>
<td>calculate the of controls from the length of the control list sets the num_ctrls property, which can be used alternatively subsequently</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.init_timeslots" title="qutip.control.dynamics.Dynamics.init_timeslots"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_timeslots</span></code></a>()</td>
<td>Generate the timeslot duration array 'tau' based on the evo_time and num_tslots attributes, unless the tau attribute is already set in which case this step in ignored Generate the cumulative time array 'time' based on the tau values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.initialize_controls" title="qutip.control.dynamics.Dynamics.initialize_controls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_controls</span></code></a>(amps[,&nbsp;init_tslots])</td>
<td>Set the initial control amplitudes and time slices Note this must be called after the configuration is complete before any dynamics can be calculated</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.refresh_drift_attribs" title="qutip.control.dynamics.Dynamics.refresh_drift_attribs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">refresh_drift_attribs</span></code></a>()</td>
<td>Reset the dyn_shape, dyn_dims and time_depend_drift attribs</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.save_amps" title="qutip.control.dynamics.Dynamics.save_amps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_amps</span></code></a>([file_name,&nbsp;times,&nbsp;amps,&nbsp;verbose])</td>
<td>Save a file with the current control amplitudes in each timeslot The first column in the file will be the start time of the slot</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.unitarity_check" title="qutip.control.dynamics.Dynamics.unitarity_check"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitarity_check</span></code></a>()</td>
<td>Checks whether all propagators are unitary</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.Dynamics.update_ctrl_amps" title="qutip.control.dynamics.Dynamics.update_ctrl_amps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_ctrl_amps</span></code></a>(new_amps)</td>
<td>Determine if any amplitudes have changed.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="73%" />
<col width="27%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>check_ctrls_initialized</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_amp_times</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_owd_evo_target</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.apply_params">
<code class="descname">apply_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.apply_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.combine_dyn_gen">
<code class="descname">combine_dyn_gen</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.combine_dyn_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.combine_dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the dynamics generator for a given timeslot
The is the combined Hamiltion for unitary systems</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.compute_evolution">
<code class="descname">compute_evolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.compute_evolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.compute_evolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculate the time evolution operators
Dynamics generators (e.g. Hamiltonian) and
prop (propagators) are calculated as necessary
Actual work is completed by the recompute_evolution method
of the timeslot computer</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.dumping">
<code class="descname">dumping</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.dumping" title="Permalink to this definition">¶</a></dt>
<dd><p>The level of data dumping that will occur during the time evolution
calculation.</p>
<blockquote>
<div><ul class="simple">
<li>NONE : No processing data dumped (Default)</li>
<li>SUMMARY : A summary of each time evolution will be recorded</li>
<li>FULL : All operators used or created in the calculation dumped</li>
<li>CUSTOM : Some customised level of dumping</li>
</ul>
</div></blockquote>
<p>When first set to CUSTOM this is equivalent to SUMMARY. It is then up
to the user to specify which operators are dumped
WARNING: FULL could consume a lot of memory!</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.dyn_gen">
<code class="descname">dyn_gen</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>List of combined dynamics generators (Qobj) for each timeslot</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.dyn_gen_phase">
<code class="descname">dyn_gen_phase</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.dyn_gen_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Some op that is applied to the dyn_gen before expontiating to
get the propagator.
See <cite>phase_application</cite> for how this is applied</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.flag_system_changed">
<code class="descname">flag_system_changed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.flag_system_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.flag_system_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag evolution, fidelity and gradients as needing recalculation</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.full_evo">
<code class="descname">full_evo</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.full_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>Full evolution - time evolution at final time slot</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.fwd_evo">
<code class="descname">fwd_evo</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.fwd_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>List of evolution operators (Qobj) from the initial to the given
timeslot</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.get_ctrl_dyn_gen">
<code class="descname">get_ctrl_dyn_gen</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.get_ctrl_dyn_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_ctrl_dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the dynamics generator for the control
Not implemented in the base class. Choose a subclass</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.get_drift_dim">
<code class="descname">get_drift_dim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.get_drift_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_drift_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the size of the matrix that defines the drift dynamics
that is assuming the drift is NxN, then this returns N</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.get_dyn_gen">
<code class="descname">get_dyn_gen</code><span class="sig-paren">(</span><em>k</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.get_dyn_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_dyn_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the combined dynamics generator for the timeslot
Not implemented in the base class. Choose a subclass</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.get_num_ctrls">
<code class="descname">get_num_ctrls</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.get_num_ctrls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.get_num_ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the of controls from the length of the control list
sets the num_ctrls property, which can be used alternatively
subsequently</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.init_timeslots">
<code class="descname">init_timeslots</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.init_timeslots"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.init_timeslots" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the timeslot duration array 'tau' based on the evo_time
and num_tslots attributes, unless the tau attribute is already set
in which case this step in ignored
Generate the cumulative time array 'time' based on the tau values</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.initialize_controls">
<code class="descname">initialize_controls</code><span class="sig-paren">(</span><em>amps</em>, <em>init_tslots=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.initialize_controls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.initialize_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial control amplitudes and time slices
Note this must be called after the configuration is complete
before any dynamics can be calculated</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.num_ctrls">
<code class="descname">num_ctrls</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.num_ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the of controls from the length of the control list
sets the num_ctrls property, which can be used alternatively
subsequently</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.onto_evo">
<code class="descname">onto_evo</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.onto_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>List of evolution operators (Qobj) from the initial to the given
timeslot</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.onwd_evo">
<code class="descname">onwd_evo</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.onwd_evo" title="Permalink to this definition">¶</a></dt>
<dd><p>List of evolution operators (Qobj) from the initial to the given
timeslot</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.phase_application">
<code class="descname">phase_application</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.phase_application" title="Permalink to this definition">¶</a></dt>
<dd><p>phase_application : scalar(string), default='preop'
Determines how the phase is applied to the dynamics generators</p>
<blockquote>
<div><ul class="simple">
<li>'preop'  : P = expm(phase*dyn_gen)</li>
<li>'postop' : P = expm(dyn_gen*phase)</li>
<li>'custom' : Customised phase application</li>
</ul>
</div></blockquote>
<p>The 'custom' option assumes that the _apply_phase method has been
set to a custom function</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.prop">
<code class="descname">prop</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.prop" title="Permalink to this definition">¶</a></dt>
<dd><p>List of propagators (Qobj) for each timeslot</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.Dynamics.prop_grad">
<code class="descname">prop_grad</code><a class="headerlink" href="#qutip.control.dynamics.Dynamics.prop_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Array of propagator gradients (Qobj) for each timeslot, control</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.refresh_drift_attribs">
<code class="descname">refresh_drift_attribs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.refresh_drift_attribs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.refresh_drift_attribs" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the dyn_shape, dyn_dims and time_depend_drift attribs</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.save_amps">
<code class="descname">save_amps</code><span class="sig-paren">(</span><em>file_name=None</em>, <em>times=None</em>, <em>amps=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.save_amps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.save_amps" title="Permalink to this definition">¶</a></dt>
<dd><p>Save a file with the current control amplitudes in each timeslot
The first column in the file will be the start time of the slot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>file_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Name of the file
If None given the def_amps_fname attribuite will be used</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List type (or string)</span></dt>
<dd><p class="first last">List / array of the start times for each slot
If None given this will be retrieved through get_amp_times()
If 'exclude' then times will not be saved in the file, just
the amplitudes</p>
</dd>
<dt><strong>amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Array[num_tslots, num_ctrls]</span></dt>
<dd><p class="first last">Amplitudes to be saved
If None given the ctrl_amps attribute will be used</p>
</dd>
<dt><strong>verbose</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">If True then an info message will be logged</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.unitarity_check">
<code class="descname">unitarity_check</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.unitarity_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.unitarity_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether all propagators are unitary</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.Dynamics.update_ctrl_amps">
<code class="descname">update_ctrl_amps</code><span class="sig-paren">(</span><em>new_amps</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#Dynamics.update_ctrl_amps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.Dynamics.update_ctrl_amps" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if any amplitudes have changed. If so, then mark the
timeslots as needing recalculation
The actual work is completed by the compare_amps method of the
timeslot computer</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dynamics.DynamicsGenMat">
<em class="property">class </em><code class="descclassname">qutip.control.dynamics.</code><code class="descname">DynamicsGenMat</code><span class="sig-paren">(</span><em>optimconfig</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#DynamicsGenMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsGenMat" title="Permalink to this definition">¶</a></dt>
<dd><p>This sub class can be used for any system where no additional
operator is applied to the dynamics generator before calculating
the propagator, e.g. classical dynamics, Lindbladian</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dump_dir</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dumping</span></code></dt>
<dd><p class="first last">The level of data dumping that will occur during the time evolution calculation.</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dyn_gen</span></code></dt>
<dd><p class="first last">List of combined dynamics generators (Qobj) for each timeslot</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">dyn_gen_phase</span></code></dt>
<dd><p class="first last">Some op that is applied to the dyn_gen before expontiating to get the propagator.</p>
</dd>
<dt><strong>evo_init2t</strong></dt>
<dd></dd>
<dt><strong>evo_t2end</strong></dt>
<dd></dd>
<dt><strong>evo_t2targ</strong></dt>
<dd></dd>
<dt><strong>evo_time</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">full_evo</span></code></dt>
<dd><p class="first last">Full evolution - time evolution at final time slot</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">fwd_evo</span></code></dt>
<dd><p class="first last">List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><strong>log_level</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">num_ctrls</span></code></dt>
<dd><p class="first last">calculate the of controls from the length of the control list</p>
</dd>
<dt><strong>num_tslots</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">onto_evo</span></code></dt>
<dd><p class="first last">List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><strong>onto_evo_target</strong></dt>
<dd></dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">onwd_evo</span></code></dt>
<dd><p class="first last">List of evolution operators (Qobj) from the initial to the given</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase_application</span></code></dt>
<dd><p class="first last">phase_application : scalar(string), default='preop'</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">prop</span></code></dt>
<dd><p class="first last">List of propagators (Qobj) for each timeslot</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">prop_grad</span></code></dt>
<dd><p class="first last">Array of propagator gradients (Qobj) for each timeslot, control</p>
</dd>
<dt><strong>tau</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_dyn_gen</span></code>(k)</td>
<td>Computes the dynamics generator for a given timeslot The is the combined Hamiltion for unitary systems</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_evolution</span></code>()</td>
<td>Recalculate the time evolution operators Dynamics generators (e.g.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code>()</td>
<td>Flag evolution, fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ctrl_dyn_gen</span></code>(j)</td>
<td>Get the dynamics generator for the control Not implemented in the base class.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_drift_dim</span></code>()</td>
<td>Returns the size of the matrix that defines the drift dynamics that is assuming the drift is NxN, then this returns N</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dyn_gen</span></code>(k)</td>
<td>Get the combined dynamics generator for the timeslot Not implemented in the base class.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_num_ctrls</span></code>()</td>
<td>calculate the of controls from the length of the control list sets the num_ctrls property, which can be used alternatively subsequently</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_timeslots</span></code>()</td>
<td>Generate the timeslot duration array 'tau' based on the evo_time and num_tslots attributes, unless the tau attribute is already set in which case this step in ignored Generate the cumulative time array 'time' based on the tau values</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_controls</span></code>(amps[,&nbsp;init_tslots])</td>
<td>Set the initial control amplitudes and time slices Note this must be called after the configuration is complete before any dynamics can be calculated</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">refresh_drift_attribs</span></code>()</td>
<td>Reset the dyn_shape, dyn_dims and time_depend_drift attribs</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_amps</span></code>([file_name,&nbsp;times,&nbsp;amps,&nbsp;verbose])</td>
<td>Save a file with the current control amplitudes in each timeslot The first column in the file will be the start time of the slot</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitarity_check</span></code>()</td>
<td>Checks whether all propagators are unitary</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_ctrl_amps</span></code>(new_amps)</td>
<td>Determine if any amplitudes have changed.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="73%" />
<col width="27%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>check_ctrls_initialized</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_amp_times</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_owd_evo_target</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="qutip.control.dynamics.DynamicsUnitary">
<em class="property">class </em><code class="descclassname">qutip.control.dynamics.</code><code class="descname">DynamicsUnitary</code><span class="sig-paren">(</span><em>optimconfig</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#DynamicsUnitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the subclass to use for systems with dynamics described by
unitary matrices. E.g. closed systems with Hermitian Hamiltonians
Note a matrix diagonalisation is used to compute the exponent
The eigen decomposition is also used to calculate the propagator gradient.
The method is taken from DYNAMO (see file header)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>drift_ham</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">This is the drift Hamiltonian for unitary dynamics
It is mapped to drift_dyn_gen during initialize_controls</p>
</dd>
<dt><strong>ctrl_ham</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">These are the control Hamiltonians for unitary dynamics
It is mapped to ctrl_dyn_gen during initialize_controls</p>
</dd>
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><p class="first last">The combined drift and control Hamiltonians for each timeslot
These are the dynamics generators for unitary dynamics.
It is mapped to dyn_gen during initialize_controls</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dynamics.DynamicsUnitary.check_unitarity" title="qutip.control.dynamics.DynamicsUnitary.check_unitarity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">check_unitarity</span></code></a>()</td>
<td>Checks whether all propagators are unitary For propagators found not to be unitary, the potential underlying causes are investigated.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_dyn_gen</span></code>(k)</td>
<td>Computes the dynamics generator for a given timeslot The is the combined Hamiltion for unitary systems</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_evolution</span></code>()</td>
<td>Recalculate the time evolution operators Dynamics generators (e.g.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code>()</td>
<td>Flag evolution, fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ctrl_dyn_gen</span></code>(j)</td>
<td>Get the dynamics generator for the control Not implemented in the base class.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_drift_dim</span></code>()</td>
<td>Returns the size of the matrix that defines the drift dynamics that is assuming the drift is NxN, then this returns N</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dyn_gen</span></code>(k)</td>
<td>Get the combined dynamics generator for the timeslot Not implemented in the base class.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_num_ctrls</span></code>()</td>
<td>calculate the of controls from the length of the control list sets the num_ctrls property, which can be used alternatively subsequently</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_timeslots</span></code>()</td>
<td>Generate the timeslot duration array 'tau' based on the evo_time and num_tslots attributes, unless the tau attribute is already set in which case this step in ignored Generate the cumulative time array 'time' based on the tau values</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dynamics.DynamicsUnitary.initialize_controls" title="qutip.control.dynamics.DynamicsUnitary.initialize_controls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_controls</span></code></a>(amplitudes[,&nbsp;init_tslots])</td>
<td>Set the initial control amplitudes and time slices Note this must be called after the configuration is complete before any dynamics can be calculated</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">refresh_drift_attribs</span></code>()</td>
<td>Reset the dyn_shape, dyn_dims and time_depend_drift attribs</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_amps</span></code>([file_name,&nbsp;times,&nbsp;amps,&nbsp;verbose])</td>
<td>Save a file with the current control amplitudes in each timeslot The first column in the file will be the start time of the slot</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitarity_check</span></code>()</td>
<td>Checks whether all propagators are unitary</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_ctrl_amps</span></code>(new_amps)</td>
<td>Determine if any amplitudes have changed.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="73%" />
<col width="27%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>check_ctrls_initialized</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_amp_times</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_owd_evo_target</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.dynamics.DynamicsUnitary.check_unitarity">
<code class="descname">check_unitarity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#DynamicsUnitary.check_unitarity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary.check_unitarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether all propagators are unitary
For propagators found not to be unitary, the potential underlying
causes are investigated.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dynamics.DynamicsUnitary.initialize_controls">
<code class="descname">initialize_controls</code><span class="sig-paren">(</span><em>amplitudes</em>, <em>init_tslots=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#DynamicsUnitary.initialize_controls"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary.initialize_controls" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial control amplitudes and time slices
Note this must be called after the configuration is complete
before any dynamics can be calculated</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dynamics.DynamicsUnitary.num_ctrls">
<code class="descname">num_ctrls</code><a class="headerlink" href="#qutip.control.dynamics.DynamicsUnitary.num_ctrls" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate the of controls from the length of the control list
sets the num_ctrls property, which can be used alternatively
subsequently</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dynamics.DynamicsSymplectic">
<em class="property">class </em><code class="descclassname">qutip.control.dynamics.</code><code class="descname">DynamicsSymplectic</code><span class="sig-paren">(</span><em>optimconfig</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dynamics.html#DynamicsSymplectic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dynamics.DynamicsSymplectic" title="Permalink to this definition">¶</a></dt>
<dd><p>Symplectic systems
This is the subclass to use for systems where the dynamics is described
by symplectic matrices, e.g. coupled oscillators, quantum optics</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>omega</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[drift_dyn_gen.shape]</span></dt>
<dd><p class="first last">matrix used in the calculation of propagators (time evolution)
with symplectic systems.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">combine_dyn_gen</span></code>(k)</td>
<td>Computes the dynamics generator for a given timeslot The is the combined Hamiltion for unitary systems</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_evolution</span></code>()</td>
<td>Recalculate the time evolution operators Dynamics generators (e.g.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code>()</td>
<td>Flag evolution, fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_ctrl_dyn_gen</span></code>(j)</td>
<td>Get the dynamics generator for the control Not implemented in the base class.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_drift_dim</span></code>()</td>
<td>Returns the size of the matrix that defines the drift dynamics that is assuming the drift is NxN, then this returns N</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_dyn_gen</span></code>(k)</td>
<td>Get the combined dynamics generator for the timeslot Not implemented in the base class.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_num_ctrls</span></code>()</td>
<td>calculate the of controls from the length of the control list sets the num_ctrls property, which can be used alternatively subsequently</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_timeslots</span></code>()</td>
<td>Generate the timeslot duration array 'tau' based on the evo_time and num_tslots attributes, unless the tau attribute is already set in which case this step in ignored Generate the cumulative time array 'time' based on the tau values</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">initialize_controls</span></code>(amps[,&nbsp;init_tslots])</td>
<td>Set the initial control amplitudes and time slices Note this must be called after the configuration is complete before any dynamics can be calculated</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">refresh_drift_attribs</span></code>()</td>
<td>Reset the dyn_shape, dyn_dims and time_depend_drift attribs</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">save_amps</span></code>([file_name,&nbsp;times,&nbsp;amps,&nbsp;verbose])</td>
<td>Save a file with the current control amplitudes in each timeslot The first column in the file will be the start time of the slot</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">unitarity_check</span></code>()</td>
<td>Checks whether all propagators are unitary</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_ctrl_amps</span></code>(new_amps)</td>
<td>Determine if any amplitudes have changed.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="73%" />
<col width="27%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>check_ctrls_initialized</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>get_amp_times</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_owd_evo_target</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="qutip.control.dynamics.DynamicsSymplectic.dyn_gen_phase">
<code class="descname">dyn_gen_phase</code><a class="headerlink" href="#qutip.control.dynamics.DynamicsSymplectic.dyn_gen_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>The phasing operator for the symplectic group generators
usually refered to as Omega
By default this is applied as 'postop' dyn_gen*-Omega
If phase_application is 'preop' it is applied as Omega*dyn_gen</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.propcomp.PropagatorComputer">
<em class="property">class </em><code class="descclassname">qutip.control.propcomp.</code><code class="descname">PropagatorComputer</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropagatorComputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropagatorComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base for all  Propagator Computer classes
that are used to calculate the propagators,
and also the propagator gradient when exact gradient methods are used
Note: they must be instantiated with a Dynamics object, that is the
container for the data that the functions operate on
This base class cannot be used directly. See subclass descriptions
and choose the appropriate one for the application</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip_utils.logging,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>grad_exact</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">indicates whether the computer class instance is capable
of computing propagator gradients. It is used to determine
whether to create the Dynamics prop_grad array</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.propcomp.PropagatorComputer.apply_params" title="qutip.control.propcomp.PropagatorComputer.apply_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code></a>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.propcomp.PropagatorComputer.reset" title="qutip.control.propcomp.PropagatorComputer.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>compute_diff_prop</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>compute_prop_grad</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>compute_propagator</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>grad_exact</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.propcomp.PropagatorComputer.apply_params">
<code class="descname">apply_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropagatorComputer.apply_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropagatorComputer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.propcomp.PropagatorComputer.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropagatorComputer.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropagatorComputer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.propcomp.PropCompApproxGrad">
<em class="property">class </em><code class="descclassname">qutip.control.propcomp.</code><code class="descname">PropCompApproxGrad</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropCompApproxGrad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompApproxGrad" title="Permalink to this definition">¶</a></dt>
<dd><p>This subclass can be used when the propagator is calculated simply
by expm of the dynamics generator, i.e. when gradients will be calculated
using approximate methods.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.propcomp.PropCompApproxGrad.reset" title="qutip.control.propcomp.PropCompApproxGrad.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>compute_diff_prop</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>compute_prop_grad</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>compute_propagator</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>grad_exact</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.propcomp.PropCompApproxGrad.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropCompApproxGrad.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompApproxGrad.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.propcomp.PropCompDiag">
<em class="property">class </em><code class="descclassname">qutip.control.propcomp.</code><code class="descname">PropCompDiag</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropCompDiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompDiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Coumputes the propagator exponentiation using diagonalisation of
of the dynamics generator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.propcomp.PropCompDiag.reset" title="qutip.control.propcomp.PropCompDiag.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>compute_diff_prop</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>compute_prop_grad</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>compute_propagator</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>grad_exact</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.propcomp.PropCompDiag.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropCompDiag.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompDiag.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.propcomp.PropCompFrechet">
<em class="property">class </em><code class="descclassname">qutip.control.propcomp.</code><code class="descname">PropCompFrechet</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropCompFrechet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompFrechet" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Frechet method for calculating the propagator:</dt>
<dd>exponentiating the combined dynamics generator</dd>
</dl>
<p>and the propagator gradient
It should work for all systems, e.g. unitary, open, symplectic
There are other PropagatorComputer subclasses that may be more efficient</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.propcomp.PropCompFrechet.reset" title="qutip.control.propcomp.PropCompFrechet.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>compute_diff_prop</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>compute_prop_grad</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>compute_propagator</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>grad_exact</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.propcomp.PropCompFrechet.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/propcomp.html#PropCompFrechet.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.propcomp.PropCompFrechet.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.fidcomp.FidelityComputer">
<em class="property">class </em><code class="descclassname">qutip.control.fidcomp.</code><code class="descname">FidelityComputer</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all Fidelity Computers.
This cannot be used directly. See subclass descriptions and choose
one appropriate for the application
Note: this must be instantiated with a Dynamics object, that is the
container for the data that the methods operate on</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>dimensional_norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Normalisation constant</p>
</dd>
<dt><strong>fid_norm_func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Used to normalise the fidelity
See SU and PSU options for the unitary dynamics</p>
</dd>
<dt><strong>grad_norm_func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function</span></dt>
<dd><p class="first last">Used to normalise the fidelity gradient
See SU and PSU options for the unitary dynamics</p>
</dd>
<dt><strong>uses_onwd_evo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">flag to specify whether the onwd_evo evolution operator
(see Dynamics) is used by the FidelityComputer</p>
</dd>
<dt><strong>uses_onto_evo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><dl class="first last docutils">
<dt>flag to specify whether the onto_evo evolution operator</dt>
<dd><p class="first last">(see Dynamics) is used by the FidelityComputer</p>
</dd>
</dl>
</dd>
<dt><strong>fid_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Last computed value of the fidelity error</p>
</dd>
<dt><strong>fidelity</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Last computed value of the normalised fidelity</p>
</dd>
<dt><strong>fidelity_current</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">flag to specify whether the fidelity / fid_err are based on the
current amplitude values. Set False when amplitudes change</p>
</dd>
<dt><strong>fid_err_grad: array[num_tslot, num_ctrls] of float</strong></dt>
<dd><p class="first last">Last computed values for the fidelity error gradients wrt the
control in the timeslot</p>
</dd>
<dt><strong>grad_norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Last computed value for the norm of the fidelity error gradients
(sqrt of the sum of the squares)</p>
</dd>
<dt><strong>fid_err_grad_current</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">flag to specify whether the fidelity / fid_err are based on the
current amplitude values. Set False when amplitudes change</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.apply_params" title="qutip.control.fidcomp.FidelityComputer.apply_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code></a>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.clear" title="qutip.control.fidcomp.FidelityComputer.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</td>
<td>clear any temporarily held status data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.flag_system_changed" title="qutip.control.fidcomp.FidelityComputer.flag_system_changed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code></a>()</td>
<td>Flag fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.get_fid_err" title="qutip.control.fidcomp.FidelityComputer.get_fid_err"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err</span></code></a>()</td>
<td>returns the absolute distance from the maximum achievable fidelity</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.get_fid_err_gradient" title="qutip.control.fidcomp.FidelityComputer.get_fid_err_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err_gradient</span></code></a>()</td>
<td>Returns the normalised gradient of the fidelity error in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.init_comp" title="qutip.control.fidcomp.FidelityComputer.init_comp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_comp</span></code></a>()</td>
<td>initialises the computer based on the configuration of the Dynamics</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidelityComputer.reset" title="qutip.control.fidcomp.FidelityComputer.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data and clear any temporarily held status data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.apply_params">
<code class="descname">apply_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.apply_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear any temporarily held status data</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.flag_system_changed">
<code class="descname">flag_system_changed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.flag_system_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.flag_system_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag fidelity and gradients as needing recalculation</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.get_fid_err">
<code class="descname">get_fid_err</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.get_fid_err"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.get_fid_err" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the absolute distance from the maximum achievable fidelity</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.get_fid_err_gradient">
<code class="descname">get_fid_err_gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.get_fid_err_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.get_fid_err_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalised gradient of the fidelity error
in a (nTimeslots x n_ctrls) array wrt the timeslot control amplitude</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.init_comp">
<code class="descname">init_comp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.init_comp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.init_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>initialises the computer based on the configuration of the Dynamics</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidelityComputer.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidelityComputer.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidelityComputer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.fidcomp.FidCompUnitary">
<em class="property">class </em><code class="descclassname">qutip.control.fidcomp.</code><code class="descname">FidCompUnitary</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes fidelity error and gradient assuming unitary dynamics, e.g.
closed qubit systems
Note fidelity and gradient calculations were taken from DYNAMO
(see file header)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phase_option</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><dl class="first last docutils">
<dt>determines how global phase is treated in fidelity calculations:</dt>
<dd><p class="first last">PSU - global phase ignored
SU - global phase included</p>
</dd>
</dl>
</dd>
<dt><strong>fidelity_prenorm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">complex</span></dt>
<dd><p class="first last">Last computed value of the fidelity before it is normalised
It is stored to use in the gradient normalisation calculation</p>
</dd>
<dt><strong>fidelity_prenorm_current</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">flag to specify whether fidelity_prenorm are based on the
current amplitude values. Set False when amplitudes change</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.clear" title="qutip.control.fidcomp.FidCompUnitary.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>()</td>
<td>clear any temporarily held status data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.compute_fid_grad" title="qutip.control.fidcomp.FidCompUnitary.compute_fid_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_fid_grad</span></code></a>()</td>
<td>Calculates exact gradient of function wrt to each timeslot control amplitudes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.flag_system_changed" title="qutip.control.fidcomp.FidCompUnitary.flag_system_changed"><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code></a>()</td>
<td>Flag fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.get_fid_err" title="qutip.control.fidcomp.FidCompUnitary.get_fid_err"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err</span></code></a>()</td>
<td>Gets the absolute error in the fidelity</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.get_fid_err_gradient" title="qutip.control.fidcomp.FidCompUnitary.get_fid_err_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err_gradient</span></code></a>()</td>
<td>Returns the normalised gradient of the fidelity error in a (nTimeslots x n_ctrls) array The gradients are cached in case they are requested mutliple times between control updates (although this is not typically found to happen)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.get_fidelity" title="qutip.control.fidcomp.FidCompUnitary.get_fidelity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fidelity</span></code></a>()</td>
<td>Gets the appropriately normalised fidelity value The normalisation is determined by the fid_norm_func pointer which should be set in the config</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.get_fidelity_prenorm" title="qutip.control.fidcomp.FidCompUnitary.get_fidelity_prenorm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fidelity_prenorm</span></code></a>()</td>
<td>Gets the current fidelity value prior to normalisation Note the gradient function uses this value The value is cached, because it is used in the gradient calculation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.init_comp" title="qutip.control.fidcomp.FidCompUnitary.init_comp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_comp</span></code></a>()</td>
<td>Check configuration and initialise the normalisation</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.init_normalization" title="qutip.control.fidcomp.FidCompUnitary.init_normalization"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_normalization</span></code></a>()</td>
<td>Calc norm of &lt;Ufinal | Ufinal&gt; to scale subsequent norms When considering unitary time evolution operators, this basically results in calculating the trace of the identity matrix and is hence equal to the size of the target matrix There may be situations where this is not the case, and hence it is not assumed to be so.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.normalize_gradient_PSU" title="qutip.control.fidcomp.FidCompUnitary.normalize_gradient_PSU"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_gradient_PSU</span></code></a>(grad)</td>
<td>Normalise the gradient matrix passed as grad This PSU version is independent of global phase</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.normalize_gradient_SU" title="qutip.control.fidcomp.FidCompUnitary.normalize_gradient_SU"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize_gradient_SU</span></code></a>(grad)</td>
<td>Normalise the gradient matrix passed as grad This SU version respects global phase</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.reset" title="qutip.control.fidcomp.FidCompUnitary.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data and clear any temporarily held status data</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompUnitary.set_phase_option" title="qutip.control.fidcomp.FidCompUnitary.set_phase_option"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_phase_option</span></code></a>([phase_option])</td>
<td>Deprecated - use phase_option Phase options are SU - global phase important PSU - global phase is not important</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="63%" />
<col width="37%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>normalize_PSU</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>normalize_SU</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.clear">
<code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>clear any temporarily held status data</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.compute_fid_grad">
<code class="descname">compute_fid_grad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.compute_fid_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.compute_fid_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates exact gradient of function wrt to each timeslot
control amplitudes. Note these gradients are not normalised
These are returned as a (nTimeslots x n_ctrls) array</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.flag_system_changed">
<code class="descname">flag_system_changed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.flag_system_changed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.flag_system_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Flag fidelity and gradients as needing recalculation</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fid_err">
<code class="descname">get_fid_err</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.get_fid_err"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fid_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the absolute error in the fidelity</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fid_err_gradient">
<code class="descname">get_fid_err_gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.get_fid_err_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fid_err_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalised gradient of the fidelity error
in a (nTimeslots x n_ctrls) array
The gradients are cached in case they are requested
mutliple times between control updates
(although this is not typically found to happen)</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fidelity">
<code class="descname">get_fidelity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.get_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the appropriately normalised fidelity value
The normalisation is determined by the fid_norm_func pointer
which should be set in the config</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.get_fidelity_prenorm">
<code class="descname">get_fidelity_prenorm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.get_fidelity_prenorm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.get_fidelity_prenorm" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the current fidelity value prior to normalisation
Note the gradient function uses this value
The value is cached, because it is used in the gradient calculation</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.init_comp">
<code class="descname">init_comp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.init_comp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.init_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>Check configuration and initialise the normalisation</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.init_normalization">
<code class="descname">init_normalization</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.init_normalization"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.init_normalization" title="Permalink to this definition">¶</a></dt>
<dd><p>Calc norm of &lt;Ufinal | Ufinal&gt; to scale subsequent norms
When considering unitary time evolution operators, this basically
results in calculating the trace of the identity matrix
and is hence equal to the size of the target matrix
There may be situations where this is not the case, and hence it
is not assumed to be so.
The normalisation function called should be set to either the
PSU - global phase ignored
SU  - global phase respected</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_PSU">
<code class="descname">normalize_PSU</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_PSU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_PSU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_SU">
<code class="descname">normalize_SU</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_SU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_SU" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_gradient_PSU">
<code class="descname">normalize_gradient_PSU</code><span class="sig-paren">(</span><em>grad</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_gradient_PSU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_gradient_PSU" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalise the gradient matrix passed as grad
This PSU version is independent of global phase</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.normalize_gradient_SU">
<code class="descname">normalize_gradient_SU</code><span class="sig-paren">(</span><em>grad</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.normalize_gradient_SU"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.normalize_gradient_SU" title="Permalink to this definition">¶</a></dt>
<dd><p>Normalise the gradient matrix passed as grad
This SU version respects global phase</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompUnitary.set_phase_option">
<code class="descname">set_phase_option</code><span class="sig-paren">(</span><em>phase_option=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompUnitary.set_phase_option"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompUnitary.set_phase_option" title="Permalink to this definition">¶</a></dt>
<dd><p>Deprecated - use phase_option
Phase options are
SU - global phase important
PSU - global phase is not important</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.fidcomp.FidCompTraceDiff">
<em class="property">class </em><code class="descclassname">qutip.control.fidcomp.</code><code class="descname">FidCompTraceDiff</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiff"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes fidelity error and gradient for general system dynamics
by calculating the the fidelity error as the trace of the overlap
of the difference between the target and evolution resulting from
the pulses with the transpose of the same.
This should provide a distance measure for dynamics described by matrices
Note the gradient calculation is taken from:
'Robust quantum gates for open systems via optimal control:
Markovian versus non-Markovian dynamics'
Frederik F Floether, Pierre de Fouquieres, and Sophie G Schirmer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scale_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The fidelity error calculated is of some arbitary scale. This
factor can be used to scale the fidelity error such that it may
represent some physical measure
If None is given then it is caculated as 1/2N, where N
is the dimension of the drift, when the Dynamics are initialised.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</td>
<td>clear any temporarily held status data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiff.compute_fid_err_grad" title="qutip.control.fidcomp.FidCompTraceDiff.compute_fid_err_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_fid_err_grad</span></code></a>()</td>
<td>Calculate exact gradient of the fidelity error function wrt to each timeslot control amplitudes.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code>()</td>
<td>Flag fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiff.get_fid_err" title="qutip.control.fidcomp.FidCompTraceDiff.get_fid_err"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err</span></code></a>()</td>
<td>Gets the absolute error in the fidelity</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiff.get_fid_err_gradient" title="qutip.control.fidcomp.FidCompTraceDiff.get_fid_err_gradient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err_gradient</span></code></a>()</td>
<td>Returns the normalised gradient of the fidelity error in a (nTimeslots x n_ctrls) array The gradients are cached in case they are requested mutliple times between control updates (although this is not typically found to happen)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiff.init_comp" title="qutip.control.fidcomp.FidCompTraceDiff.init_comp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_comp</span></code></a>()</td>
<td>initialises the computer based on the configuration of the Dynamics Calculates the scale_factor is not already set</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiff.reset" title="qutip.control.fidcomp.FidCompTraceDiff.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data and clear any temporarily held status data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.compute_fid_err_grad">
<code class="descname">compute_fid_err_grad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiff.compute_fid_err_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.compute_fid_err_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate exact gradient of the fidelity error function
wrt to each timeslot control amplitudes.
Uses the trace difference norm fidelity
These are returned as a (nTimeslots x n_ctrls) array</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.get_fid_err">
<code class="descname">get_fid_err</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiff.get_fid_err"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.get_fid_err" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the absolute error in the fidelity</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.get_fid_err_gradient">
<code class="descname">get_fid_err_gradient</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiff.get_fid_err_gradient"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.get_fid_err_gradient" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the normalised gradient of the fidelity error
in a (nTimeslots x n_ctrls) array
The gradients are cached in case they are requested
mutliple times between control updates
(although this is not typically found to happen)</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.init_comp">
<code class="descname">init_comp</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiff.init_comp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.init_comp" title="Permalink to this definition">¶</a></dt>
<dd><p>initialises the computer based on the configuration of the Dynamics
Calculates the scale_factor is not already set</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiff.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiff.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiff.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.fidcomp.FidCompTraceDiffApprox">
<em class="property">class </em><code class="descclassname">qutip.control.fidcomp.</code><code class="descname">FidCompTraceDiffApprox</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiffApprox"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiffApprox" title="Permalink to this definition">¶</a></dt>
<dd><p>As FidCompTraceDiff, except uses the finite difference method to
compute approximate gradients</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>epsilon</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">control amplitude offset to use when approximating the gradient wrt
a timeslot control amplitude</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code>()</td>
<td>clear any temporarily held status data</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiffApprox.compute_fid_err_grad" title="qutip.control.fidcomp.FidCompTraceDiffApprox.compute_fid_err_grad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compute_fid_err_grad</span></code></a>()</td>
<td>Calculates gradient of function wrt to each timeslot control amplitudes.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">flag_system_changed</span></code>()</td>
<td>Flag fidelity and gradients as needing recalculation</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err</span></code>()</td>
<td>Gets the absolute error in the fidelity</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_fid_err_gradient</span></code>()</td>
<td>Returns the normalised gradient of the fidelity error in a (nTimeslots x n_ctrls) array The gradients are cached in case they are requested mutliple times between control updates (although this is not typically found to happen)</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_comp</span></code>()</td>
<td>initialises the computer based on the configuration of the Dynamics Calculates the scale_factor is not already set</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.fidcomp.FidCompTraceDiffApprox.reset" title="qutip.control.fidcomp.FidCompTraceDiffApprox.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset any configuration data and clear any temporarily held status data</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiffApprox.compute_fid_err_grad">
<code class="descname">compute_fid_err_grad</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiffApprox.compute_fid_err_grad"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiffApprox.compute_fid_err_grad" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates gradient of function wrt to each timeslot
control amplitudes. Note these gradients are not normalised
They are calulated
These are returned as a (nTimeslots x n_ctrls) array</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.fidcomp.FidCompTraceDiffApprox.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/fidcomp.html#FidCompTraceDiffApprox.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.fidcomp.FidCompTraceDiffApprox.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset any configuration data and
clear any temporarily held status data</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.tslotcomp.TimeslotComputer">
<em class="property">class </em><code class="descclassname">qutip.control.tslotcomp.</code><code class="descname">TimeslotComputer</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TimeslotComputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TimeslotComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all Timeslot Computers
Note: this must be instantiated with a Dynamics object, that is the
container for the data that the methods operate on</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>evo_comp_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">EvoCompSummary</span></dt>
<dd><p class="first last">A summary of the most recent evolution computation
Used in the stats and dump
Will be set to None if neither stats or dump are set</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.tslotcomp.TimeslotComputer.apply_params" title="qutip.control.tslotcomp.TimeslotComputer.apply_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code></a>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.tslotcomp.TimeslotComputer.dump_current" title="qutip.control.tslotcomp.TimeslotComputer.dump_current"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump_current</span></code></a>()</td>
<td>Store a copy of the current time evolution</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="68%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>flag_all_calc_now</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>init_comp</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.tslotcomp.TimeslotComputer.apply_params">
<code class="descname">apply_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TimeslotComputer.apply_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TimeslotComputer.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value
Note: attributes are created if they do not exist already,
and are overwritten if they do.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.tslotcomp.TimeslotComputer.dump_current">
<code class="descname">dump_current</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TimeslotComputer.dump_current"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TimeslotComputer.dump_current" title="Permalink to this definition">¶</a></dt>
<dd><p>Store a copy of the current time evolution</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll">
<em class="property">class </em><code class="descclassname">qutip.control.tslotcomp.</code><code class="descname">TSlotCompUpdateAll</code><span class="sig-paren">(</span><em>dynamics</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll" title="Permalink to this definition">¶</a></dt>
<dd><p>Timeslot Computer - Update All
Updates all dynamics generators, propagators and evolutions when
ctrl amplitudes are updated</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.compare_amps" title="qutip.control.tslotcomp.TSlotCompUpdateAll.compare_amps"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compare_amps</span></code></a>(new_amps)</td>
<td>Determine if any amplitudes have changed.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">dump_current</span></code>()</td>
<td>Store a copy of the current time evolution</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.get_timeslot_for_fidelity_calc" title="qutip.control.tslotcomp.TSlotCompUpdateAll.get_timeslot_for_fidelity_calc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_timeslot_for_fidelity_calc</span></code></a>()</td>
<td>Returns the timeslot index that will be used calculate current fidelity value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.recompute_evolution" title="qutip.control.tslotcomp.TSlotCompUpdateAll.recompute_evolution"><code class="xref py py-obj docutils literal notranslate"><span class="pre">recompute_evolution</span></code></a>()</td>
<td>Recalculates the evolution operators.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="68%" />
<col width="32%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>flag_all_calc_now</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>init_comp</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll.compare_amps">
<code class="descname">compare_amps</code><span class="sig-paren">(</span><em>new_amps</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll.compare_amps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.compare_amps" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine if any amplitudes have changed. If so, then mark the
timeslots as needing recalculation
Returns: True if amplitudes are the same, False if they have changed</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll.get_timeslot_for_fidelity_calc">
<code class="descname">get_timeslot_for_fidelity_calc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll.get_timeslot_for_fidelity_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.get_timeslot_for_fidelity_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the timeslot index that will be used calculate current fidelity
value.
This (default) method simply returns the last timeslot</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.tslotcomp.TSlotCompUpdateAll.recompute_evolution">
<code class="descname">recompute_evolution</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/tslotcomp.html#TSlotCompUpdateAll.recompute_evolution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.tslotcomp.TSlotCompUpdateAll.recompute_evolution" title="Permalink to this definition">¶</a></dt>
<dd><p>Recalculates the evolution operators.
Dynamics generators (e.g. Hamiltonian) and
prop (propagators) are calculated as necessary</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGen">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGen</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen" title="Permalink to this definition">¶</a></dt>
<dd><p>Pulse generator
Base class for all Pulse generators
The object can optionally be instantiated with a Dynamics object,
in which case the timeslots and amplitude scaling and offset
are copied from that.
Otherwise the class can be used independently by setting:
tau (array of timeslot durations)
or
num_tslots and pulse_time for equally spaced timeslots</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of timeslots, aka timeslices
(copied from Dynamics if given)</p>
</dd>
<dt><strong>pulse_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">total duration of the pulse
(copied from Dynamics.evo_time if given)</p>
</dd>
<dt><strong>scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">linear scaling applied to the pulse
(copied from Dynamics.initial_ctrl_scaling if given)</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">linear offset applied to the pulse
(copied from Dynamics.initial_ctrl_offset if given)</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of float</span></dt>
<dd><p class="first last">Duration of each timeslot
(copied from Dynamics if given)</p>
</dd>
<dt><strong>lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Lower boundary for the pulse amplitudes
Note that the scaling and offset attributes can be used to fully
bound the pulse for all generators except some of the random ones
This bound (if set) may result in additional shifting / scaling
Default is -Inf</p>
</dd>
<dt><strong>ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Upper boundary for the pulse amplitudes
Note that the scaling and offset attributes can be used to fully
bound the pulse for all generators except some of the random ones
This bound (if set) may result in additional shifting / scaling
Default is Inf</p>
</dd>
<dt><strong>periodic</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">True if the pulse generator produces periodic pulses</p>
</dd>
<dt><strong>random</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">True if the pulse generator produces random pulses</p>
</dd>
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGen.apply_params" title="qutip.control.pulsegen.PulseGen.apply_params"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code></a>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGen.gen_pulse" title="qutip.control.pulsegen.PulseGen.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>()</td>
<td>returns the pulse as an array of vales for each timeslot Must be implemented by subclass</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGen.init_pulse" title="qutip.control.pulsegen.PulseGen.init_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code></a>()</td>
<td>Initialise the pulse parameters</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGen.reset" title="qutip.control.pulsegen.PulseGen.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGen.apply_params">
<code class="descname">apply_params</code><span class="sig-paren">(</span><em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGen.apply_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.apply_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Set object attributes based on the dictionary (if any) passed in the 
instantiation, or passed as a parameter
This is called during the instantiation automatically.
The key value pairs are the attribute name and value</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGen.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGen.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>returns the pulse as an array of vales for each timeslot
Must be implemented by subclass</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGen.init_pulse">
<code class="descname">init_pulse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGen.init_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialise the pulse parameters</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGen.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGen.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGen.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenRandom">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenRandom</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenRandom"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenRandom" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates random pulses as simply random values for each timeslot</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenRandom.gen_pulse" title="qutip.control.pulsegen.PulseGenRandom.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>()</td>
<td>Generate a pulse of random values between 1 and -1 Values are scaled using the scaling property and shifted using the offset property Returns the pulse as an array of vales for each timeslot</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>()</td>
<td>Initialise the pulse parameters</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenRandom.reset" title="qutip.control.pulsegen.PulseGenRandom.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenRandom.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenRandom.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenRandom.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse of random values between 1 and -1
Values are scaled using the scaling property
and shifted using the offset property
Returns the pulse as an array of vales for each timeslot</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenRandom.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenRandom.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenRandom.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenZero">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenZero</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenZero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenZero" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a flat pulse</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenZero.gen_pulse" title="qutip.control.pulsegen.PulseGenZero.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>()</td>
<td>Generate a pulse with the same value in every timeslot.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>()</td>
<td>Initialise the pulse parameters</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenZero.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenZero.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenZero.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse with the same value in every timeslot.
The value will be zero, unless the offset is not zero,
in which case it will be the offset</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenLinear">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenLinear</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenLinear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates linear pulses</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gradient</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Gradient of the line.
Note this is calculated from the start_val and end_val if these
are given</p>
</dd>
<dt><strong>start_val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Start point of the line. That is the starting amplitude</p>
</dd>
<dt><strong>end_val</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">End point of the line.
That is the amplitude at the start of the last timeslot</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenLinear.gen_pulse" title="qutip.control.pulsegen.PulseGenLinear.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([gradient,&nbsp;start_val,&nbsp;end_val])</td>
<td>Generate a linear pulse using either the gradient and start value or using the end point to calulate the gradient Note that the scaling and offset parameters are still applied, so unless these values are the default 1.0 and 0.0, then the actual gradient etc will be different Returns the pulse as an array of vales for each timeslot</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenLinear.init_pulse" title="qutip.control.pulsegen.PulseGenLinear.init_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code></a>([gradient,&nbsp;start_val,&nbsp;end_val])</td>
<td>Calculate the gradient if pulse is defined by start and  end point values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenLinear.reset" title="qutip.control.pulsegen.PulseGenLinear.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenLinear.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>gradient=None</em>, <em>start_val=None</em>, <em>end_val=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenLinear.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a linear pulse using either the gradient and start value
or using the end point to calulate the gradient
Note that the scaling and offset parameters are still applied,
so unless these values are the default 1.0 and 0.0, then the
actual gradient etc will be different
Returns the pulse as an array of vales for each timeslot</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenLinear.init_pulse">
<code class="descname">init_pulse</code><span class="sig-paren">(</span><em>gradient=None</em>, <em>start_val=None</em>, <em>end_val=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenLinear.init_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the gradient if pulse is defined by start and 
end point values</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenLinear.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenLinear.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenLinear.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenPeriodic">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenPeriodic</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenPeriodic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenPeriodic" title="Permalink to this definition">¶</a></dt>
<dd><p>Intermediate class for all periodic pulse generators
All of the periodic pulses range from -1 to 1
All have a start phase that can be set between 0 and 2pi</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>num_waves</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Number of complete waves (cycles) that occur in the pulse.
wavelen and freq calculated from this if it is given</p>
</dd>
<dt><strong>wavelen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Wavelength of the pulse (assuming the speed is 1)
freq is calculated from this if it is given</p>
</dd>
<dt><strong>freq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Frequency of the pulse</p>
</dd>
<dt><strong>start_phase</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Phase of the pulse signal when t=0</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code>()</td>
<td>returns the pulse as an array of vales for each timeslot Must be implemented by subclass</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenPeriodic.init_pulse" title="qutip.control.pulsegen.PulseGenPeriodic.init_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code></a>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Calculate the wavelength, frequency, number of waves etc from the each other and the other parameters If num_waves is given then the other parameters are worked from this Otherwise if the wavelength is given then it is the driver Otherwise the frequency is used to calculate wavelength and num_waves</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenPeriodic.reset" title="qutip.control.pulsegen.PulseGenPeriodic.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenPeriodic.init_pulse">
<code class="descname">init_pulse</code><span class="sig-paren">(</span><em>num_waves=None</em>, <em>wavelen=None</em>, <em>freq=None</em>, <em>start_phase=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenPeriodic.init_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenPeriodic.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the wavelength, frequency, number of waves etc
from the each other and the other parameters
If num_waves is given then the other parameters are worked from this
Otherwise if the wavelength is given then it is the driver
Otherwise the frequency is used to calculate wavelength and num_waves</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenPeriodic.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenPeriodic.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenPeriodic.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenSine">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenSine</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenSine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSine" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sine wave pulses</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenSine.gen_pulse" title="qutip.control.pulsegen.PulseGenSine.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Generate a sine wave pulse If no params are provided then the class object attributes are used.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Calculate the wavelength, frequency, number of waves etc from the each other and the other parameters If num_waves is given then the other parameters are worked from this Otherwise if the wavelength is given then it is the driver Otherwise the frequency is used to calculate wavelength and num_waves</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenSine.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>num_waves=None</em>, <em>wavelen=None</em>, <em>freq=None</em>, <em>start_phase=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenSine.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSine.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sine wave pulse
If no params are provided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs.
returns the pulse as an array of vales for each timeslot</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenSquare">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenSquare</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenSquare"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSquare" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates square wave pulses</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenSquare.gen_pulse" title="qutip.control.pulsegen.PulseGenSquare.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Generate a square wave pulse If no parameters are pavided then the class object attributes are used.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Calculate the wavelength, frequency, number of waves etc from the each other and the other parameters If num_waves is given then the other parameters are worked from this Otherwise if the wavelength is given then it is the driver Otherwise the frequency is used to calculate wavelength and num_waves</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenSquare.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>num_waves=None</em>, <em>wavelen=None</em>, <em>freq=None</em>, <em>start_phase=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenSquare.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSquare.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a square wave pulse
If no parameters are pavided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenSaw">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenSaw</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenSaw"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSaw" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates saw tooth wave pulses</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenSaw.gen_pulse" title="qutip.control.pulsegen.PulseGenSaw.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Generate a saw tooth wave pulse If no parameters are pavided then the class object attributes are used.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Calculate the wavelength, frequency, number of waves etc from the each other and the other parameters If num_waves is given then the other parameters are worked from this Otherwise if the wavelength is given then it is the driver Otherwise the frequency is used to calculate wavelength and num_waves</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenSaw.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>num_waves=None</em>, <em>wavelen=None</em>, <em>freq=None</em>, <em>start_phase=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenSaw.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenSaw.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a saw tooth wave pulse
If no parameters are pavided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenTriangle">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenTriangle</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenTriangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenTriangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates triangular wave pulses</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenTriangle.gen_pulse" title="qutip.control.pulsegen.PulseGenTriangle.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Generate a sine wave pulse If no parameters are pavided then the class object attributes are used.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>([num_waves,&nbsp;wavelen,&nbsp;freq,&nbsp;...])</td>
<td>Calculate the wavelength, frequency, number of waves etc from the each other and the other parameters If num_waves is given then the other parameters are worked from this Otherwise if the wavelength is given then it is the driver Otherwise the frequency is used to calculate wavelength and num_waves</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenTriangle.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>num_waves=None</em>, <em>wavelen=None</em>, <em>freq=None</em>, <em>start_phase=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenTriangle.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenTriangle.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a sine wave pulse
If no parameters are pavided then the class object attributes are used.
If they are provided, then these will reinitialise the object attribs</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenGaussian">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenGaussian</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenGaussian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates pulses with a Gaussian profile</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>log_level</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenGaussian.gen_pulse" title="qutip.control.pulsegen.PulseGenGaussian.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([mean,&nbsp;variance])</td>
<td>Generate a pulse with Gaussian shape.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>()</td>
<td>Initialise the pulse parameters</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenGaussian.reset" title="qutip.control.pulsegen.PulseGenGaussian.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenGaussian.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>mean=None</em>, <em>variance=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenGaussian.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussian.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse with Gaussian shape. The peak is centre around the
mean and the variance determines the breadth
The scaling and offset attributes are applied as an amplitude
and fixed linear offset. Note that the maximum amplitude will be
scaling + offset.</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenGaussian.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenGaussian.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussian.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenGaussianEdge">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenGaussianEdge</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenGaussianEdge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussianEdge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate pulses with inverted Gaussian ramping in and out
It's intended use for a ramping modulation, which is often required in 
experimental setups.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>decay_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Determines the ramping rate. It is approximately the time
required to bring the pulse to full amplitude
It is set to 1/10 of the pulse time by default</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenGaussianEdge.gen_pulse" title="qutip.control.pulsegen.PulseGenGaussianEdge.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([decay_time])</td>
<td>Generate a pulse that starts and ends at zero and 1.0 in between then apply scaling and offset The tailing in and out is an inverted Gaussian shape</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code>()</td>
<td>Initialise the pulse parameters</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenGaussianEdge.reset" title="qutip.control.pulsegen.PulseGenGaussianEdge.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenGaussianEdge.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>decay_time=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenGaussianEdge.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussianEdge.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse that starts and ends at zero and 1.0 in between
then apply scaling and offset
The tailing in and out is an inverted Gaussian shape</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenGaussianEdge.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenGaussianEdge.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenGaussianEdge.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenCrab">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenCrab</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>num_coeffs=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all CRAB pulse generators
Note these are more involved in the optimisation process as they are
used to produce piecewise control amplitudes each time new optimisation
parameters are tried</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>num_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of coefficients used for each basis function</p>
</dd>
<dt><strong>num_basis_funcs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of basis functions
In this case set at 2 and should not be changed</p>
</dd>
<dt><strong>coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array[num_coeffs, num_basis_funcs]</span></dt>
<dd><p class="first last">The basis coefficient values</p>
</dd>
<dt><strong>randomize_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True (default) then the coefficients are set to some random values
when initialised, otherwise they will all be equal to self.scaling</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrab.estimate_num_coeffs" title="qutip.control.pulsegen.PulseGenCrab.estimate_num_coeffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_num_coeffs</span></code></a>(dim)</td>
<td>Estimate the number coefficients based on the dimensionality of the system.</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code>()</td>
<td>returns the pulse as an array of vales for each timeslot Must be implemented by subclass</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrab.get_optim_var_vals" title="qutip.control.pulsegen.PulseGenCrab.get_optim_var_vals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_optim_var_vals</span></code></a>()</td>
<td>Get the parameter values to be optimised Returns ------- list (or 1d array) of floats</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrab.init_coeffs" title="qutip.control.pulsegen.PulseGenCrab.init_coeffs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_coeffs</span></code></a>([num_coeffs])</td>
<td>Generate the initial ceofficent values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrab.init_pulse" title="qutip.control.pulsegen.PulseGenCrab.init_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code></a>([num_coeffs])</td>
<td>Set the initial freq and coefficient values</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrab.reset" title="qutip.control.pulsegen.PulseGenCrab.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrab.set_optim_var_vals" title="qutip.control.pulsegen.PulseGenCrab.set_optim_var_vals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_optim_var_vals</span></code></a>(param_vals)</td>
<td>Set the values of the any of the pulse generation parameters based on new values from the optimisation method Typically this will be the basis coefficients</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_guess_pulse_scale</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>guess_pulse_add</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>guess_pulse_modulate</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>init_guess_pulse</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>set_coeffs</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrab.estimate_num_coeffs">
<code class="descname">estimate_num_coeffs</code><span class="sig-paren">(</span><em>dim</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab.estimate_num_coeffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.estimate_num_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the number coefficients based on the dimensionality of the
system.
Returns
-------
num_coeffs : int</p>
<blockquote>
<div>estimated number of coefficients</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrab.get_optim_var_vals">
<code class="descname">get_optim_var_vals</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab.get_optim_var_vals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.get_optim_var_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the parameter values to be optimised
Returns
-------
list (or 1d array) of floats</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrab.init_coeffs">
<code class="descname">init_coeffs</code><span class="sig-paren">(</span><em>num_coeffs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab.init_coeffs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.init_coeffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the initial ceofficent values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>num_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of coefficients used for each basis function
If given this overides the default and sets the attribute
of the same name.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrab.init_pulse">
<code class="descname">init_pulse</code><span class="sig-paren">(</span><em>num_coeffs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab.init_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial freq and coefficient values</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrab.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrab.set_optim_var_vals">
<code class="descname">set_optim_var_vals</code><span class="sig-paren">(</span><em>param_vals</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrab.set_optim_var_vals"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrab.set_optim_var_vals" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the values of the any of the pulse generation parameters
based on new values from the optimisation method
Typically this will be the basis coefficients</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier">
<em class="property">class </em><code class="descclassname">qutip.control.pulsegen.</code><code class="descname">PulseGenCrabFourier</code><span class="sig-paren">(</span><em>dyn=None</em>, <em>num_coeffs=None</em>, <em>params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrabFourier"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a pulse using the Fourier basis functions, i.e. sin and cos</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array[num_coeffs]</span></dt>
<dd><p class="first last">Frequencies for the basis functions</p>
</dd>
<dt><strong>randomize_freqs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True (default) the some random offset is applied to the frequencies</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply_params</span></code>([params])</td>
<td>Set object attributes based on the dictionary (if any) passed in the  instantiation, or passed as a parameter This is called during the instantiation automatically.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">estimate_num_coeffs</span></code>(dim)</td>
<td>Estimate the number coefficients based on the dimensionality of the system.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrabFourier.gen_pulse" title="qutip.control.pulsegen.PulseGenCrabFourier.gen_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">gen_pulse</span></code></a>([coeffs])</td>
<td>Generate a pulse using the Fourier basis with the freqs and coeffs attributes.</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_optim_var_vals</span></code>()</td>
<td>Get the parameter values to be optimised Returns ------- list (or 1d array) of floats</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_coeffs</span></code>([num_coeffs])</td>
<td>Generate the initial ceofficent values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrabFourier.init_freqs" title="qutip.control.pulsegen.PulseGenCrabFourier.init_freqs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_freqs</span></code></a>()</td>
<td>Generate the frequencies These are the Fourier harmonics with a uniformly distributed random offset</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrabFourier.init_pulse" title="qutip.control.pulsegen.PulseGenCrabFourier.init_pulse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">init_pulse</span></code></a>([num_coeffs])</td>
<td>Set the initial freq and coefficient values</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.pulsegen.PulseGenCrabFourier.reset" title="qutip.control.pulsegen.PulseGenCrabFourier.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>()</td>
<td>reset attributes to default values</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_optim_var_vals</span></code>(param_vals)</td>
<td>Set the values of the any of the pulse generation parameters based on new values from the optimisation method Typically this will be the basis coefficients</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_guess_pulse_scale</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>guess_pulse_add</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>guess_pulse_modulate</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>init_guess_pulse</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>set_coeffs</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.gen_pulse">
<code class="descname">gen_pulse</code><span class="sig-paren">(</span><em>coeffs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrabFourier.gen_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.gen_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a pulse using the Fourier basis with the freqs and
coeffs attributes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float array[num_coeffs, num_basis_funcs]</span></dt>
<dd><p class="first last">The basis coefficient values
If given this overides the default and sets the attribute
of the same name.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.init_freqs">
<code class="descname">init_freqs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrabFourier.init_freqs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.init_freqs" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the frequencies
These are the Fourier harmonics with a uniformly distributed
random offset</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.init_pulse">
<code class="descname">init_pulse</code><span class="sig-paren">(</span><em>num_coeffs=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrabFourier.init_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.init_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the initial freq and coefficient values</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.pulsegen.PulseGenCrabFourier.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#PulseGenCrabFourier.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.PulseGenCrabFourier.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>reset attributes to default values</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.stats.Stats">
<em class="property">class </em><code class="descclassname">qutip.control.stats.</code><code class="descname">Stats</code><a class="reference internal" href="../_modules/qutip/control/stats.html#Stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.stats.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for all optimisation statistics
Used for configurations where all timeslots are updated each iteration
e.g. exact gradients
Note that all times are generated using timeit.default_timer() and are
in seconds</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dyn_gen_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Text used in some report functions.
Makes sense to set it to 'Hamiltonian' when using unitary dynamics
Default is simply 'dynamics generator'</p>
</dd>
<dt><strong>num_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>wall_time_optim_start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Start time for the optimisation</p>
</dd>
<dt><strong>wall_time_optim_end</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">End time for the optimisation</p>
</dd>
<dt><strong>wall_time_optim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Time elasped during the optimisation</p>
</dd>
<dt><strong>wall_time_dyn_gen_compute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total wall (elasped) time computing combined dynamics generator
(for example combining drift and control Hamiltonians)</p>
</dd>
<dt><strong>wall_time_prop_compute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total wall (elasped) time computing propagators, that is the
time evolution from one timeslot to the next
Includes calculating the propagator gradient for exact gradients</p>
</dd>
<dt><strong>wall_time_fwd_prop_compute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total wall (elasped) time computing combined forward propagation,
that is the time evolution from the start to a specific timeslot.
Excludes calculating the propagators themselves</p>
</dd>
<dt><strong>wall_time_onwd_prop_compute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total wall (elasped) time computing combined onward propagation,
that is the time evolution from a specific timeslot to the end time.
Excludes calculating the propagators themselves</p>
</dd>
<dt><strong>wall_time_gradient_compute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total wall (elasped) time computing the fidelity error gradient.
Excludes calculating the propagator gradients (in exact gradient
methods)</p>
</dd>
<dt><strong>num_fidelity_func_calls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of calls to fidelity function by the optimisation algorithm</p>
</dd>
<dt><strong>num_grad_func_calls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of calls to gradient function by the optimisation algorithm</p>
</dd>
<dt><strong>num_tslot_recompute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of time the timeslot evolution is recomputed
(It is only computed if any amplitudes changed since the last call)</p>
</dd>
<dt><strong>num_fidelity_computes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of time the fidelity is computed
(It is only computed if any amplitudes changed since the last call)</p>
</dd>
<dt><strong>num_grad_computes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of time the gradient is computed
(It is only computed if any amplitudes changed since the last call)</p>
</dd>
<dt><strong>num_ctrl_amp_updates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of times the control amplitudes are updated</p>
</dd>
<dt><strong>mean_num_ctrl_amp_updates_per_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Mean number of control amplitude updates per iteration</p>
</dd>
<dt><strong>num_timeslot_changes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of times the amplitudes of a any control in a timeslot changes</p>
</dd>
<dt><strong>mean_num_timeslot_changes_per_update</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Mean average number of timeslot amplitudes that are changed per update</p>
</dd>
<dt><strong>num_ctrl_amp_changes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of times individual control amplitudes that are changed</p>
</dd>
<dt><strong>mean_num_ctrl_amp_changes_per_update</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Mean average number of control amplitudes that are changed per update</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.stats.Stats.calculate" title="qutip.control.stats.Stats.calculate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">calculate</span></code></a>()</td>
<td>Perform the calculations (e.g.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.stats.Stats.report" title="qutip.control.stats.Stats.report"><code class="xref py py-obj docutils literal notranslate"><span class="pre">report</span></code></a>()</td>
<td>Print a report of the stats to the console</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>report_amp_updates</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>report_func_calls</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>report_timings</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.stats.Stats.calculate">
<code class="descname">calculate</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/stats.html#Stats.calculate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.stats.Stats.calculate" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform the calculations (e.g. averages) that are required on the stats
Should be called before calling report</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.stats.Stats.report">
<code class="descname">report</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/stats.html#Stats.report"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.stats.Stats.report" title="Permalink to this definition">¶</a></dt>
<dd><p>Print a report of the stats to the console</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dump.Dump">
<em class="property">class </em><code class="descclassname">qutip.control.dump.</code><code class="descname">Dump</code><a class="reference internal" href="../_modules/qutip/control/dump.html#Dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.Dump" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for dump items.
The lists for dump items is depends on the type
Note: abstract class</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>parent</strong> <span class="classifier-delimiter">:</span> <span class="classifier">some control object (Dynamics or Optimizer)</span></dt>
<dd><p class="first last">aka the host. Object that generates the data that is dumped and is
host to this dump object.</p>
</dd>
<dt><strong>dump_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">directory where files (if any) will be written out
the path and be relative or absolute
use ~/ to specify user home directory
Note: files are only written when write_to_file is True
of writeout is called explicitly
Defaults to ~/.qtrl_dump</p>
</dd>
<dt><a class="reference internal" href="#qutip.control.dump.Dump.level" title="qutip.control.dump.Dump.level"><code class="xref py py-obj docutils literal notranslate"><span class="pre">level</span></code></a> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The level of data dumping that will occur - SUMMARY : A summary will be recorded - FULL : All possible dumping - CUSTOM : Some customised level of dumping When first set to CUSTOM this is equivalent to SUMMARY.</p>
</dd>
<dt><strong>write_to_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">When set True data and summaries (as configured) will be written
interactively to file during the processing
Set during instantiation by the host based on its dump_to_file attrib</p>
</dd>
<dt><strong>dump_file_ext</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Default file extension for any file names that are auto generated</p>
</dd>
<dt><strong>fname_base</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">First part of any auto generated file names.
This is usually overridden in the subclass</p>
</dd>
<dt><strong>dump_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True a summary is recorded each time a new item is added to the
the dump.
Default is True</p>
</dd>
<dt><strong>summary_sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">delimiter for the summary file.
default is a space</p>
</dd>
<dt><strong>data_sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">delimiter for the data files (arrays saved to file).
default is a space</p>
</dd>
<dt><strong>summary_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">File path for summary file.
Automatically generated. Can be set specifically</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dump.Dump.create_dump_dir" title="qutip.control.dump.Dump.create_dump_dir"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_dump_dir</span></code></a>()</td>
<td>Checks dump directory exists, creates it if not</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.dump.Dump.create_dump_dir">
<code class="descname">create_dump_dir</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#Dump.create_dump_dir"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.Dump.create_dump_dir" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks dump directory exists, creates it if not</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dump.Dump.level">
<code class="descname">level</code><a class="headerlink" href="#qutip.control.dump.Dump.level" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>The level of data dumping that will occur</dt>
<dd><ul class="first last simple">
<li>SUMMARY : A summary will be recorded</li>
<li>FULL : All possible dumping</li>
<li>CUSTOM : Some customised level of dumping</li>
</ul>
</dd>
</dl>
<p>When first set to CUSTOM this is equivalent to SUMMARY. It is then up
to the user to specify what specifically is dumped</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dump.OptimDump">
<em class="property">class </em><code class="descclassname">qutip.control.dump.</code><code class="descname">OptimDump</code><span class="sig-paren">(</span><em>optim</em>, <em>level='SUMMARY'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#OptimDump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.OptimDump" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for dumps of optimisation data generated during the pulse
optimisation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dump_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">When True summary items are appended to the iter_summary</p>
</dd>
<dt><strong>iter_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">optimizer.OptimIterSummary</span></code></span></dt>
<dd><p class="first last">Summary at each iteration</p>
</dd>
<dt><strong>dump_fid_err</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">When True values are appended to the fid_err_log</p>
</dd>
<dt><strong>fid_err_log</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of float</span></dt>
<dd><p class="first last">Fidelity error at each call of the fid_err_func</p>
</dd>
<dt><strong>dump_grad_norm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">When True values are appended to the fid_err_log</p>
</dd>
<dt><strong>grad_norm_log</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of float</span></dt>
<dd><p class="first last">Gradient norm at each call of the grad_norm_log</p>
</dd>
<dt><strong>dump_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">When True values are appended to the grad_log</p>
</dd>
<dt><strong>grad_log</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of ndarray</span></dt>
<dd><p class="first last">Gradients at each call of the fid_grad_func</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dump.OptimDump.add_iter_summary" title="qutip.control.dump.OptimDump.add_iter_summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_iter_summary</span></code></a>()</td>
<td>add copy of current optimizer iteration summary</td>
</tr>
<tr class="row-even"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_dump_dir</span></code>()</td>
<td>Checks dump directory exists, creates it if not</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dump.OptimDump.update_fid_err_log" title="qutip.control.dump.OptimDump.update_fid_err_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_fid_err_log</span></code></a>(fid_err)</td>
<td>add an entry to the fid_err log</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dump.OptimDump.update_grad_log" title="qutip.control.dump.OptimDump.update_grad_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_grad_log</span></code></a>(grad)</td>
<td>add an entry to the grad log</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dump.OptimDump.update_grad_norm_log" title="qutip.control.dump.OptimDump.update_grad_norm_log"><code class="xref py py-obj docutils literal notranslate"><span class="pre">update_grad_norm_log</span></code></a>(grad_norm)</td>
<td>add an entry to the grad_norm log</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dump.OptimDump.writeout" title="qutip.control.dump.OptimDump.writeout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">writeout</span></code></a>([f])</td>
<td>write all the logs and the summary out to file(s)</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.dump.OptimDump.add_iter_summary">
<code class="descname">add_iter_summary</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#OptimDump.add_iter_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.add_iter_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>add copy of current optimizer iteration summary</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dump.OptimDump.dump_all">
<code class="descname">dump_all</code><a class="headerlink" href="#qutip.control.dump.OptimDump.dump_all" title="Permalink to this definition">¶</a></dt>
<dd><p>True if everything (ignoring the summary) is to be dumped</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dump.OptimDump.dump_any">
<code class="descname">dump_any</code><a class="headerlink" href="#qutip.control.dump.OptimDump.dump_any" title="Permalink to this definition">¶</a></dt>
<dd><p>True if anything other than the summary is to be dumped</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dump.OptimDump.update_fid_err_log">
<code class="descname">update_fid_err_log</code><span class="sig-paren">(</span><em>fid_err</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#OptimDump.update_fid_err_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.update_fid_err_log" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the fid_err log</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dump.OptimDump.update_grad_log">
<code class="descname">update_grad_log</code><span class="sig-paren">(</span><em>grad</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#OptimDump.update_grad_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.update_grad_log" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the grad log</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dump.OptimDump.update_grad_norm_log">
<code class="descname">update_grad_norm_log</code><span class="sig-paren">(</span><em>grad_norm</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#OptimDump.update_grad_norm_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.update_grad_norm_log" title="Permalink to this definition">¶</a></dt>
<dd><p>add an entry to the grad_norm log</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dump.OptimDump.writeout">
<code class="descname">writeout</code><span class="sig-paren">(</span><em>f=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#OptimDump.writeout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.OptimDump.writeout" title="Permalink to this definition">¶</a></dt>
<dd><p>write all the logs and the summary out to file(s)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>f</strong> <span class="classifier-delimiter">:</span> <span class="classifier">filename or filehandle</span></dt>
<dd><p class="first last">If specified then all summary and  object data will go in one file.
If None is specified then type specific files will be generated
in the dump_dir
If a filehandle is specified then it must be a byte mode file
as numpy.savetxt is used, and requires this.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dump.DynamicsDump">
<em class="property">class </em><code class="descclassname">qutip.control.dump.</code><code class="descname">DynamicsDump</code><span class="sig-paren">(</span><em>dynamics</em>, <em>level='SUMMARY'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#DynamicsDump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump" title="Permalink to this definition">¶</a></dt>
<dd><p>A container for dumps of dynamics data.
Mainly time evolution calculations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Attributes:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dump_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True a summary is recorded</p>
</dd>
<dt><strong>evo_summary</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of :class:<a href="#id6"><span class="problematic" id="id7">`</span></a>tslotcomp.EvoCompSummary'</span></dt>
<dd><p class="first last">Summary items are appended if dump_summary is True
at each recomputation of the evolution.</p>
</dd>
<dt><strong>dump_amps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True control amplitudes are dumped</p>
</dd>
<dt><strong>dump_dyn_gen</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True the dynamics generators (Hamiltonians) are dumped</p>
</dd>
<dt><strong>dump_prop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True propagators are dumped</p>
</dd>
<dt><strong>dump_prop_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True propagator gradients are dumped</p>
</dd>
<dt><strong>dump_fwd_evo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True forward evolution operators are dumped</p>
</dd>
<dt><strong>dump_onwd_evo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True onward evolution operators are dumped</p>
</dd>
<dt><strong>dump_onto_evo</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True onto (or backward) evolution operators are dumped</p>
</dd>
<dt><strong>evo_dumps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="#qutip.control.dump.EvoCompDumpItem" title="qutip.control.dump.EvoCompDumpItem"><code class="xref py py-class docutils literal notranslate"><span class="pre">EvoCompDumpItem</span></code></a></span></dt>
<dd><p class="first last">A new dump item is appended at each recomputation of the evolution.
That is if any of the calculation objects are to be dumped.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dump.DynamicsDump.add_evo_comp_summary" title="qutip.control.dump.DynamicsDump.add_evo_comp_summary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_evo_comp_summary</span></code></a>([dump_item_idx])</td>
<td>add copy of current evo comp summary</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dump.DynamicsDump.add_evo_dump" title="qutip.control.dump.DynamicsDump.add_evo_dump"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_evo_dump</span></code></a>()</td>
<td>Add dump of current time evolution generating objects</td>
</tr>
<tr class="row-odd"><td><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_dump_dir</span></code>()</td>
<td>Checks dump directory exists, creates it if not</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#qutip.control.dump.DynamicsDump.writeout" title="qutip.control.dump.DynamicsDump.writeout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">writeout</span></code></a>([f])</td>
<td>write all the dump items and the summary out to file(s) Parameters ---------- f : filename or filehandle     If specified then all summary and object data will go in one file.</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>clear</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.dump.DynamicsDump.add_evo_comp_summary">
<code class="descname">add_evo_comp_summary</code><span class="sig-paren">(</span><em>dump_item_idx=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#DynamicsDump.add_evo_comp_summary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump.add_evo_comp_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>add copy of current evo comp summary</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dump.DynamicsDump.add_evo_dump">
<code class="descname">add_evo_dump</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#DynamicsDump.add_evo_dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump.add_evo_dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Add dump of current time evolution generating objects</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dump.DynamicsDump.dump_all">
<code class="descname">dump_all</code><a class="headerlink" href="#qutip.control.dump.DynamicsDump.dump_all" title="Permalink to this definition">¶</a></dt>
<dd><p>True if all of the calculation objects are to be dumped</p>
</dd></dl>

<dl class="attribute">
<dt id="qutip.control.dump.DynamicsDump.dump_any">
<code class="descname">dump_any</code><a class="headerlink" href="#qutip.control.dump.DynamicsDump.dump_any" title="Permalink to this definition">¶</a></dt>
<dd><p>True if any of the calculation objects are to be dumped</p>
</dd></dl>

<dl class="method">
<dt id="qutip.control.dump.DynamicsDump.writeout">
<code class="descname">writeout</code><span class="sig-paren">(</span><em>f=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#DynamicsDump.writeout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.DynamicsDump.writeout" title="Permalink to this definition">¶</a></dt>
<dd><p>write all the dump items and the summary out to file(s)
Parameters
----------
f : filename or filehandle</p>
<blockquote>
<div>If specified then all summary and object data will go in one file.
If None is specified then type specific files will be generated
in the dump_dir
If a filehandle is specified then it must be a byte mode file
as numpy.savetxt is used, and requires this.</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dump.DumpItem">
<em class="property">class </em><code class="descclassname">qutip.control.dump.</code><code class="descname">DumpItem</code><a class="reference internal" href="../_modules/qutip/control/dump.html#DumpItem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.DumpItem" title="Permalink to this definition">¶</a></dt>
<dd><p>An item in a dump list</p>
</dd></dl>

<dl class="class">
<dt id="qutip.control.dump.EvoCompDumpItem">
<em class="property">class </em><code class="descclassname">qutip.control.dump.</code><code class="descname">EvoCompDumpItem</code><span class="sig-paren">(</span><em>dump</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#EvoCompDumpItem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.EvoCompDumpItem" title="Permalink to this definition">¶</a></dt>
<dd><p>A copy of all objects generated to calculate one time evolution
Note the attributes are only set if the corresponding
<a class="reference internal" href="#qutip.control.dump.DynamicsDump" title="qutip.control.dump.DynamicsDump"><code class="xref py py-class docutils literal notranslate"><span class="pre">DynamicsDump</span></code></a> <a href="#id8"><span class="problematic" id="id9">dump_</span></a> attribute is set.</p>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#qutip.control.dump.EvoCompDumpItem.writeout" title="qutip.control.dump.EvoCompDumpItem.writeout"><code class="xref py py-obj docutils literal notranslate"><span class="pre">writeout</span></code></a>([f])</td>
<td>write all the objects out to files</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="qutip.control.dump.EvoCompDumpItem.writeout">
<code class="descname">writeout</code><span class="sig-paren">(</span><em>f=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/dump.html#EvoCompDumpItem.writeout"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.EvoCompDumpItem.writeout" title="Permalink to this definition">¶</a></dt>
<dd><p>write all the objects out to files</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>f</strong> <span class="classifier-delimiter">:</span> <span class="classifier">filename or filehandle</span></dt>
<dd><p class="first last">If specified then all object data will go in one file.
If None is specified then type specific files will be generated
in the dump_dir
If a filehandle is specified then it must be a byte mode file
as numpy.savetxt is used, and requires this.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="qutip.control.dump.DumpSummaryItem">
<em class="property">class </em><code class="descclassname">qutip.control.dump.</code><code class="descname">DumpSummaryItem</code><a class="reference internal" href="../_modules/qutip/control/dump.html#DumpSummaryItem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.dump.DumpSummaryItem" title="Permalink to this definition">¶</a></dt>
<dd><p>A summary of the most recent iteration
Abstract class only</p>
<p>Attributes:
idx : int</p>
<blockquote>
<div>Index in the summary list in which this is stored</div></blockquote>
<p class="rubric">Methods</p>
<table border="1" class="docutils">
<colgroup>
<col width="66%" />
<col width="34%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><strong>get_header_line</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td><strong>get_value_line</strong></td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td><strong>reset</strong></td>
<td>&#160;</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="apidoc.html" class="btn btn-neutral float-left" title="API documentation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>