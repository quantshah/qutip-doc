

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="None" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="None" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Functions &mdash; QuTiP: Quantum Toolbox in Python 4.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Change Log" href="../changelog.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.2
              </div>
            
          

            
            
              <div class="isa_warning">
                <i class="fa fa-warning"></i>
              Update QuTiP to the latest version and check out the latest documentation
              here.
            </div>
            

            
          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
          
          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../guide/guide.html">Users Guide</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="apidoc.html">API documentation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="classes.html">Classes</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#manipulation-and-creation-of-states-and-operators">Manipulation and Creation of States and Operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.states">Quantum States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.operators">Quantum Operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.random_objects">Random Operators and States</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.three_level_atom">Three-Level Atoms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superoperator">Superoperators and Liouvillians</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.superop_reps">Superoperator Representations</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#functions-acting-on-states-and-operators">Functions acting on states and operators</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.expect">Expectation Values</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tensor">Tensor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.partial_transpose">Partial Transpose</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.entropy">Entropy Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.metrics">Density Matrix Metrics</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.continuous_variables">Continous Variables</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#dynamics-and-time-evolution">Dynamics and Time-Evolution</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.sesolve">Schrödinger Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mesolve">Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.mcsolve">Monte Carlo Evolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.essolve">Exponential Series</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.bloch_redfield">Bloch-Redfield Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.floquet">Floquet States and Floquet-Markov Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.stochastic">Stochastic Schrödinger Equation and Master Equation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.correlation">Correlation Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.steadystate">Steady-state Solvers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.propagator">Propagators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.rhs_generate">Time-dependent problems</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.scattering">Scattering in Quantum Optical Systems</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#visualization">Visualization</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.wigner">Pseudoprobability Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.visualization">Graphs and Visualization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.tomography">Quantum Process Tomography</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#quantum-information-processing">Quantum Information Processing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.gates">Gates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.qubits">Qubits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.qip.algorithms.qft">Algorithms</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.nonmarkov.transfertensor">non-Markovian Solvers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#module-qutip.control.pulseoptim">Optimal control</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#grape">GRAPE</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crab">CRAB</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id41">References</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utilitiy-functions">Utilitiy Functions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.graph">Graph Theory Routines</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.utilities">Utility Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.fileio">File I/O Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.parallel">Parallelization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip.ipynbtools">IPython Notebook Tools</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-qutip">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../biblio.html">Bibliography</a></li>
</ul>

            

          

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="apidoc.html">API documentation</a> &raquo;</li>
        
      <li>Functions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/apidoc/functions.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="functions">
<span id="id1"></span><h1>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h1>
<div class="section" id="manipulation-and-creation-of-states-and-operators">
<h2>Manipulation and Creation of States and Operators<a class="headerlink" href="#manipulation-and-creation-of-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.states">
<span id="quantum-states"></span><h3>Quantum States<a class="headerlink" href="#module-qutip.states" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.states.basis">
<code class="descclassname">qutip.states.</code><code class="descname">basis</code><span class="sig-paren">(</span><em>N</em>, <em>n=0</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the vector representation of a Fock state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Integer corresponding to desired number state, defaults
to 0 if omitted.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the state.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Qobj representing the requested number state <code class="docutils literal notranslate"><span class="pre">|n&gt;</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>A subtle incompatibility with the quantum optics toolbox: In QuTiP:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p>but in the qotoolbox:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="n">ground</span> <span class="n">state</span>
</pre></div>
</div>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.bell_state">
<code class="descclassname">qutip.states.</code><code class="descname">bell_state</code><span class="sig-paren">(</span><em>state='00'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#bell_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.bell_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bell state:</p>
<blockquote>
<div><a href="#id2"><span class="problematic" id="id3">|</span></a>B00&gt; = 1 / sqrt(2)*[<a href="#id4"><span class="problematic" id="id5">|</span></a>0&gt;|0&gt;+|1&gt;|1&gt;]
<a href="#id6"><span class="problematic" id="id7">|</span></a>B01&gt; = 1 / sqrt(2)*[<a href="#id8"><span class="problematic" id="id9">|</span></a>0&gt;|0&gt;-<a href="#id10"><span class="problematic" id="id11">|</span></a>1&gt;|1&gt;]
<a href="#id12"><span class="problematic" id="id13">|</span></a>B10&gt; = 1 / sqrt(2)*[<a href="#id14"><span class="problematic" id="id15">|</span></a>0&gt;|1&gt;+|1&gt;|0&gt;]
<a href="#id16"><span class="problematic" id="id17">|</span></a>B11&gt; = 1 / sqrt(2)*[<a href="#id18"><span class="problematic" id="id19">|</span></a>0&gt;|1&gt;-<a href="#id20"><span class="problematic" id="id21">|</span></a>1&gt;|0&gt;]</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Bell_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Bell state</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.bra">
<code class="descclassname">qutip.states.</code><code class="descname">bra</code><span class="sig-paren">(</span><em>seq</em>, <em>dim=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#bra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.bra" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle bra state for a list or string,
where each element stands for state of the respective particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str / list of ints or characters</span></dt>
<dd><p class="first last">Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string &quot;1101&quot;).
For qubits it is also possible to use the following conventions:
- 'g'/'e' (ground and excited state)
- 'u'/'d' (spin up and down)
- 'H'/'V' (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default: 2) / list of ints</span></dt>
<dd><p class="first last">Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>bra</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1], [2, 2]], shape = [1, 4], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  1.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1, 1], [2, 2, 2]], shape = [1, 8], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.  0.  0.  0.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[1, 1], [3, 3]], shape = [1, 9], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  1.  0.  0.  0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bra</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[1, 1], [5, 2]], shape = [1, 10], type = bra</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.  0.  0.  0.  0.  0.  1.  0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent">
<code class="descclassname">qutip.states.</code><code class="descname">coherent</code><span class="sig-paren">(</span><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method='operator'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a coherent state with eigenvalue alpha.</p>
<p>Constructed using displacement operator on vacuum state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">Eigenvalue of coherent state.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the state. Using a non-zero offset will make the
default method 'analytic'.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'operator', 'analytic'}</span></dt>
<dd><p class="first last">Method for generating coherent state.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Qobj quantum object for coherent state</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method 'operator' (default) or 'analytic'. With the
'operator' method, the coherent state is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size 'N'. This method guarantees that the
resulting state is normalized. With 'analytic' method the coherent state
is generated using the analytical formula for the coherent state
coefficients in the Fock basis. This method does not guarantee that the
state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [1]], shape = [5, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[  9.69233235e-01+0.j        ]</span>
<span class="go"> [  0.00000000e+00+0.24230831j]</span>
<span class="go"> [ -4.28344935e-02+0.j        ]</span>
<span class="go"> [  0.00000000e+00-0.00618204j]</span>
<span class="go"> [  7.80904967e-04+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.coherent_dm">
<code class="descclassname">qutip.states.</code><code class="descname">coherent_dm</code><span class="sig-paren">(</span><em>N</em>, <em>alpha</em>, <em>offset=0</em>, <em>method='operator'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#coherent_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.coherent_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a coherent state.</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.coherent" title="qutip.states.coherent"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.coherent()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">Eigenvalue for coherent state.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the state.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'operator', 'analytic'}</span></dt>
<dd><p class="first last">Method for generating coherent density matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix representation of coherent state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Select method 'operator' (default) or 'analytic'. With the
'operator' method, the coherent density matrix is generated by displacing
the vacuum state using the displacement operator defined in the
truncated Hilbert space of size 'N'. This method guarantees that the
resulting density matrix is normalized. With 'analytic' method the coherent
density matrix is generated using the analytical formula for the coherent
state coefficients in the Fock basis. This method does not guarantee that
the state is normalized if truncated to a small number of Fock states,
but would in that case give more accurate coefficients.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mf">0.25</span><span class="n">j</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.93941695+0.j          0.00000000-0.23480733j -0.04216943+0.j        ]</span>
<span class="go"> [ 0.00000000+0.23480733j  0.05869011+0.j          0.00000000-0.01054025j]</span>
<span class="go"> [-0.04216943+0.j          0.00000000+0.01054025j  0.00189294+0.j        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_state_dictionaries">
<code class="descclassname">qutip.states.</code><code class="descname">enr_state_dictionaries</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_state_dictionaries"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_state_dictionaries" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of states, and lookup-dictionaries for translating
a state tuple to a state index, and vice versa, for a system with a given
number of components and maximum number of excitations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims: list</strong></dt>
<dd><p class="first last">A list with the number of states in each sub-system.</p>
</dd>
<dt><strong>excitations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum numbers of dimension</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nstates, state2idx, idx2state: integer, dict, dict</strong></dt>
<dd><p class="first last">The number of states <cite>nstates</cite>, a dictionary for looking up state
indices from a state tuple, and a dictionary for looking up state
state tuples from state indices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_thermal_dm">
<code class="descclassname">qutip.states.</code><code class="descname">enr_thermal_dm</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the density operator for a thermal state in the excitation-number-
restricted state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments.
See the documentation for enr_fock for a more detailed description of
these arguments. The temperature of each mode in dims is specified by
the average number of excitatons <cite>n</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The average number of exciations in the thermal state. <cite>n</cite> can be
a float (which then applies to each mode), or a list/array of the same
length as dims, in which each element corresponds specifies the
temperature of the corresponding mode.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Thermal state density matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.enr_fock">
<code class="descclassname">qutip.states.</code><code class="descname">enr_fock</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#enr_fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.enr_fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the Fock state representation in a excitation-number restricted
state space. The <cite>dims</cite> argument is a list of integers that define the
number of quantums states of each component of a composite quantum system,
and the <cite>excitations</cite> specifies the maximum number of excitations for
the basis states that are to be included in the state space. The <cite>state</cite>
argument is a tuple of integers that specifies the state (in the number
basis representation) for which to generate the Fock state representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of integers</span></dt>
<dd><p class="first last">The state in the number basis representation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A Qobj instance that represent a Fock state in the exication-number-
restricted state space defined by <cite>dims</cite> and <cite>exciations</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock">
<code class="descclassname">qutip.states.</code><code class="descname">fock</code><span class="sig-paren">(</span><em>N</em>, <em>n=0</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#fock"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock" title="Permalink to this definition">¶</a></dt>
<dd><p>Bosonic Fock (number) state.</p>
<p>Same as <a class="reference internal" href="#qutip.states.basis" title="qutip.states.basis"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.basis()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of states in the Hilbert space.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">int</span></code> for desired number state, defaults to 0 if omitted.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Requested number state :math:`left|nright&gt;`.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 0.+0.j]</span>
<span class="go"> [ 1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.fock_dm">
<code class="descclassname">qutip.states.</code><code class="descname">fock_dm</code><span class="sig-paren">(</span><em>N</em>, <em>n=0</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#fock_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.fock_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix representation of a Fock state</p>
<p>Constructed via outer product of <a class="reference internal" href="#qutip.states.fock" title="qutip.states.fock"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.states.fock()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">int</span></code> for desired number state, defaults to 0 if omitted.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix representation of Fock state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ghz_state">
<code class="descclassname">qutip.states.</code><code class="descname">ghz_state</code><span class="sig-paren">(</span><em>N=3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ghz_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ghz_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the N-qubit GHZ-state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default=3)</span></dt>
<dd><p class="first last">Number of qubits in state</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>G</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">N-qubit GHZ-state</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.maximally_mixed_dm">
<code class="descclassname">qutip.states.</code><code class="descname">maximally_mixed_dm</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#maximally_mixed_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.maximally_mixed_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the maximally mixed density matrix for a Hilbert space of
dimension N.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of basis states in Hilbert space.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Thermal state density matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket">
<code class="descclassname">qutip.states.</code><code class="descname">ket</code><span class="sig-paren">(</span><em>seq</em>, <em>dim=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces a multiparticle ket state for a list or string,
where each element stands for state of the respective particle.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>seq</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str / list of ints or characters</span></dt>
<dd><p class="first last">Each element defines state of the respective particle.
(e.g. [1,1,0,1] or a string &quot;1101&quot;).
For qubits it is also possible to use the following conventions:
- 'g'/'e' (ground and excited state)
- 'u'/'d' (spin up and down)
- 'H'/'V' (horizontal and vertical polarization)
Note: for dimension &gt; 9 you need to use a list.</p>
</dd>
<dt><strong>dim</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default: 2) / list of ints</span></dt>
<dd><p class="first last">Space dimension for each particle:
int if there are the same, list if they are different.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;10&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [1, 1]], shape = [4, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;Hue&quot;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;12&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3, 3], [1, 1]], shape = [9, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span><span class="p">(</span><span class="s2">&quot;31&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[5, 2], [1, 1]], shape = [10, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.ket2dm">
<code class="descclassname">qutip.states.</code><code class="descname">ket2dm</code><span class="sig-paren">(</span><em>Q</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#ket2dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.ket2dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes input ket or bra vector and returns density matrix
formed by outer product.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Ket or bra type quantum object.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix formed by outer product of <cite>Q</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">basis</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2dm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.phase_basis">
<code class="descclassname">qutip.states.</code><code class="descname">phase_basis</code><span class="sig-paren">(</span><em>N</em>, <em>m</em>, <em>phi0=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#phase_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.phase_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis vector for the mth phase of the Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of basis vectors in Hilbert space.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Integer corresponding to the mth discrete phase phi_m=phi0+2*pi*m/N</p>
</dd>
<dt><strong>phi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (default=0)</span></dt>
<dd><p class="first last">Reference phase angle.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Ket vector for mth Pegg-Barnett phase operator basis state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett basis states form a complete set over the truncated
Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.states.projection">
<code class="descclassname">qutip.states.</code><code class="descname">projection</code><span class="sig-paren">(</span><em>N</em>, <em>n</em>, <em>m</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#projection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.projection" title="Permalink to this definition">¶</a></dt>
<dd><p>The projection operator that projects state <span class="math notranslate nohighlight">\(|m&gt;\)</span> on state <span class="math notranslate nohighlight">\(|n&gt;\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n, m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The number states in the projection.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the projector.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Requested projection operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.qutrit_basis">
<code class="descclassname">qutip.states.</code><code class="descname">qutrit_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#qutrit_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.qutrit_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qstates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of qutrit basis vectors</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.singlet_state">
<code class="descclassname">qutip.states.</code><code class="descname">singlet_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#singlet_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.singlet_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the two particle singlet-state:</p>
<blockquote>
<div><a href="#id22"><span class="problematic" id="id23">|</span></a>S&gt;=1/sqrt(2)*[<a href="#id24"><span class="problematic" id="id25">|</span></a>0&gt;|1&gt;-<a href="#id26"><span class="problematic" id="id27">|</span></a>1&gt;|0&gt;]</div></blockquote>
<p>that is identical to the fourth bell state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Bell_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last"><a href="#id28"><span class="problematic" id="id29">|</span></a>B11&gt; Bell state</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.spin_state">
<code class="descclassname">qutip.states.</code><code class="descname">spin_state</code><span class="sig-paren">(</span><em>j</em>, <em>m</em>, <em>type='ket'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#spin_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.spin_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the spin state <a href="#id30"><span class="problematic" id="id31">|</span></a>j, m&gt;, i.e.  the eigenstate
of the spin-j Sz operator with eigenvalue m.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The spin of the state ().</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Eigenvalue of the spin-j Sz operator.</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'ket', 'bra', 'dm'}</span></dt>
<dd><p class="first last">Type of state to generate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Qobj quantum object for spin state</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.spin_coherent">
<code class="descclassname">qutip.states.</code><code class="descname">spin_coherent</code><span class="sig-paren">(</span><em>j</em>, <em>theta</em>, <em>phi</em>, <em>type='ket'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#spin_coherent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.spin_coherent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the coherent spin state <a href="#id32"><span class="problematic" id="id33">|</span></a>theta, phi&gt;.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The spin of the state.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle from z axis.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle from x axis.</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'ket', 'bra', 'dm'}</span></dt>
<dd><p class="first last">Type of state to generate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Qobj quantum object for spin coherent state</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_enumerate">
<code class="descclassname">qutip.states.</code><code class="descname">state_number_enumerate</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations=None</em>, <em>state=None</em>, <em>idx=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_enumerate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_enumerate" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterator that enumerate all the state number arrays (quantum numbers on
the form [n1, n2, n3, ...]) for a system with dimensions given by dims.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_number_enumerate</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">[ 0  0 ]</span>
<span class="go">[ 0  1 ]</span>
<span class="go">[ 1  0 ]</span>
<span class="go">[ 1  1 ]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or array</span></dt>
<dd><p class="first last">The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Current state in the iteration. Used internally.</p>
</dd>
<dt><strong>excitations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer (None)</span></dt>
<dd><p class="first last">Restrict state space to states with excitation numbers below or
equal to this value.</p>
</dd>
<dt><strong>idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Current index in the iteration. Used internally.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state_number</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Successive state number arrays that can be used in loops and other
iterations, using standard state enumeration <em>by definition</em>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_index">
<code class="descclassname">qutip.states.</code><code class="descname">state_number_index</code><span class="sig-paren">(</span><em>dims</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_index"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of a quantum state corresponding to state,
given a system with dimensions given by dims.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_index</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="go">6</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or array</span></dt>
<dd><p class="first last">The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">State number array.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>idx</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The index of the state given by <cite>state</cite> in standard enumeration
ordering.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_index_number">
<code class="descclassname">qutip.states.</code><code class="descname">state_index_number</code><span class="sig-paren">(</span><em>dims</em>, <em>index</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_index_number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_index_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a quantum number representation given a state index, for a system
of composite structure defined by dims.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_index_number</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">6</span><span class="p">)</span>
<span class="go">[1, 1, 0]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or array</span></dt>
<dd><p class="first last">The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>index</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the state in standard enumeration ordering.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The state number array corresponding to index <cite>index</cite> in standard
enumeration ordering.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.state_number_qobj">
<code class="descclassname">qutip.states.</code><code class="descname">state_number_qobj</code><span class="sig-paren">(</span><em>dims</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#state_number_qobj"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.state_number_qobj" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a Qobj representation of a quantum state specified by the state
array <cite>state</cite>.</p>
<p>Example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_number_qobj</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = [8, 1], type = ket</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 1.]</span>
<span class="go"> [ 0.]</span>
<span class="go"> [ 0.]]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or array</span></dt>
<dd><p class="first last">The quantum state dimensions array, as it would appear in a Qobj.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">State number array.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj.qobj</span></code></span></dt>
<dd><p class="first last">The state as a <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj.qobj</span></code> instance.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.states.thermal_dm">
<code class="descclassname">qutip.states.</code><code class="descname">thermal_dm</code><span class="sig-paren">(</span><em>N</em>, <em>n</em>, <em>method='operator'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#thermal_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.thermal_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Density matrix for a thermal state of n particles</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Expectation value for number of particles in thermal state.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'operator', 'analytic'}</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">string</span></code> that sets the method used to generate the
thermal state probabilities</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Thermal state density matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The 'operator' method (default) generates
the thermal state using the truncated number operator <code class="docutils literal notranslate"><span class="pre">num(N)</span></code>. This
is the method that should be used in computations. The
'analytic' method uses the analytic coefficients derived in
an infinite Hilbert space. The analytic form is not necessarily normalized,
if truncated too aggressively.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.51612903  0.          0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.25806452  0.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.12903226  0.          0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.06451613  0.        ]</span>
<span class="go"> [ 0.          0.          0.          0.          0.03225806]]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">thermal_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;analytic&#39;</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[5], [5]], shape = [5, 5], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.5      0.       0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.25     0.       0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.125    0.       0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.0625   0.     ]</span>
<span class="go"> [ 0.       0.       0.       0.       0.03125]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.states.zero_ket">
<code class="descclassname">qutip.states.</code><code class="descname">zero_ket</code><span class="sig-paren">(</span><em>N</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/states.html#zero_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.states.zero_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the zero ket vector with shape Nx1 and
dimensions <cite>dims</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Hilbert space dimensionality</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Optional dimensions if ket corresponds to
a composite Hilbert space.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>zero_ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Zero ket on given Hilbert space.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.operators">
<span id="quantum-operators"></span><h3>Quantum Operators<a class="headerlink" href="#module-qutip.operators" title="Permalink to this headline">¶</a></h3>
<p>This module contains functions for generating Qobj representation of a variety
of commonly occuring quantum operators.</p>
<dl class="function">
<dt id="qutip.operators.charge">
<code class="descclassname">qutip.operators.</code><code class="descname">charge</code><span class="sig-paren">(</span><em>Nmax</em>, <em>Nmin=None</em>, <em>frac=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#charge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.charge" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the diagonal charge operator over charge states
from Nmin to Nmax.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>Nmax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Maximum charge state to consider.</p>
</dd>
<dt><strong>Nmin</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default = -Nmax)</span></dt>
<dd><p class="first last">Lowest charge state to consider.</p>
</dd>
<dt><strong>frac</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float (default = 1)</span></dt>
<dd><p class="first last">Specify fractional charge if needed.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>C</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Charge operator over [Nmin,Nmax].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.commutator">
<code class="descclassname">qutip.operators.</code><code class="descname">commutator</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>kind='normal'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#commutator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.commutator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the commutator of kind <cite>kind</cite> (normal, anti) of the
two operators A and B.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.create">
<code class="descclassname">qutip.operators.</code><code class="descname">create</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation (raising) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of Hilbert space.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Qobj for raising operator.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 1.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  1.41421356+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.73205081+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.destroy">
<code class="descclassname">qutip.operators.</code><code class="descname">destroy</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Destruction (lowering) operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of Hilbert space.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Qobj for lowering operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">destroy</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.00000000+0.j  1.00000000+0.j  0.00000000+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  1.41421356+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  1.73205081+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.00000000+0.j  0.00000000+0.j  0.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.displace">
<code class="descclassname">qutip.operators.</code><code class="descname">displace</code><span class="sig-paren">(</span><em>N</em>, <em>alpha</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#displace"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.displace" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode displacement operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of Hilbert space.</p>
</dd>
<dt><strong>alpha</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">Displacement amplitude.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Displacement operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">displace</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.96923323+0.j -0.24230859+0.j  0.04282883+0.j -0.00626025+0.j]</span>
<span class="go"> [ 0.24230859+0.j  0.90866411+0.j -0.33183303+0.j  0.07418172+0.j]</span>
<span class="go"> [ 0.04282883+0.j  0.33183303+0.j  0.84809499+0.j -0.41083747+0.j]</span>
<span class="go"> [ 0.00626025+0.j  0.07418172+0.j  0.41083747+0.j  0.90866411+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_destroy">
<code class="descclassname">qutip.operators.</code><code class="descname">enr_destroy</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#enr_destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate annilation operators for modes in a excitation-number-restricted
state space. For example, consider a system consisting of 4 modes, each
with 5 states. The total hilbert space size is 5**4 = 625. If we are
only interested in states that contain up to 2 excitations, we only need
to include states such as</p>
<blockquote>
<div>(0, 0, 0, 0)
(0, 0, 0, 1)
(0, 0, 0, 2)
(0, 0, 1, 0)
(0, 0, 1, 1)
(0, 0, 2, 0)
...</div></blockquote>
<p>This function creates annihilation operators for the 4 modes that act
within this state space:</p>
<blockquote>
<div>a1, a2, a3, a4 = enr_destroy([5, 5, 5, 5], excitations=2)</div></blockquote>
<p>From this point onwards, the annihiltion operators a1, ..., a4 can be
used to setup a Hamiltonian, collapse operators and expectation-value
operators, etc., following the usual pattern.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of excitations that are to be included in the
state space.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of qobj</span></dt>
<dd><p class="first last">A list of annihilation operators for each mode in the composite
quantum system described by dims.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.enr_identity">
<code class="descclassname">qutip.operators.</code><code class="descname">enr_identity</code><span class="sig-paren">(</span><em>dims</em>, <em>excitations</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#enr_identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.enr_identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the identity operator for the excitation-number restricted
state space defined by the <cite>dims</cite> and <cite>exciations</cite> arguments. See the
docstring for enr_fock for a more detailed description of these arguments.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of the dimensions of each subsystem of a composite quantum
system.</p>
</dd>
<dt><strong>excitations</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The maximum number of excitations that are to be included in the
state space.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of integers</span></dt>
<dd><p class="first last">The state in the number basis representation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A Qobj instance that represent the identity operator in the
exication-number-restricted state space defined by <cite>dims</cite> and
<cite>exciations</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.jmat">
<code class="descclassname">qutip.operators.</code><code class="descname">jmat</code><span class="sig-paren">(</span><em>j</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#jmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.jmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Higher-order spin operators:</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spin of operator</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Which operator to return 'x','y','z','+','-'.
If no args given, then output is ['x','y','z']</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>jmat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj / ndarray</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">qobj</span></code> for requested spin operator(s).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If no 'args' input, then returns array of ['x','y','z'] operators.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jmat</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">[ Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          0.70710678  0.        ]</span>
<span class="go"> [ 0.70710678  0.          0.70710678]</span>
<span class="go"> [ 0.          0.70710678  0.        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j          0.-0.70710678j  0.+0.j        ]</span>
<span class="go"> [ 0.+0.70710678j  0.+0.j          0.-0.70710678j]</span>
<span class="go"> [ 0.+0.j          0.+0.70710678j  0.+0.j        ]]</span>
<span class="go"> Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  0.  0.]</span>
<span class="go"> [ 0.  0. -1.]]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.num">
<code class="descclassname">qutip.operators.</code><code class="descname">num</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.num" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object for number operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The dimension of the Hilbert space.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper: qobj</strong></dt>
<dd><p class="first last">Qobj for number operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 0 0]</span>
<span class="go"> [0 0 2 0]</span>
<span class="go"> [0 0 0 3]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qeye">
<code class="descclassname">qutip.operators.</code><code class="descname">qeye</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qeye"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qeye" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of ints</span></dt>
<dd><p class="first last">Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal notranslate"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Identity operator Qobj.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qeye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[3], [3]], shape = [3, 3], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.  0.]</span>
<span class="go"> [ 0.  1.  0.]</span>
<span class="go"> [ 0.  0.  1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.identity">
<code class="descclassname">qutip.operators.</code><code class="descname">identity</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Identity operator. Alternative name to <a class="reference internal" href="#qutip.operators.qeye" title="qutip.operators.qeye"><code class="xref py py-func docutils literal notranslate"><span class="pre">qeye()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of ints</span></dt>
<dd><p class="first last">Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal notranslate"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Identity operator Qobj.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.momentum">
<code class="descclassname">qutip.operators.</code><code class="descname">momentum</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#momentum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.momentum" title="Permalink to this definition">¶</a></dt>
<dd><p>Momentum operator p=-1j/sqrt(2)*(a-a.dag())</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Momentum operator as Qobj.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.phase">
<code class="descclassname">qutip.operators.</code><code class="descname">phase</code><span class="sig-paren">(</span><em>N</em>, <em>phi0=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#phase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Pegg-Barnett phase operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>phi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Reference phase.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Phase operator with respect to reference phase.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The Pegg-Barnett phase operator is Hermitian on a truncated Hilbert space.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.position">
<code class="descclassname">qutip.operators.</code><code class="descname">position</code><span class="sig-paren">(</span><em>N</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Position operator x=1/sqrt(2)*(a+a.dag())</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of Fock states in Hilbert space.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Position operator as Qobj.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qdiags">
<code class="descclassname">qutip.operators.</code><code class="descname">qdiags</code><span class="sig-paren">(</span><em>diagonals</em>, <em>offsets</em>, <em>dims=None</em>, <em>shape=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qdiags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qdiags" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs an operator from an array of diagonals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>diagonals</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of array_like</span></dt>
<dd><p class="first last">Array of elements to place along the selected diagonals.</p>
</dd>
<dt><strong>offsets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of ints</span></dt>
<dd><dl class="first last docutils">
<dt>Sequence for diagonals to be set:</dt>
<dd><ul class="first last simple">
<li>k=0 main diagonal</li>
<li>k&gt;0 kth upper diagonal</li>
<li>k&lt;0 kth lower diagonal</li>
</ul>
</dd>
</dl>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, optional</span></dt>
<dd><p class="first last">Dimensions for operator</p>
</dd>
<dt><strong>shape</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list, tuple, optional</span></dt>
<dd><p class="first last">Shape of operator.  If omitted, a square operator large enough
to contain the diagonals is generated.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.diags</span></code></p>
</div>
<p class="rubric">Notes</p>
<p>This function requires SciPy 0.11+.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">qdiags</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isherm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.          1.          0.          0.        ]</span>
<span class="go"> [ 0.          0.          1.41421356  0.        ]</span>
<span class="go"> [ 0.          0.          0.          1.73205081]</span>
<span class="go"> [ 0.          0.          0.          0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qutrit_ops">
<code class="descclassname">qutip.operators.</code><code class="descname">qutrit_ops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qutrit_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qutrit_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>opers: array</strong></dt>
<dd><p class="first last"><cite>array</cite> of qutrit operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.qzero">
<code class="descclassname">qutip.operators.</code><code class="descname">qzero</code><span class="sig-paren">(</span><em>N</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#qzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.qzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Zero operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of ints</span></dt>
<dd><p class="first last">Dimension of Hilbert space. If provided as a list of ints,
then the dimension is the product over this list, but the
<code class="docutils literal notranslate"><span class="pre">dims</span></code> property of the new Qobj are set to this list.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qzero</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Zero operator Qobj.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmam">
<code class="descclassname">qutip.operators.</code><code class="descname">sigmam</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Annihilation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  0.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmap">
<code class="descclassname">qutip.operators.</code><code class="descname">sigmap</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creation operator for Pauli spins.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmam</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 0.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmax">
<code class="descclassname">qutip.operators.</code><code class="descname">sigmax</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-x operator</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmax</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.  1.]</span>
<span class="go"> [ 1.  0.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmay">
<code class="descclassname">qutip.operators.</code><code class="descname">sigmay</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-y operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmay</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.-1.j]</span>
<span class="go"> [ 0.+1.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.sigmaz">
<code class="descclassname">qutip.operators.</code><code class="descname">sigmaz</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#sigmaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Pauli spin 1/2 sigma-z operator.</p>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.  0.]</span>
<span class="go"> [ 0. -1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jx">
<code class="descclassname">qutip.operators.</code><code class="descname">spin_Jx</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jx" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j x operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spin of operator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jy">
<code class="descclassname">qutip.operators.</code><code class="descname">spin_Jy</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jy" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j y operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spin of operator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jz">
<code class="descclassname">qutip.operators.</code><code class="descname">spin_Jz</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jz" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j z operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spin of operator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jm">
<code class="descclassname">qutip.operators.</code><code class="descname">spin_Jm</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jm" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j annihilation operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spin of operator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.spin_Jp">
<code class="descclassname">qutip.operators.</code><code class="descname">spin_Jp</code><span class="sig-paren">(</span><em>j</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#spin_Jp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.spin_Jp" title="Permalink to this definition">¶</a></dt>
<dd><p>Spin-j creation operator</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Spin of operator</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">qobj</span></code> representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeeze">
<code class="descclassname">qutip.operators.</code><code class="descname">squeeze</code><span class="sig-paren">(</span><em>N</em>, <em>z</em>, <em>offset=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-mode Squeezing operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of hilbert space.</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">Squeezing parameter.</p>
</dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0)</span></dt>
<dd><p class="first last">The lowest number state that is included in the finite number state
representation of the operator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">Squeezing operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[4], [4]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.98441565+0.j  0.00000000+0.j  0.17585742+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j  0.95349007+0.j  0.00000000+0.j  0.30142443+0.j]</span>
<span class="go"> [-0.17585742+0.j  0.00000000+0.j  0.98441565+0.j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j -0.30142443+0.j  0.00000000+0.j  0.95349007+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.squeezing">
<code class="descclassname">qutip.operators.</code><code class="descname">squeezing</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em>, <em>z</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#squeezing"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.squeezing" title="Permalink to this definition">¶</a></dt>
<dd><p>Generalized squeezing operator.</p>
<div class="math notranslate nohighlight">
\[S(z) = \exp\left(\frac{1}{2}\left(z^*a_1a_2
- za_1^\dagger a_2^\dagger\right)\right)\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a1</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">Operator 1.</p>
</dd>
<dt><strong>a2</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">Operator 2.</p>
</dd>
<dt><strong>z</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex</span></dt>
<dd><p class="first last">Squeezing parameter.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">Squeezing operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.operators.tunneling">
<code class="descclassname">qutip.operators.</code><code class="descname">tunneling</code><span class="sig-paren">(</span><em>N</em>, <em>m=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/operators.html#tunneling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.operators.tunneling" title="Permalink to this definition">¶</a></dt>
<dd><p>Tunneling operator with elements of the form
<span class="math notranslate nohighlight">\(\sum |N&gt;&lt;N+m| + |N+m&gt;&lt;N|\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of basis states in Hilbert space.</p>
</dd>
<dt><strong>m</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default = 1)</span></dt>
<dd><p class="first last">Number of excitations in tunneling event.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Tunneling operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<div class="versionadded">
<p><span class="versionmodified">New in version 3.2.</span></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.random_objects">
<span id="random-operators-and-states"></span><span id="functions-rand"></span><h3>Random Operators and States<a class="headerlink" href="#module-qutip.random_objects" title="Permalink to this headline">¶</a></h3>
<p>This module is a collection of random state and operator generators.
The sparsity of the ouput Qobj's is controlled by varing the
<cite>density</cite> parameter.</p>
<dl class="function">
<dt id="qutip.random_objects.rand_dm">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_dm</code><span class="sig-paren">(</span><em>N</em>, <em>density=0.75</em>, <em>pure=False</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, ndarray, list</span></dt>
<dd><p class="first last">If int, then shape of output operator. If list/ndarray then eigenvalues
of generated density matrix.</p>
</dd>
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Density between [0,1] of output density matrix.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">NxN density matrix quantum operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>For small density matrices., choosing a low density will result in an error
as no diagonal elements will be generated such that <span class="math notranslate nohighlight">\(Tr(\rho)=1\)</span>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_dm_ginibre">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_dm_ginibre</code><span class="sig-paren">(</span><em>N=2</em>, <em>rank=None</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm_ginibre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_ginibre" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Ginibre random density operator of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code> and rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id34">[BCSZ08]</a>. If <code class="docutils literal notranslate"><span class="pre">rank</span></code> is <cite>None</cite>, a full-rank
(Hilbert-Schmidt ensemble) random density operator will be
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of the density operator to be returned.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>rank</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">Rank of the sampled density operator. If None, a full-rank
density operator is generated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">An N × N density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_dm_hs">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_dm_hs</code><span class="sig-paren">(</span><em>N=2</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_dm_hs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_dm_hs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Hilbert-Schmidt random density operator of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code> and rank <code class="docutils literal notranslate"><span class="pre">rank</span></code> by using the algorithm of
<a class="reference internal" href="../biblio.html#bcsz08" id="id35">[BCSZ08]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of the density operator to be returned.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A dim × dim density operator sampled from the Ginibre
or Hilbert-Schmidt distribution.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_herm">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_herm</code><span class="sig-paren">(</span><em>N</em>, <em>density=0.75</em>, <em>dims=None</em>, <em>pos_def=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_herm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_herm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse Hermitian quantum object.</p>
<p>If 'N' is an integer, uses <span class="math notranslate nohighlight">\(H=0.5*(X+X^{+})\)</span> where <span class="math notranslate nohighlight">\(X\)</span> is
a randomly generated quantum operator with a given <cite>density</cite>. Else uses
complex Jacobi rotations when 'N' is given by an array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, list/ndarray</span></dt>
<dd><p class="first last">If int, then shape of output operator. If list/ndarray then eigenvalues
of generated operator.</p>
</dd>
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Density between [0,1] of output Hermitian operator.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
<dt><strong>pos_def</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (default=False)</span></dt>
<dd><p class="first last">Return a positive semi-definite matrix (by diagonal dominance).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">NxN Hermitian quantum operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_ket</code><span class="sig-paren">(</span><em>N</em>, <em>density=1</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_ket"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random Nx1 sparse ket vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of rows for output quantum operator.</p>
</dd>
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Density between [0,1] of output ket state.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Left-dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N]].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Nx1 ket state quantum operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_ket_haar">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_ket_haar</code><span class="sig-paren">(</span><em>N=2</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_ket_haar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_ket_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random pure state of dimension <code class="docutils literal notranslate"><span class="pre">dim</span></code> by
applying a Haar random unitary to a fixed pure state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of the state vector to be returned.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of ints, or None</span></dt>
<dd><p class="first last">Left-dimensions of the resultant quantum object.
If None, [N] is used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>psi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A random state vector drawn from the Haar measure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_unitary</code><span class="sig-paren">(</span><em>N</em>, <em>density=0.75</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a random NxN sparse unitary quantum object.</p>
<p>Uses <span class="math notranslate nohighlight">\(\exp(-iH)\)</span> where H is a randomly generated
Hermitian operator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Shape of output quantum operator.</p>
</dd>
<dt><strong>density</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Density between [0,1] of output Unitary operator.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">NxN Unitary quantum operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_unitary_haar">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_unitary_haar</code><span class="sig-paren">(</span><em>N=2</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_unitary_haar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_unitary_haar" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Haar random unitary matrix of dimension
<code class="docutils literal notranslate"><span class="pre">dim</span></code>, using the algorithm of <a class="reference internal" href="../biblio.html#mez07" id="id36">[Mez07]</a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Dimension of the unitary to be returned.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of lists of int, or None</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[N],[N]].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Unitary of dims <code class="docutils literal notranslate"><span class="pre">[[dim],</span> <span class="pre">[dim]]</span></code> drawn from the Haar
measure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_super">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_super</code><span class="sig-paren">(</span><em>N=5</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a randomly drawn superoperator acting on operators acting on
N dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Square root of the dimension of the superoperator to be returned.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.random_objects.rand_super_bcsz">
<code class="descclassname">qutip.random_objects.</code><code class="descname">rand_super_bcsz</code><span class="sig-paren">(</span><em>N=2</em>, <em>enforce_tp=True</em>, <em>rank=None</em>, <em>dims=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/random_objects.html#rand_super_bcsz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.random_objects.rand_super_bcsz" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random superoperator drawn from the Bruzda
et al ensemble for CPTP maps <a class="reference internal" href="../biblio.html#bcsz08" id="id37">[BCSZ08]</a>. Note that due to
finite numerical precision, for ranks less than full-rank,
zero eigenvalues may become slightly negative, such that the
returned operator is not actually completely positive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Square root of the dimension of the superoperator to be returned.</p>
</dd>
<dt><strong>enforce_tp</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, the trace-preserving condition of <a class="reference internal" href="../biblio.html#bcsz08" id="id38">[BCSZ08]</a> is enforced;
otherwise only complete positivity is enforced.</p>
</dd>
<dt><strong>rank</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd><p class="first last">Rank of the sampled superoperator. If None, a full-rank
superoperator is generated.</p>
</dd>
<dt><strong>dims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Dimensions of quantum object.  Used for specifying
tensor structure. Default is dims=[[[N],[N]], [[N],[N]]].</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A superoperator acting on vectorized dim × dim density operators,
sampled from the BCSZ distribution.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.three_level_atom">
<span id="three-level-atoms"></span><h3>Three-Level Atoms<a class="headerlink" href="#module-qutip.three_level_atom" title="Permalink to this headline">¶</a></h3>
<p>This module provides functions that are useful for simulating the
three level atom with QuTiP.  A three level atom (qutrit) has three states,
which are linked by dipole transitions so that 1 &lt;-&gt; 2 &lt;-&gt; 3.
Depending on there relative energies they are in the ladder, lambda or
vee configuration. The structure of the relevant operators is the same
for any of the three configurations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Ladder</span><span class="p">:</span>          <span class="n">Lambda</span><span class="p">:</span>                 <span class="n">Vee</span><span class="p">:</span>
                            <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>
  <span class="o">-------|</span><span class="n">three</span><span class="o">&gt;</span>           <span class="o">-------</span>                      <span class="o">-------</span>
     <span class="o">|</span>                       <span class="o">/</span> \             <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>         <span class="o">/</span>
     <span class="o">|</span>                      <span class="o">/</span>   \           <span class="o">-------</span>       <span class="o">/</span>
     <span class="o">|</span>                     <span class="o">/</span>     \             \         <span class="o">/</span>
  <span class="o">-------|</span><span class="n">two</span><span class="o">&gt;</span>            <span class="o">/</span>       \             \       <span class="o">/</span>
     <span class="o">|</span>                   <span class="o">/</span>         \             \     <span class="o">/</span>
     <span class="o">|</span>                  <span class="o">/</span>           \             \   <span class="o">/</span>
     <span class="o">|</span>                 <span class="o">/</span>        <span class="o">--------</span>           \ <span class="o">/</span>
  <span class="o">-------|</span><span class="n">one</span><span class="o">&gt;</span>      <span class="o">-------</span>      <span class="o">|</span><span class="n">three</span><span class="o">&gt;</span>         <span class="o">-------</span>
                     <span class="o">|</span><span class="n">one</span><span class="o">&gt;</span>                       <span class="o">|</span><span class="n">two</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="section" id="references">
<h4>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h4>
<p>The naming of qutip operators follows the convention in <a class="reference internal" href="#r0be8dcf25d86-1" id="id39">[R0be8dcf25d86-1]</a> .</p>
<table class="docutils citation" frame="void" id="r0be8dcf25d86-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id39">[R0be8dcf25d86-1]</a></td><td>Shore, B. W., &quot;The Theory of Coherent Atomic Excitation&quot;,
Wiley, 1990.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="notes">
<h4>Notes<a class="headerlink" href="#notes" title="Permalink to this headline">¶</a></h4>
<p>Contributed by Markus Baden, Oct. 07, 2011</p>
<dl class="function">
<dt id="qutip.three_level_atom.three_level_basis">
<code class="descclassname">qutip.three_level_atom.</code><code class="descname">three_level_basis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/three_level_atom.html#three_level_basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Basis states for a three level atom.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last"><cite>array</cite> of three level atom basis vectors.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.three_level_atom.three_level_ops">
<code class="descclassname">qutip.three_level_atom.</code><code class="descname">three_level_ops</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/three_level_atom.html#three_level_ops"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.three_level_atom.three_level_ops" title="Permalink to this definition">¶</a></dt>
<dd><p>Operators for a three level system (qutrit)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last"><cite>array</cite> of three level operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.superoperator">
<span id="superoperators-and-liouvillians"></span><h3>Superoperators and Liouvillians<a class="headerlink" href="#module-qutip.superoperator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.superoperator.operator_to_vector">
<code class="descclassname">qutip.superoperator.</code><code class="descname">operator_to_vector</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#operator_to_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.operator_to_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a vector representation of a quantum operator given
the matrix representation.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.vector_to_operator">
<code class="descclassname">qutip.superoperator.</code><code class="descname">vector_to_operator</code><span class="sig-paren">(</span><em>op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#vector_to_operator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.vector_to_operator" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a matrix representation given a quantum operator in
vector form.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.liouvillian">
<code class="descclassname">qutip.superoperator.</code><code class="descname">liouvillian</code><span class="sig-paren">(</span><em>H</em>, <em>c_ops=[]</em>, <em>data_only=False</em>, <em>chi=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the Liouvillian superoperator from a Hamiltonian
and a <code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators. Like liouvillian, but with an
experimental implementation which avoids creating extra Qobj instances,
which can be advantageous for large systems.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like of Qobj or QobjEvo</span></dt>
<dd><p class="first last">A <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of collapse operators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Liouvillian superoperator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spost">
<code class="descclassname">qutip.superoperator.</code><code class="descname">spost</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#spost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from post-multiplication by operator A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Quantum operator for post multiplication.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>super</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Superoperator formed from input qauntum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.spre">
<code class="descclassname">qutip.superoperator.</code><code class="descname">spre</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#spre"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.spre" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Quantum operator for pre-multiplication.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>super :Qobj or QobjEvo</strong></dt>
<dd><p class="first last">Superoperator formed from input quantum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.sprepost">
<code class="descclassname">qutip.superoperator.</code><code class="descname">sprepost</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#sprepost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.sprepost" title="Permalink to this definition">¶</a></dt>
<dd><p>Superoperator formed from pre-multiplication by operator A and post-
multiplication of operator B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Quantum operator for pre-multiplication.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Quantum operator for post-multiplication.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>super</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Superoperator formed from input quantum objects.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superoperator.lindblad_dissipator">
<code class="descclassname">qutip.superoperator.</code><code class="descname">lindblad_dissipator</code><span class="sig-paren">(</span><em>a</em>, <em>b=None</em>, <em>data_only=False</em>, <em>chi=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superoperator.html#lindblad_dissipator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superoperator.lindblad_dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Lindblad dissipator (generalized) for a single pair of collapse operators
(a, b), or for a single collapse operator (a) when b is not specified:</p>
<div class="math notranslate nohighlight">
\[\mathcal{D}[a,b]\rho = a \rho b^\dagger -
\frac{1}{2}a^\dagger b\rho - \frac{1}{2}\rho a^\dagger b\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo</span></dt>
<dd><p class="first last">Left part of collapse operator.</p>
</dd>
<dt><strong>b</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or QobjEvo (optional)</span></dt>
<dd><p class="first last">Right part of collapse operator. If not specified, b defaults to a.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>D</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj, QobjEvo</span></dt>
<dd><p class="first last">Lindblad dissipator superoperator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.superop_reps">
<span id="superoperator-representations"></span><h3>Superoperator Representations<a class="headerlink" href="#module-qutip.superop_reps" title="Permalink to this headline">¶</a></h3>
<p>This module implements transformations between superoperator representations,
including supermatrix, Kraus, Choi and Chi (process) matrix formalisms.</p>
<dl class="function">
<dt id="qutip.superop_reps.to_choi">
<code class="descclassname">qutip.superop_reps.</code><code class="descname">to_choi</code><span class="sig-paren">(</span><em>q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_choi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_choi" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the Choi representation,
such that the trace of the returned operator is equal to the dimension
of the system.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Superoperator to be converted to Choi representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_choi(A)</span> <span class="pre">==</span> <span class="pre">to_choi(sprepost(A,</span> <span class="pre">A.dag()))</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">choi.superrep</span> <span class="pre">==</span> <span class="pre">&quot;choi&quot;</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError: if the given quantum object is not a map, or cannot be converted</strong></dt>
<dd><p class="first last">to Choi representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_super">
<code class="descclassname">qutip.superop_reps.</code><code class="descname">to_super</code><span class="sig-paren">(</span><em>q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_super"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_super" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to the supermatrix (Liouville)
representation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Superoperator to be converted to supermatrix representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_super(A)</span> <span class="pre">==</span> <span class="pre">sprepost(A,</span> <span class="pre">A.dag())</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>superop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">A quantum object representing the same map as <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>, such that
<code class="docutils literal notranslate"><span class="pre">superop.superrep</span> <span class="pre">==</span> <span class="pre">&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError</strong></dt>
<dd><p class="first last">If the given quantum object is not a map, or cannot be converted
to supermatrix representation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.superop_reps.to_kraus">
<code class="descclassname">qutip.superop_reps.</code><code class="descname">to_kraus</code><span class="sig-paren">(</span><em>q_oper</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/superop_reps.html#to_kraus"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.superop_reps.to_kraus" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a Qobj representing a quantum map to a list of quantum objects,
each representing an operator in the Kraus decomposition of the given map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>q_oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Superoperator to be converted to Kraus representation. If
<code class="docutils literal notranslate"><span class="pre">q_oper</span></code> is <code class="docutils literal notranslate"><span class="pre">type=&quot;oper&quot;</span></code>, then it is taken to act by conjugation,
such that <code class="docutils literal notranslate"><span class="pre">to_kraus(A)</span> <span class="pre">==</span> <span class="pre">to_kraus(sprepost(A,</span> <span class="pre">A.dag()))</span> <span class="pre">==</span> <span class="pre">[A]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>kraus_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of Qobj</span></dt>
<dd><p class="first last">A list of quantum objects, each representing a Kraus operator in the
decomposition of <code class="docutils literal notranslate"><span class="pre">q_oper</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>TypeError: if the given quantum object is not a map, or cannot be</strong></dt>
<dd><p class="first last">decomposed into Kraus operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="functions-acting-on-states-and-operators">
<h2>Functions acting on states and operators<a class="headerlink" href="#functions-acting-on-states-and-operators" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.expect">
<span id="expectation-values"></span><h3>Expectation Values<a class="headerlink" href="#module-qutip.expect" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.expect.expect">
<code class="descclassname">qutip.expect.</code><code class="descname">expect</code><span class="sig-paren">(</span><em>oper</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/expect.html#expect"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.expect" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value for operator(s) and state(s).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj/array-like</span></dt>
<dd><p class="first last">A single or a <cite>list</cite> or operators for expectation value.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj/array-like</span></dt>
<dd><p class="first last">A single or a <cite>list</cite> of quantum states or density matrices.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>expt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float/complex/array-like</span></dt>
<dd><p class="first last">Expectation value.  <code class="docutils literal notranslate"><span class="pre">real</span></code> if <cite>oper</cite> is Hermitian, <code class="docutils literal notranslate"><span class="pre">complex</span></code>
otherwise. A (nested) array of expectaction values of state or operator
are arrays.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">expect</span><span class="p">(</span><span class="n">num</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">basis</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.expect.variance">
<code class="descclassname">qutip.expect.</code><code class="descname">variance</code><span class="sig-paren">(</span><em>oper</em>, <em>state</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/expect.html#variance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.expect.variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Variance of an operator for the given state vector or density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>oper</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Operator for expectation value.</p>
</dd>
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj/list</span></dt>
<dd><p class="first last">A single or <cite>list</cite> of quantum states or density matrices..</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>var</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Variance of operator 'oper' for given state.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.tensor">
<span id="tensor"></span><h3>Tensor<a class="headerlink" href="#module-qutip.tensor" title="Permalink to this headline">¶</a></h3>
<p>Module for the creation of composite quantum objects via the tensor product.</p>
<dl class="function">
<dt id="qutip.tensor.tensor">
<code class="descclassname">qutip.tensor.</code><code class="descname">tensor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input operators.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects for tensor product.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A composite quantum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tensor</span><span class="p">([</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmax</span><span class="p">()])</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.super_tensor">
<code class="descclassname">qutip.tensor.</code><code class="descname">super_tensor</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#super_tensor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.super_tensor" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the tensor product of input superoperators, by tensoring
together the underlying Hilbert spaces on which each vectorized operator
acts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of quantum objects with <code class="docutils literal notranslate"><span class="pre">type=&quot;super&quot;</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>obj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A composite quantum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.composite">
<code class="descclassname">qutip.tensor.</code><code class="descname">composite</code><span class="sig-paren">(</span><em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#composite"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.composite" title="Permalink to this definition">¶</a></dt>
<dd><p>Given two or more operators, kets or bras, returns the Qobj
corresponding to a composite system over each argument.
For ordinary operators and vectors, this is the tensor product,
while for superoperators and vectorized operators, this is
the column-reshuffled tensor product.</p>
<p>If a mix of Qobjs supported on Hilbert and Liouville spaces
are passed in, the former are promoted. Ordinary operators
are assumed to be unitaries, and are promoted using <code class="docutils literal notranslate"><span class="pre">to_super</span></code>,
while kets and bras are promoted by taking their projectors and
using <code class="docutils literal notranslate"><span class="pre">operator_to_vector(ket2dm(arg))</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.tensor.tensor_contract">
<code class="descclassname">qutip.tensor.</code><code class="descname">tensor_contract</code><span class="sig-paren">(</span><em>qobj</em>, <em>*pairs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tensor.html#tensor_contract"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tensor.tensor_contract" title="Permalink to this definition">¶</a></dt>
<dd><p>Contracts a qobj along one or more index pairs.
Note that this uses dense representations and thus
should <em>not</em> be used for very large Qobjs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pairs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">One or more tuples <code class="docutils literal notranslate"><span class="pre">(i,</span> <span class="pre">j)</span></code> indicating that the
<code class="docutils literal notranslate"><span class="pre">i</span></code> and <code class="docutils literal notranslate"><span class="pre">j</span></code> dimensions of the original qobj
should be contracted.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cqobj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">The original Qobj with all named index pairs contracted
away.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.partial_transpose">
<span id="partial-transpose"></span><h3>Partial Transpose<a class="headerlink" href="#module-qutip.partial_transpose" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.partial_transpose.partial_transpose">
<code class="descclassname">qutip.partial_transpose.</code><code class="descname">partial_transpose</code><span class="sig-paren">(</span><em>rho</em>, <em>mask</em>, <em>method='dense'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/partial_transpose.html#partial_transpose"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.partial_transpose.partial_transpose" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the partial transpose of a Qobj instance <cite>rho</cite>,
where <cite>mask</cite> is an array/list with length that equals
the number of components of <cite>rho</cite> (that is, the length of
<cite>rho.dims[0]</cite>), and the values in <cite>mask</cite> indicates whether
or not the corresponding subsystem is to be transposed.
The elements in <cite>mask</cite> can be boolean or integers <cite>0</cite> or <cite>1</cite>,
where <cite>True</cite>/<cite>1</cite> indicates that the corresponding subsystem
should be tranposed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">A density matrix.</p>
</dd>
<dt><strong>mask</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">A mask that selects which subsystems should be transposed.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of method, <cite>dense</cite> or <cite>sparse</cite>. The default method
is <cite>dense</cite>. The <cite>sparse</cite> implementation can be faster for
large and sparse systems (hundreds of quantum states).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rho_pr: :class:`qutip.qobj`</strong></dt>
<dd><p class="first last">A density matrix with the selected subsystems transposed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.entropy">
<span id="entropy-functions"></span><span id="functions-entropy"></span><h3>Entropy Functions<a class="headerlink" href="#module-qutip.entropy" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.entropy.concurrence">
<code class="descclassname">qutip.entropy.</code><code class="descname">concurrence</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#concurrence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.concurrence" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the concurrence entanglement measure for a two-qubit state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Ket, bra, or density matrix for a two-qubit state.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>concur</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Concurrence</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r8ba8a4d22c3a-1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id40">[1]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Concurrence_(quantum_computing">http://en.wikipedia.org/wiki/Concurrence_(quantum_computing</a>)</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_conditional">
<code class="descclassname">qutip.entropy.</code><code class="descname">entropy_conditional</code><span class="sig-paren">(</span><em>rho</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_conditional"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_conditional" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the conditional entropy <span class="math notranslate nohighlight">\(S(A|B)=S(A,B)-S(B)\)</span>
of a selected density matrix component.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix of composite object</p>
</dd>
<dt><strong>selB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/list</span></dt>
<dd><p class="first last">Selected components for density matrix B</p>
</dd>
<dt><strong>base</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{e,2}</span></dt>
<dd><p class="first last">Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False,True}</span></dt>
<dd><p class="first last">Use sparse eigensolver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ent_cond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Value of conditional entropy</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_linear">
<code class="descclassname">qutip.entropy.</code><code class="descname">entropy_linear</code><span class="sig-paren">(</span><em>rho</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_linear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_linear" title="Permalink to this definition">¶</a></dt>
<dd><p>Linear entropy of a density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">sensity matrix or ket/bra vector.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>entropy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear entropy of rho.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_linear</span><span class="p">(</span><span class="n">rho</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_mutual">
<code class="descclassname">qutip.entropy.</code><code class="descname">entropy_mutual</code><span class="sig-paren">(</span><em>rho</em>, <em>selA</em>, <em>selB</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_mutual"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_mutual" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the mutual information S(A:B) between selection
components of a system density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix for composite quantum systems</p>
</dd>
<dt><strong>selA</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/list</span></dt>
<dd><p class="first last"><cite>int</cite> or <cite>list</cite> of first selected density matrix components.</p>
</dd>
<dt><strong>selB</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int/list</span></dt>
<dd><p class="first last"><cite>int</cite> or <cite>list</cite> of second selected density matrix components.</p>
</dd>
<dt><strong>base</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{e,2}</span></dt>
<dd><p class="first last">Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False,True}</span></dt>
<dd><p class="first last">Use sparse eigensolver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ent_mut</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Mutual information between selected components.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.entropy.entropy_vn">
<code class="descclassname">qutip.entropy.</code><code class="descname">entropy_vn</code><span class="sig-paren">(</span><em>rho</em>, <em>base=2.718281828459045</em>, <em>sparse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/entropy.html#entropy_vn"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.entropy.entropy_vn" title="Permalink to this definition">¶</a></dt>
<dd><p>Von-Neumann entropy of density matrix</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix.</p>
</dd>
<dt><strong>base</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{e,2}</span></dt>
<dd><p class="first last">Base of logarithm.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False,True}</span></dt>
<dd><p class="first last">Use sparse eigensolver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>entropy</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Von-Neumann entropy of <cite>rho</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rho</span><span class="o">=</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy_vn</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qutip.metrics">
<span id="density-matrix-metrics"></span><h3>Density Matrix Metrics<a class="headerlink" href="#module-qutip.metrics" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of functions for calculating metrics
(distance measures) between states and operators.</p>
<dl class="function">
<dt id="qutip.metrics.fidelity">
<code class="descclassname">qutip.metrics.</code><code class="descname">fidelity</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the fidelity (pseudo-metric) between two density matrices.
See: Nielsen &amp; Chuang, &quot;Quantum Computation and Quantum Information&quot;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity pseudo-metric between A and B.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelity</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.24104350624628332</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.tracedist">
<code class="descclassname">qutip.metrics.</code><code class="descname">tracedist</code><span class="sig-paren">(</span><em>A</em>, <em>B</em>, <em>sparse=False</em>, <em>tol=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#tracedist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.tracedist" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the trace distance between two density matrices..
See: Nielsen &amp; Chuang, &quot;Quantum Computation and Quantum Information&quot;</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector with same dimensions as A.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Tolerance used by sparse eigensolver, if used. (0=Machine precision)</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{False, True}</span></dt>
<dd><p class="first last">Use sparse eigensolver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>tracedist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Trace distance between A and B.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">=</span><span class="n">fock_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">=</span><span class="n">coherent_dm</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tracedist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
<span class="go">0.9705143161472971</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_dist">
<code class="descclassname">qutip.metrics.</code><code class="descname">bures_dist</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#bures_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures distance between two density matrices A &amp; B.</p>
<p>The Bures distance ranges from 0, for states with unit fidelity,
to sqrt(2).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Bures distance between density matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.bures_angle">
<code class="descclassname">qutip.metrics.</code><code class="descname">bures_angle</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#bures_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.bures_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Bures Angle between two density matrices A &amp; B.</p>
<p>The Bures angle ranges from 0, for states with unit fidelity, to pi/2.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>angle</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Bures angle between density matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.hilbert_dist">
<code class="descclassname">qutip.metrics.</code><code class="descname">hilbert_dist</code><span class="sig-paren">(</span><em>A</em>, <em>B</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#hilbert_dist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.hilbert_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Hilbert-Schmidt distance between two density matrices A &amp; B.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector.</p>
</dd>
<dt><strong>B</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Density matrix or state vector with same dimensions as A.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Hilbert-Schmidt distance between density matrices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>See V. Vedral and M. B. Plenio, Phys. Rev. A 57, 1619 (1998).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.average_gate_fidelity">
<code class="descclassname">qutip.metrics.</code><code class="descname">average_gate_fidelity</code><span class="sig-paren">(</span><em>oper</em>, <em>target=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#average_gate_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.average_gate_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a Qobj representing the supermatrix form of a map, returns the
average gate fidelity (pseudo-metric) of that map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Quantum object representing a superoperator.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Quantum object representing the target unitary; the inverse
is applied before evaluating the fidelity.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fid</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity pseudo-metric between A and the identity superoperator,
or between A and the target superunitary.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.metrics.process_fidelity">
<code class="descclassname">qutip.metrics.</code><code class="descname">process_fidelity</code><span class="sig-paren">(</span><em>U1</em>, <em>U2</em>, <em>normalize=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/metrics.html#process_fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.metrics.process_fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the process fidelity given two process operators.</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.continuous_variables">
<span id="continous-variables"></span><h3>Continous Variables<a class="headerlink" href="#module-qutip.continuous_variables" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection functions for calculating continuous variable
quantities from fock-basis representation of the state of multi-mode fields.</p>
<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix">
<code class="descclassname">qutip.continuous_variables.</code><code class="descname">correlation_matrix</code><span class="sig-paren">(</span><em>basis</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the correlation
matrix:</p>
<div class="math notranslate nohighlight">
\[C_{mn} = \langle a_m a_n \rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>basis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of operators that defines the basis for the correlation matrix.</p>
</dd>
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Density matrix for which to calculate the correlation matrix. If
<cite>rho</cite> is <cite>None</cite>, then a matrix of correlation matrix operators is
returned instead of expectation values of those operators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A 2-dimensional <em>array</em> of correlation values or operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.covariance_matrix">
<code class="descclassname">qutip.continuous_variables.</code><code class="descname">covariance_matrix</code><span class="sig-paren">(</span><em>basis</em>, <em>rho</em>, <em>symmetrized=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a basis set of operators <span class="math notranslate nohighlight">\(\{a\}_n\)</span>, calculate the covariance
matrix:</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<p>or, if of the optional argument <cite>symmetrized=False</cite>,</p>
<div class="math notranslate nohighlight">
\[V_{mn} = \langle a_m a_n\rangle -
\langle a_m \rangle \langle a_n\rangle\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>basis</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of operators that defines the basis for the covariance matrix.</p>
</dd>
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Density matrix for which to calculate the covariance matrix.</p>
</dd>
<dt><strong>symmetrized</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True, False}</span></dt>
<dd><p class="first last">Flag indicating whether the symmetrized (default) or non-symmetrized
correlation matrix is to be calculated.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_field">
<code class="descclassname">qutip.continuous_variables.</code><code class="descname">correlation_matrix_field</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix_field"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_field" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the correlation matrix for given field operators <span class="math notranslate nohighlight">\(a_1\)</span> and
<span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation values are
calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cov_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array of complex numbers or Qobj's
A 2-dimensional <em>array</em> of covariance values, or, if rho=0, a matrix
of operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.correlation_matrix_quadrature">
<code class="descclassname">qutip.continuous_variables.</code><code class="descname">correlation_matrix_quadrature</code><span class="sig-paren">(</span><em>a1</em>, <em>a2</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#correlation_matrix_quadrature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.correlation_matrix_quadrature" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quadrature correlation matrix with given field operators
<span class="math notranslate nohighlight">\(a_1\)</span> and <span class="math notranslate nohighlight">\(a_2\)</span>. If a density matrix is given the expectation
values are calculated, otherwise a matrix with operators is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Field operator for mode 2.</p>
</dd>
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">Array of complex numbers or Qobj's
A 2-dimensional <em>array</em> of covariance values for the field quadratures,
or, if rho=0, a matrix of operators.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.wigner_covariance_matrix">
<code class="descclassname">qutip.continuous_variables.</code><code class="descname">wigner_covariance_matrix</code><span class="sig-paren">(</span><em>a1=None</em>, <em>a2=None</em>, <em>R=None</em>, <em>rho=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#wigner_covariance_matrix"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.wigner_covariance_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Wigner covariance matrix
<span class="math notranslate nohighlight">\(V_{ij} = \frac{1}{2}(R_{ij} + R_{ji})\)</span>, given
the quadrature correlation matrix
<span class="math notranslate nohighlight">\(R_{ij} = \langle R_{i} R_{j}\rangle -
\langle R_{i}\rangle \langle R_{j}\rangle\)</span>, where
<span class="math notranslate nohighlight">\(R = (q_1, p_1, q_2, p_2)^T\)</span> is the vector with quadrature operators
for the two modes.</p>
<p>Alternatively, if <cite>R = None</cite>, and if annihilation operators <cite>a1</cite> and <cite>a2</cite>
for the two modes are supplied instead, the quadrature correlation matrix
is constructed from the annihilation operators before then the covariance
matrix is calculated.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>a1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Field operator for mode 1.</p>
</dd>
<dt><strong>a2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Field operator for mode 2.</p>
</dd>
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">The quadrature correlation matrix.</p>
</dd>
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Density matrix for which to calculate the covariance matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cov_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">A 2-dimensional array of covariance values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.continuous_variables.logarithmic_negativity">
<code class="descclassname">qutip.continuous_variables.</code><code class="descname">logarithmic_negativity</code><span class="sig-paren">(</span><em>V</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/continuous_variables.html#logarithmic_negativity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.continuous_variables.logarithmic_negativity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the logarithmic negativity given a symmetrized covariance
matrix, see <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.continous_variables.covariance_matrix()</span></code>. Note that
the two-mode field state that is described by <cite>V</cite> must be Gaussian for this
function to applicable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>V</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>2d array</em></span></dt>
<dd><p class="first last">The covariance matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The logarithmic negativity for the two-mode Gaussian state
that is described by the the Wigner covariance matrix V.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="dynamics-and-time-evolution">
<h2>Dynamics and Time-Evolution<a class="headerlink" href="#dynamics-and-time-evolution" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.sesolve">
<span id="schrodinger-equation"></span><h3>Schrödinger Equation<a class="headerlink" href="#module-qutip.sesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the unitary Schrodinger equation.</p>
<dl class="function">
<dt id="qutip.sesolve.sesolve">
<code class="descclassname">qutip.sesolve.</code><code class="descname">sesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/sesolve.html#sesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.sesolve.sesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Schrodinger equation evolution of a state vector or unitary matrix
for a given Hamiltonian.</p>
<p>Evolve the state vector (<cite>psi0</cite>) using a given
Hamiltonian (<cite>H</cite>), by integrating the set of ordinary differential
equations that define the system. Alternatively evolve a unitary matrix in
solving the Schrodinger operator equation.</p>
<p>The output is either the state vector or unitary matrix at arbitrary points
in time (<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values. e_ops cannot be used in conjunction
with solving the Schrodinger operator equation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian, or a callback function for time-dependent
Hamiltonians.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">initial state vector (ket)
or initial unitary operator <cite>psi0 = U</cite></p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function single</span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.
Must be empty list operator evolution</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first last">dictionary of parameters for time-dependent Hamiltonians</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qdeoptions</span></code></span></dt>
<dd><p class="first last">with options for the ODE solver.</p>
</dd>
<dt><strong>progress_bar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">BaseProgressBar</span></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>, or
an <em>array</em> or state vectors corresponding to the
times in <cite>tlist</cite> [if <cite>e_ops</cite> is an empty list], or
nothing if a callback function was given inplace of operators for
which to calculate the expectation values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mesolve">
<span id="master-equation"></span><h3>Master Equation<a class="headerlink" href="#module-qutip.mesolve" title="Permalink to this headline">¶</a></h3>
<p>This module provides solvers for the Lindblad master equation and von Neumann
equation.</p>
<dl class="function">
<dt id="qutip.mesolve.mesolve">
<code class="descclassname">qutip.mesolve.</code><code class="descname">mesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops=[]</em>, <em>e_ops=[]</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/mesolve.html#mesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mesolve.mesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Master equation evolution of a density matrix for a given Hamiltonian and
set of collapse operators, or a Liouvillian.</p>
<p>Evolve the state vector or density matrix (<cite>rho0</cite>) using a given
Hamiltonian (<cite>H</cite>) and an [optional] set of collapse operators
(<cite>c_ops</cite>), by integrating the set of ordinary differential equations
that define the system. In the absence of collapse operators the system is
evolved according to the unitary evolution of the Hamiltonian.</p>
<p>The output is either the state vector at arbitrary points in time
(<cite>tlist</cite>), or the expectation values of the supplied operators
(<cite>e_ops</cite>). If e_ops is a callback function, it is invoked for each
time in <cite>tlist</cite> with time and the state as arguments, and the function
does not use any return values.</p>
<p>If either <cite>H</cite> or the Qobj elements in <cite>c_ops</cite> are superoperators, they
will be treated as direct contributions to the total system Liouvillian.
This allows to solve master equations that are not on standard Lindblad
form by passing a custom Liouvillian in place of either the <cite>H</cite> or <cite>c_ops</cite>
elements.</p>
<p><strong>Time-dependent operators</strong></p>
<p>For time-dependent problems, <cite>H</cite> and <cite>c_ops</cite> can be callback
functions that takes two arguments, time and <cite>args</cite>, and returns the
Hamiltonian or Liouvillian for the system at that point in time
(<em>callback format</em>).</p>
<p>Alternatively, <cite>H</cite> and <cite>c_ops</cite> can be a specified in a nested-list format
where each element in the list is a list of length 2, containing an
operator (<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>) at the first element and where the
second element is either a string (<em>list string format</em>), a callback
function (<em>list callback format</em>) that evaluates to the time-dependent
coefficient for the corresponding operator, or a NumPy array (<em>list
array format</em>) which specifies the value of the coefficient to the
corresponding operator for each value of t in tlist.</p>
<p><em>Examples</em></p>
<blockquote>
<div><p>H = [[H0, 'sin(w*t)'], [H1, 'sin(2*w*t)']]</p>
<p>H = [[H0, f0_t], [H1, f1_t]]</p>
<p>where f0_t and f1_t are python functions with signature f_t(t, args).</p>
<p>H = [[H0, np.sin(w*tlist)], [H1, np.sin(2*w*tlist)]]</p>
</div></blockquote>
<p>In the <em>list string format</em> and <em>list callback format</em>, the string
expression and the callback function must evaluate to a real or complex
number (coefficient for the corresponding operator).</p>
<p>In all cases of time-dependent operators, <cite>args</cite> is a dictionary of
parameters that is used when evaluating operators. It is passed to the
callback functions as second argument.</p>
<p><strong>Additional options</strong></p>
<p>Additional options to mesolve can be set via the <cite>options</cite> argument, which
should be an instance of <a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a>. Many ODE
integration options can be set this way, and the <cite>store_states</cite> and
<cite>store_final_state</cite> options can be used to store states even though
expectation values are requested via the <cite>e_ops</cite> argument.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If an element in the list-specification of the Hamiltonian or
the list of collapse operators are in superoperator form it will be
added to the total Liouvillian of the problem with out further
transformation. This allows for using mesolve for solving master
equations that are not on standard Lindblad form.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On using callback function: mesolve transforms all <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code>
objects to sparse matrices before handing the problem to the integrator
function. In order for your callback function to work correctly, pass
all <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> objects that are used in constructing the
Hamiltonian via args. mesolve will check for <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> in
<cite>args</cite> and handle the conversion to sparse matrices. All other
<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> objects that are not passed via <cite>args</cite> will be
passed on to the integrator in scipy which will raise an NotImplemented
exception.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System Hamiltonian, or a callback function for time-dependent
Hamiltonians, or alternatively a system Liouvillian.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">single collapse operator, or list of collapse operators, or a list
of Liouvillian superoperators.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first last">dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Options</span></code></span></dt>
<dd><p class="first last">with options for the solver.</p>
</dd>
<dt><strong>progress_bar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">BaseProgressBar</span></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: :class:`qutip.Result`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Result</span></code>, which contains
either an <em>array</em> <cite>result.expect</cite> of expectation values for the times
specified by <cite>tlist</cite>, or an <em>array</em> <cite>result.states</cite> of state vectors or
density matrices corresponding to the times in <cite>tlist</cite> [if <cite>e_ops</cite> is
an empty list], or nothing if a callback function was given in place of
operators for which to calculate the expectation values.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.mcsolve">
<span id="monte-carlo-evolution"></span><h3>Monte Carlo Evolution<a class="headerlink" href="#module-qutip.mcsolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.mcsolve.mcsolve">
<code class="descclassname">qutip.mcsolve.</code><code class="descname">mcsolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>c_ops=[]</em>, <em>e_ops=[]</em>, <em>ntraj=None</em>, <em>args={}</em>, <em>options=None</em>, <em>progress_bar=True</em>, <em>map_func=None</em>, <em>map_kwargs=None</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/mcsolve.html#mcsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.mcsolve.mcsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Monte Carlo evolution of a state vector <span class="math notranslate nohighlight">\(|\psi \rangle\)</span> for a
given Hamiltonian and sets of collapse operators, and possibly, operators
for calculating expectation values. Options for the underlying ODE solver
are given by the Options class.</p>
<p>mcsolve supports time-dependent Hamiltonians and collapse operators using
either Python functions of strings to represent time-dependent
coefficients. Note that, the system Hamiltonian MUST have at least one
constant term.</p>
<p>As an example of a time-dependent problem, consider a Hamiltonian with two
terms <code class="docutils literal notranslate"><span class="pre">H0</span></code> and <code class="docutils literal notranslate"><span class="pre">H1</span></code>, where <code class="docutils literal notranslate"><span class="pre">H1</span></code> is time-dependent with coefficient
<code class="docutils literal notranslate"><span class="pre">sin(w*t)</span></code>, and collapse operators <code class="docutils literal notranslate"><span class="pre">C0</span></code> and <code class="docutils literal notranslate"><span class="pre">C1</span></code>, where <code class="docutils literal notranslate"><span class="pre">C1</span></code> is
time-dependent with coeffcient <code class="docutils literal notranslate"><span class="pre">exp(-a*t)</span></code>.  Here, w and a are constant
arguments with values <code class="docutils literal notranslate"><span class="pre">W</span></code> and <code class="docutils literal notranslate"><span class="pre">A</span></code>.</p>
<p>Using the Python function time-dependent format requires two Python
functions, one for each collapse coefficient. Therefore, this problem could
be expressed as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">H1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">sin</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">C1_coeff</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">args</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>

<span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1_coeff</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="n">C1_coeff</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>or in String (Cython) format we could write:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="p">[</span><span class="n">H0</span><span class="p">,</span> <span class="p">[</span><span class="n">H1</span><span class="p">,</span> <span class="s1">&#39;sin(w*t)&#39;</span><span class="p">]]</span>

<span class="n">c_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">C0</span><span class="p">,</span> <span class="p">[</span><span class="n">C1</span><span class="p">,</span> <span class="s1">&#39;exp(-a*t)&#39;</span><span class="p">]]</span>

<span class="n">args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="n">A</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="n">W</span><span class="p">}</span>
</pre></div>
</div>
<p>Constant terms are preferably placed first in the Hamiltonian and collapse
operator lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Initial state vector</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Times at which results are recorded.</p>
</dd>
<dt><strong>ntraj</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of trajectories to run.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">single collapse operator or <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of collapse
operators.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">single operator or <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of operators for calculating
expectation values.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">Instance of ODE solver options.</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. Set to None to disable the
progress bar.</p>
</dd>
<dt><strong>map_func: function</strong></dt>
<dd><p class="first last">A map function for managing the calls to the single-trajactory solver.</p>
</dd>
<dt><strong>map_kwargs: dictionary</strong></dt>
<dd><p class="first last">Optional keyword arguments to the map_func function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>results</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt>
<dd><p class="first last">Object storing all results from the simulation.</p>
</dd>
<dt><strong>.. note::</strong></dt>
<dd><p class="first last">It is possible to reuse the random number seeds from a previous run
of the mcsolver by passing the output Result object seeds via the
Options class, i.e. Options(seeds=prev_result.seeds).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.essolve">
<span id="exponential-series"></span><h3>Exponential Series<a class="headerlink" href="#module-qutip.essolve" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.essolve.essolve">
<code class="descclassname">qutip.essolve.</code><code class="descname">essolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_op_list</em>, <em>e_ops</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/essolve.html#essolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.essolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolution of a state vector or density matrix (<cite>rho0</cite>) for a given
Hamiltonian (<cite>H</cite>) and set of collapse operators (<cite>c_op_list</cite>), by
expressing the ODE as an exponential series. The output is either
the state vector at arbitrary points in time (<cite>tlist</cite>), or the
expectation values of the supplied operators (<cite>e_ops</cite>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj/function_type</span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">Initial state density matrix.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_op_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> collapse operators.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> operators for which to evaluate
expectation values.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>expt_array</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Expectation values of wavefunctions/density matrices for the
times specified in <code class="docutils literal notranslate"><span class="pre">tlist</span></code>.</p>
</dd>
<dt><strong>.. note:: This solver does not support time-dependent Hamiltonians.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.essolve.ode2es">
<code class="descclassname">qutip.essolve.</code><code class="descname">ode2es</code><span class="sig-paren">(</span><em>L</em>, <em>rho0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/essolve.html#ode2es"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.essolve.ode2es" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates an exponential series that describes the time evolution for the
initial density matrix (or state vector) <cite>rho0</cite>, given the Liouvillian
(or Hamiltonian) <cite>L</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>L</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Liouvillian of the system.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Initial state vector or density matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eseries</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.eseries" title="qutip.eseries"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.eseries</span></code></a></span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">eseries</span></code> represention of the system dynamics.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.bloch_redfield">
<span id="bloch-redfield-master-equation"></span><h3>Bloch-Redfield Master Equation<a class="headerlink" href="#module-qutip.bloch_redfield" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.bloch_redfield.brmesolve">
<code class="descclassname">qutip.bloch_redfield.</code><code class="descname">brmesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>a_ops=[]</em>, <em>e_ops=[]</em>, <em>c_ops=[]</em>, <em>args={}</em>, <em>use_secular=True</em>, <em>sec_cutoff=0.1</em>, <em>tol=1e-12</em>, <em>spectra_cb=None</em>, <em>options=None</em>, <em>progress_bar=None</em>, <em>_safe_mode=True</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#brmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.brmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solves for the dynamics of a system using the Bloch-Redfield master equation,
given an input Hamiltonian, Hermitian bath-coupling terms and their associated 
spectrum functions, as well as possible Lindblad collapse operators.</p>
<p>For time-independent systems, the Hamiltonian must be given as a Qobj,
whereas the bath-coupling terms (a_ops), must be written as a nested list
of operator - spectrum function pairs, where the frequency is specified by
the <cite>w</cite> variable.</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [[a+a.dag(),lambda w: 0.2*(w&gt;=0)]]</div></blockquote>
<p>For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse
operators (c_ops), can be specified in the QuTiP string-based time-dependent
format.  For the a_op spectra, the frequency variable must be <cite>w</cite>, and the 
string cannot contain any other variables other than the possibility of having
a time-dependence through the time variable <cite>t</cite>:</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [[a+a.dag(), '0.2*exp(-t)*(w&gt;=0)']]</div></blockquote>
<p>It is also possible to use Cubic_Spline objects for time-dependence.  In
the case of a_ops, Cubic_Splines must be passed as a tuple:</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [ [a+a.dag(), ( f(w), g(t)] ]</div></blockquote>
<p>where f(w) and g(t) are strings or Cubic_spline objects for the bath
spectrum and time-dependence, respectively.</p>
<p>Finally, if one has bath-couplimg terms of the form
H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is</p>
<p><em>Example</em></p>
<blockquote>
<div>a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]</div></blockquote>
<p>where f(w) is the spectrum of the operators while g1(t) and g2(t)
are the time-dependence of the operators <cite>a</cite> and <cite>a.dag()</cite>, respectively</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj / list</span></dt>
<dd><p class="first last">System Hamiltonian given as a Qobj or
nested list in string-based format.</p>
</dd>
<dt><strong>psi0: Qobj</strong></dt>
<dd><p class="first last">Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of times for evaluating evolution</p>
</dd>
<dt><strong>a_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Nested list of Hermitian system operators that couple to 
the bath degrees of freedom, along with their associated
spectra.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of system collapse operators, or nested list in
string-based format.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Placeholder for future implementation, kept for API consistency.</p>
</dd>
<dt><strong>use_secular</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True}</span></dt>
<dd><p class="first last">Use secular approximation when evaluating bath-coupling terms.</p>
</dd>
<dt><strong>sec_cutoff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {0.1}</span></dt>
<dd><p class="first last">Cutoff for secular approximation.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {qutip.setttings.atol}</span></dt>
<dd><p class="first last">Tolerance used for removing small values after 
basis transformation.</p>
</dd>
<dt><strong>spectra_cb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">DEPRECIATED. Do not use.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Options" title="qutip.solver.Options"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Options</span></code></a></span></dt>
<dd><p class="first last">Options for the solver.</p>
</dd>
<dt><strong>progress_bar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">BaseProgressBar</span></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result: :class:`qutip.solver.Result`</strong></dt>
<dd><p class="first last">An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which contains
either an array of expectation values, for operators given in e_ops,
or a list of states for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_tensor">
<code class="descclassname">qutip.bloch_redfield.</code><code class="descname">bloch_redfield_tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div>Calculates the time-independent Bloch-Redfield tensor for a system given
a set of operators and corresponding spectral functions that describes the
system's couplingto its environment.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><blockquote class="first">
<div><p>System Hamiltonian.</p>
</div></blockquote>
<dl class="last docutils">
<dt>a_ops <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Nested list of system operators that couple to the environment,
and the corresponding bath spectra represented as Python
functions.</p>
</dd>
<dt>spectra_cb <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Depreciated.</p>
</dd>
<dt>c_ops <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of system collapse operators.</p>
</dd>
<dt>use_secular <span class="classifier-delimiter">:</span> <span class="classifier">bool {True, False}</span></dt>
<dd><p class="first last">Flag that indicates if the secular approximation should
be used.</p>
</dd>
<dt>sec_cutoff <span class="classifier-delimiter">:</span> <span class="classifier">float {0.1}</span></dt>
<dd><p class="first last">Threshold for secular approximation.</p>
</dd>
</dl>
</dd>
<dt><strong>atol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float {qutip.settings.atol}</span></dt>
<dd><p class="first last">Threshold for removing small parameters.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>R, kets: :class:`qutip.Qobj`, list of :class:`qutip.Qobj`</strong></dt>
<dd><p class="first last">R is the Bloch-Redfield tensor and kets is a list eigenstates of the
Hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.bloch_redfield.bloch_redfield_solve">
<code class="descclassname">qutip.bloch_redfield.</code><code class="descname">bloch_redfield_solve</code><span class="sig-paren">(</span><em>R</em>, <em>ekets</em>, <em>rho0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>options=None</em>, <em>progress_bar=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/bloch_redfield.html#bloch_redfield_solve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.bloch_redfield.bloch_redfield_solve" title="Permalink to this definition">¶</a></dt>
<dd><p>Evolve the ODEs defined by Bloch-Redfield master equation. The
Bloch-Redfield tensor can be calculated by the function
<a class="reference internal" href="#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">bloch_redfield_tensor()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>R</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">Bloch-Redfield tensor.</p>
</dd>
<dt><strong>ekets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">Array of kets that make up a basis tranformation for the eigenbasis.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">Initial density matrix.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt>
<dd><p class="first last">List of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qdeoptions</span></code></span></dt>
<dd><p class="first last">Options for the ODE solver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.floquet">
<span id="floquet-states-and-floquet-markov-master-equation"></span><h3>Floquet States and Floquet-Markov Master Equation<a class="headerlink" href="#module-qutip.floquet" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.floquet.fmmesolve">
<code class="descclassname">qutip.floquet.</code><code class="descname">fmmesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>tlist</em>, <em>c_ops=[]</em>, <em>e_ops=[]</em>, <em>spectra_cb=[]</em>, <em>T=None</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em>, <em>floquet_basis=True</em>, <em>kmax=5</em>, <em>_safe_mode=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#fmmesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fmmesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the dynamics for the system using the Floquet-Markov master equation.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This solver currently does not support multiple collapse operators.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian.</p>
</dd>
<dt><strong>rho0 / psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt>
<dd><p class="first last">list of operators for which to evaluate expectation values.</p>
</dd>
<dt><strong>spectra_cb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list callback functions</span></dt>
<dd><p class="first last">List of callback functions that compute the noise power spectrum as
a function of frequency for the collapse operators in <cite>c_ops</cite>.</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian. The default value
'None' indicates that the 'tlist' spans a single period of the driving.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first">dictionary of parameters for time-dependent Hamiltonians and
collapse operators.</p>
<p>This dictionary should also contain an entry 'w_th', which is
the temperature of the environment (if finite) in the
energy/frequency units of the Hamiltonian.  For example, if
the Hamiltonian written in units of 2pi GHz, and the
temperature is given in K, use the following conversion</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">temperature</span> <span class="o">=</span> <span class="mf">25e-3</span> <span class="c1"># unit K</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="mf">6.626e-34</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kB</span> <span class="o">=</span> <span class="mf">1.38e-23</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">args</span><span class="p">[</span><span class="s1">&#39;w_th&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">temperature</span> <span class="o">*</span> <span class="p">(</span><span class="n">kB</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="mf">1e-9</span>
</pre></div>
</div>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code></span></dt>
<dd><p class="first last">options for the ODE solver.</p>
</dd>
<dt><strong>k_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The truncation of the number of sidebands (default 5).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code></span></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver</span></code>, which contains either
an <em>array</em> of expectation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_modes</code><span class="sig-paren">(</span><em>H</em>, <em>T</em>, <em>args=None</em>, <em>sort=False</em>, <em>U=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the initial Floquet modes Phi_alpha(0) for a driven system with
period T.</p>
<p>Returns a list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> instances representing the Floquet
modes and a list of corresponding quasienergies, sorted by increasing
quasienergy in the interval [-pi/T, pi/T]. The optional parameter <cite>sort</cite>
decides if the output is to be sorted in increasing quasienergies or not.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian. The default value
'None' indicates that the 'tlist' spans a single period of the driving.</p>
</dd>
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">The propagator for the time-dependent Hamiltonian with period <cite>T</cite>.
If U is <cite>None</cite> (default), it will be calculated from the Hamiltonian
<cite>H</cite> using <a class="reference internal" href="#qutip.propagator.propagator" title="qutip.propagator.propagator"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.propagator.propagator()</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of kets, list of quasi energies</span></dt>
<dd><p class="first last">Two lists: the Floquet modes as kets and the quasi energies.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_modes_t</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the Floquet modes at times tlist Phi_alpha(tlist) propagting the
initial Floquet modes Phi_alpha(0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>f_modes_0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt>
<dd><p class="first last">Floquet modes at <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
<dt><strong>f_energies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Floquet energies.</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time at which to evaluate the floquet modes.</p>
</dd>
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">dictionary with variables required to evaluate H</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of kets</span></dt>
<dd><p class="first last">The Floquet modes as kets at time <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_table">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_modes_table</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>tlist</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Pre-calculate the Floquet modes for a range of times spanning the floquet
period. Can later be used as a table to look up the floquet modes for
any time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>f_modes_0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt>
<dd><p class="first last">Floquet modes at <span class="math notranslate nohighlight">\(t\)</span></p>
</dd>
<dt><strong>f_energies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">Floquet energies.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The list of times at which to evaluate the floquet modes.</p>
</dd>
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian, time-dependent with period <cite>T</cite></p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">dictionary with variables required to evaluate H</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">nested list</span></dt>
<dd><p class="first last">A nested list of Floquet modes as kets for each time in <cite>tlist</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_modes_t_lookup">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_modes_t_lookup</code><span class="sig-paren">(</span><em>f_modes_table_t</em>, <em>t</em>, <em>T</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_modes_t_lookup"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_modes_t_lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Lookup the floquet mode at time t in the pre-calculated table of floquet
modes in the first period of the time-dependence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>f_modes_table_t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">nested list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt>
<dd><p class="first last">A lookup-table of Floquet modes at times precalculated by
<a class="reference internal" href="#qutip.floquet.floquet_modes_table" title="qutip.floquet.floquet_modes_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.floquet.floquet_modes_table()</span></code></a>.</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time for which to evaluate the Floquet modes.</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">nested list</span></dt>
<dd><p class="first last">A list of Floquet modes as kets for the time that most closely matching
the time <cite>t</cite> in the supplied table of Floquet modes.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_states_t">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_states_t</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_states_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_states_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the floquet states at time t given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>f_modes_t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt>
<dd><p class="first last">A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The Floquet energies.</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">Dictionary with variables required to evaluate H.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of Floquet states for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_wavefunction_t">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_wavefunction_t</code><span class="sig-paren">(</span><em>f_modes_0</em>, <em>f_energies</em>, <em>f_coeff</em>, <em>t</em>, <em>H</em>, <em>T</em>, <em>args=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_wavefunction_t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_wavefunction_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the wavefunction for a time t using the Floquet state
decompositon, given the initial Floquet modes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>f_modes_t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt>
<dd><p class="first last">A list of initial Floquet modes (for time <span class="math notranslate nohighlight">\(t=0\)</span>).</p>
</dd>
<dt><strong>f_energies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The Floquet energies.</p>
</dd>
<dt><strong>f_coeff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The coefficients for Floquet decomposition of the initial wavefunction.</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The time for which to evaluate the Floquet states.</p>
</dd>
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">Dictionary with variables required to evaluate H.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">The wavefunction for the time <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.floquet_state_decomposition">
<code class="descclassname">qutip.floquet.</code><code class="descname">floquet_state_decomposition</code><span class="sig-paren">(</span><em>f_states</em>, <em>f_energies</em>, <em>psi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#floquet_state_decomposition"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.floquet_state_decomposition" title="Permalink to this definition">¶</a></dt>
<dd><p>Decompose the wavefunction <cite>psi</cite> (typically an initial state) in terms of
the Floquet states, <span class="math notranslate nohighlight">\(\psi = \sum_\alpha c_\alpha \psi_\alpha(0)\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>f_states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> (kets)</span></dt>
<dd><p class="first last">A list of Floquet modes.</p>
</dd>
<dt><strong>f_energies</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The Floquet energies.</p>
</dd>
<dt><strong>psi</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">The wavefunction to decompose in the Floquet state basis.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">The coefficients <span class="math notranslate nohighlight">\(c_\alpha\)</span> in the Floquet state decomposition.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.floquet.fsesolve">
<code class="descclassname">qutip.floquet.</code><code class="descname">fsesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>tlist</em>, <em>e_ops=[]</em>, <em>T=None</em>, <em>args={}</em>, <em>Tsteps=100</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/floquet.html#fsesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.floquet.fsesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the Schrodinger equation using the Floquet formalism.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">System Hamiltonian, time-dependent with period <cite>T</cite>.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">Initial state vector (ket).</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code> / callback function</span></dt>
<dd><p class="first last">list of operators for which to evaluate expectation values. If this
list is empty, the state vectors for each time in <cite>tlist</cite> will be
returned instead of expectation values.</p>
</dd>
<dt><strong>T</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The period of the time-dependence of the hamiltonian.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">Dictionary with variables required to evaluate H.</p>
</dd>
<dt><strong>Tsteps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of time steps in one driving period for which to
precalculate the Floquet modes. <cite>Tsteps</cite> should be an even number.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt>
<dd><p class="first last">An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>, which
contains either an <em>array</em> of expectation values or an array of
state vectors, for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.stochastic">
<span id="stochastic-schrodinger-equation-and-master-equation"></span><h3>Stochastic Schrödinger Equation and Master Equation<a class="headerlink" href="#module-qutip.stochastic" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.stochastic.smesolve">
<code class="descclassname">qutip.stochastic.</code><code class="descname">smesolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops=[]</em>, <em>sc_ops=[]</em>, <em>e_ops=[]</em>, <em>_safe_mode=True</em>, <em>args={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#smesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt>
<dd><p class="first last">System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt>
<dd><p class="first last">Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>sc_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt>
<dd><p class="first last">List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first last">Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver.SolverResult`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssesolve">
<code class="descclassname">qutip.stochastic.</code><code class="descname">ssesolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>times</em>, <em>sc_ops=[]</em>, <em>e_ops=[]</em>, <em>_safe_mode=True</em>, <em>args={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#ssesolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssesolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve stochastic master equation. Dispatch to specific solvers
depending on the value of the <cite>solver</cite> keyword argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent system.</span></dt>
<dd><p class="first last">System Hamiltonian.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">State vector (ket).</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>sc_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a>, or time dependent Qobjs.</span></dt>
<dd><p class="first last">List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.
Can depend on time, see StochasticSolverOptions help for format.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first last">Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver.SolverResult`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.smepdpsolve">
<code class="descclassname">qutip.stochastic.</code><code class="descname">smepdpsolve</code><span class="sig-paren">(</span><em>H</em>, <em>rho0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#smepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.smepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for density matrix
evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Initial density matrix.</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>sc_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">List of stochastic collapse operators. Each stochastic collapse
operator will give a deterministic and stochastic contribution
to the eqaution of motion according to how the d1 and d2 functions
are defined.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first last">Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver.SolverResult`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.stochastic.ssepdpsolve">
<code class="descclassname">qutip.stochastic.</code><code class="descname">ssepdpsolve</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>times</em>, <em>c_ops</em>, <em>e_ops</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/stochastic.html#ssepdpsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.stochastic.ssepdpsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>A stochastic (piecewse deterministic process) PDP solver for wavefunction
evolution. For most purposes, use <a class="reference internal" href="#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve()</span></code></a> instead for quantum
trajectory simulations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Initial state vector (ket).</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> / <em>array</em></span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(t\)</span>. Must be uniformly spaced.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Deterministic collapse operator which will contribute with a standard
Lindblad type of dissipation.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function single</span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>dictionary</em></span></dt>
<dd><p class="first last">Optional keyword arguments. See
<a class="reference internal" href="classes.html#qutip.stochastic.StochasticSolverOptions" title="qutip.stochastic.StochasticSolverOptions"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.stochastic.StochasticSolverOptions</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver.SolverResult`</strong></dt>
<dd><p class="first last">An instance of the class <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.SolverResult</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.correlation">
<span id="correlation-functions"></span><h3>Correlation Functions<a class="headerlink" href="#module-qutip.correlation" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.correlation.correlation">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>reverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>bool</em></span></dt>
<dd><p class="first last">If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_ss">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_ss</code><span class="sig-paren">(</span><em>H</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:</p>
<div class="math notranslate nohighlight">
\[\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\]</div>
<p>along one time axis (given steady-state initial conditions) using the
quantum regression theorem and the evolution solver indicated by the
<cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>reverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>bool</em></span></dt>
<dd><p class="first last">If <cite>True</cite>, calculate
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_1t">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_2op_1t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_2op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the evolution
solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>reverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'me', 'mc', 'es'}</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">Solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">An array of correlation values for the times specified by <cite>tlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_2op_2t">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_2op_2t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='me'</em>, <em>reverse=False</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_2op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_2op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the two-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>reverse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">If <cite>True</cite>, calculate <span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)\right&gt;\)</span> instead of
<span class="math notranslate nohighlight">\(\left&lt;A(t+\tau)B(t)\right&gt;\)</span>.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray</span></dt>
<dd><p class="first last">An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_1t">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_3op_1t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>solver='me'</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_3op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>c_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator C.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array of correlation values for the times specified by <cite>taulist</cite></p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_3op_2t">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_3op_2t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>solver='me'</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_3op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_3op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the three-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>c_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator C.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_1t">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_4op_1t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver='me'</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_4op_1t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_1t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along one time axis using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>c_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator C.</p>
</dd>
<dt><strong>d_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator D.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_vec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array of correlation values for the times specified by <cite>taulist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Deprecated in QuTiP 3.1
Use correlation_3op_1t() instead.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.correlation_4op_2t">
<code class="descclassname">qutip.correlation.</code><code class="descname">correlation_4op_2t</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>tlist</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>c_op</em>, <em>d_op</em>, <em>solver='me'</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#correlation_4op_2t"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.correlation_4op_2t" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the four-operator two-time correlation function:
<span class="math notranslate nohighlight">\(\left&lt;A(t)B(t+\tau)C(t+\tau)D(t)\right&gt;\)</span>
along two time axes using the quantum regression theorem and the
evolution solver indicated by the <cite>solver</cite> parameter.</p>
<p>Note: it is not possibly to calculate a physically meaningful correlation
of this form where <span class="math notranslate nohighlight">\(\tau&lt;0\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho_0\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi_0\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(t\)</span>. tlist must be positive and contain the
element <cite>0</cite>. When taking steady-steady correlations only one tlist
value is necessary, i.e. when <span class="math notranslate nohighlight">\(t \rightarrow \infty\)</span>; here
tlist is automatically set, ignoring user input.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>c_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator C.</p>
</dd>
<dt><strong>d_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator D.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation, <cite>mc</cite> for Monte Carlo, and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>corr_mat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An 2-dimensional array (matrix) of correlation values for the times
specified by <cite>tlist</cite> (first index) and <cite>taulist</cite> (second index). If
<cite>tlist</cite> is <cite>None</cite>, then a 1-dimensional array of correlation values
is returned instead.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<p>See, Gardiner, Quantum Noise, Section 5.2.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum">
<code class="descclassname">qutip.correlation.</code><code class="descname">spectrum</code><span class="sig-paren">(</span><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>solver='es'</em>, <em>use_pinv=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using the solver indicated by the <cite>solver</cite> parameter. Note: this spectrum
is only defined for stationary statistics (uses steady state rho0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>es</cite> for exponential series and
<cite>pi</cite> for psuedo-inverse).</p>
</dd>
<dt><strong>use_pinv</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">For use with the <cite>pi</cite> solver: if <cite>True</cite> use numpy's pinv method,
otherwise use a generic solver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_ss">
<code class="descclassname">qutip.correlation.</code><code class="descname">spectrum_ss</code><span class="sig-paren">(</span><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_ss"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_ss" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using an eseries based solver Note: this spectrum is only defined for
stationary statistics (uses steady state rho0).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>use_pinv</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>bool</em></span></dt>
<dd><p class="first last">If <cite>True</cite> use numpy's <cite>pinv</cite> method, otherwise use a generic solver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_pi">
<code class="descclassname">qutip.correlation.</code><code class="descname">spectrum_pi</code><span class="sig-paren">(</span><em>H</em>, <em>wlist</em>, <em>c_ops</em>, <em>a_op</em>, <em>b_op</em>, <em>use_pinv=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_pi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_pi" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the spectrum of the correlation function
<span class="math notranslate nohighlight">\(\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;\)</span>,
i.e., the Fourier transform of the correlation function:</p>
<div class="math notranslate nohighlight">
\[S(\omega) = \int_{-\infty}^{\infty}
\lim_{t \to \infty} \left&lt;A(t+\tau)B(t)\right&gt;
e^{-i\omega\tau} d\tau.\]</div>
<p>using a psuedo-inverse method. Note: this spectrum is only defined for
stationary statistics (uses steady state rho0)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">system Hamiltonian.</p>
</dd>
<dt><strong>wlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of frequencies for <span class="math notranslate nohighlight">\(\omega\)</span>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>list</em> of <code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">list of collapse operators.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>b_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj</span></code></span></dt>
<dd><p class="first last">operator B.</p>
</dd>
<dt><strong>use_pinv</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>bool</em></span></dt>
<dd><p class="first last">If <cite>True</cite> use numpy's pinv method, otherwise use a generic solver.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spectrum</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">An array with spectrum <span class="math notranslate nohighlight">\(S(\omega)\)</span> for the frequencies
specified in <cite>wlist</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.spectrum_correlation_fft">
<code class="descclassname">qutip.correlation.</code><code class="descname">spectrum_correlation_fft</code><span class="sig-paren">(</span><em>tlist</em>, <em>y</em>, <em>inverse=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#spectrum_correlation_fft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.spectrum_correlation_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the power spectrum corresponding to a two-time correlation
function using FFT.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list/array of times <span class="math notranslate nohighlight">\(t\)</span> which the correlation function is given.</p>
</dd>
<dt><strong>y</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list/array of correlations corresponding to time delays <span class="math notranslate nohighlight">\(t\)</span>.</p>
</dd>
<dt><strong>inverse: boolean</strong></dt>
<dd><p class="first last">boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>w, S</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Returns an array of angular frequencies 'w' and the corresponding
two-sided power spectrum 'S(w)'.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g1">
<code class="descclassname">qutip.correlation.</code><code class="descname">coherence_function_g1</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver='me'</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#coherence_function_g1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g1" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized first-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[g^{(1)}(\tau) =
\frac{\langle A^\dagger(\tau)A(0)\rangle}
{\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle
        \langle A^\dagger(0)A(0)\rangle}}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>g1, G1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.correlation.coherence_function_g2">
<code class="descclassname">qutip.correlation.</code><code class="descname">coherence_function_g2</code><span class="sig-paren">(</span><em>H</em>, <em>state0</em>, <em>taulist</em>, <em>c_ops</em>, <em>a_op</em>, <em>solver='me'</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/correlation.html#coherence_function_g2"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.correlation.coherence_function_g2" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the normalized second-order quantum coherence function:</p>
<div class="math notranslate nohighlight">
\[ g^{(2)}(\tau) =
\frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}
{\langle A^\dagger(\tau)A(\tau)\rangle
 \langle A^\dagger(0)A(0)\rangle}\]</div>
<p>using the quantum regression theorem and the evolution solver indicated by
the <cite>solver</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">system Hamiltonian, may be time-dependent for solver choice of <cite>me</cite> or
<cite>mc</cite>.</p>
</dd>
<dt><strong>state0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>. If 'state0' is 'None', then the steady state will
be used as the initial state. The 'steady-state' is only implemented
for the <cite>me</cite> and <cite>es</cite> solvers.</p>
</dd>
<dt><strong>taulist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times for <span class="math notranslate nohighlight">\(\tau\)</span>. taulist must be positive and contain
the element <cite>0</cite>.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">list of collapse operators, may be time-dependent for solver choice of
<cite>me</cite> or <cite>mc</cite>.</p>
</dd>
<dt><strong>a_op</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">operator A.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Dictionary of arguments to be passed to solver.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">choice of solver (<cite>me</cite> for master-equation and
<cite>es</cite> for exponential series).</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">solver options class. <cite>ntraj</cite> is taken as a two-element list because
the <cite>mc</cite> correlator calls <cite>mcsolve()</cite> recursively; by default,
<cite>ntraj=[20, 100]</cite>. <cite>mc_corr_eps</cite> prevents divide-by-zero errors in
the <cite>mc</cite> correlator; by default, <cite>mc_corr_eps=1e-10</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>g2, G2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">The normalized and unnormalized second-order coherence function.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.steadystate">
<span id="steady-state-solvers"></span><h3>Steady-state Solvers<a class="headerlink" href="#module-qutip.steadystate" title="Permalink to this headline">¶</a></h3>
<p>Module contains functions for solving for the steady state density matrix of
open quantum systems defined by a Liouvillian or Hamiltonian and a list of
collapse operators.</p>
<dl class="function">
<dt id="qutip.steadystate.steadystate">
<code class="descclassname">qutip.steadystate.</code><code class="descname">steadystate</code><span class="sig-paren">(</span><em>A</em>, <em>c_op_list=[]</em>, <em>method='direct'</em>, <em>solver=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/steadystate.html#steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the steady state for quantum evolution subject to the
supplied Hamiltonian or Liouvillian operator and (if given a Hamiltonian) a
list of collapse operators.</p>
<p>If the user passes a Hamiltonian then it, along with the list of collapse
operators, will be converted into a Liouvillian operator in Lindblad form.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of collapse operators.</p>
</dd>
<dt><strong>solver</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {None, 'scipy', 'mkl'}</span></dt>
<dd><p class="first last">Selects the sparse solver to use.  Default is auto-select
based on the availability of the MKL library.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'direct', 'eigen', 'iterative-gmres',</span></dt>
<dd><blockquote class="first">
<div><p>'iterative-lgmres', 'iterative-bicgstab', 'svd', 'power',
'power-gmres', 'power-lgmres', 'power-bicgstab'}</p>
</div></blockquote>
<p class="last">Method for solving the underlying linear equation. Direct LU solver
'direct' (default), sparse eigenvalue problem 'eigen',
iterative GMRES method 'iterative-gmres', iterative LGMRES method
'iterative-lgmres', iterative BICGSTAB method 'iterative-bicgstab',
SVD 'svd' (dense), or inverse-power method 'power'. The iterative
power methods 'power-gmres', 'power-lgmres', 'power-bicgstab' use
the same solvers as their direct counterparts.</p>
</dd>
<dt><strong>return_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = False</span></dt>
<dd><p class="first last">Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = True</span></dt>
<dd><p class="first last">Solve for the steady state using sparse algorithms. If set to False,
the underlying Liouvillian operator will be converted into a dense
matrix. Use only for 'smaller' systems.</p>
</dd>
<dt><strong>use_rcm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = False</span></dt>
<dd><p class="first last">Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</dd>
<dt><strong>use_wbm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = False</span></dt>
<dd><p class="first last">Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</dd>
<dt><strong>weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</dd>
<dt><strong>max_iter_refine</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int {10}</span></dt>
<dd><p class="first last">MKL ONLY. Max. number of iterative refinements to perform.</p>
</dd>
<dt><strong>scaling_vectors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True, False}</span></dt>
<dd><p class="first last">MKL ONLY.  Scale matrix to unit norm columns and rows.</p>
</dd>
<dt><strong>weighted_matching</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {True, False}</span></dt>
<dd><p class="first last">MKL ONLY.  Use weighted matching to better condition diagonal.</p>
</dd>
<dt><strong>x0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndarray, optional</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Initial guess for solution vector.</p>
</dd>
<dt><strong>maxiter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional, default=1000</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Maximum number of iterations to perform.</p>
</dd>
<dt><strong>tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1e-12</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Tolerance used for terminating solver.</p>
</dd>
<dt><strong>mtol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=None</span></dt>
<dd><p class="first last">ITERATIVE 'power' methods ONLY. Tolerance for lu solve method.
If None given then <cite>max(0.1*tol, 1e-15)</cite> is used</p>
</dd>
<dt><strong>matol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default=1e-15</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Absolute tolerance for lu solve method.</p>
</dd>
<dt><strong>permc_spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default='COLAMD'</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Column ordering used internally by superLU for the
'direct' LU decomposition method. Options include 'COLAMD' and
'NATURAL'. If using RCM then this is set to 'NATURAL' automatically
unless explicitly specified.</p>
</dd>
<dt><strong>use_precond</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool optional, default = False</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Use an incomplete sparse LU decomposition as a
preconditioner for the 'iterative' GMRES and BICG solvers.
Speeds up convergence time by orders of magnitude in many cases.</p>
</dd>
<dt><strong>M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">{sparse matrix, dense matrix, LinearOperator}, optional</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Preconditioner for A. The preconditioner should
approximate the inverse of A. Effective preconditioning can
dramatically improve the rate of convergence for iterative methods.
If no preconditioner is given and <code class="docutils literal notranslate"><span class="pre">use_precond</span> <span class="pre">=</span> <span class="pre">True</span></code>, then one
is generated automatically.</p>
</dd>
<dt><strong>fill_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default = 100</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</dd>
<dt><strong>drop_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default = 1e-4</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</dd>
<dt><strong>diag_pivot_thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default = None</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</dd>
<dt><strong>ILU_MILU</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default = 'smilu_2'</span></dt>
<dd><p class="first last">ITERATIVE ONLY. Selects the incomplete LU decomposition method
algoithm used in creating the preconditoner. Should only be used by
advanced users.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>dm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Steady state density matrix.</p>
</dd>
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Dictionary containing solver-specific information about the solution.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The SVD method works only for dense operators (i.e. small systems).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.steadystate.build_preconditioner">
<code class="descclassname">qutip.steadystate.</code><code class="descname">build_preconditioner</code><span class="sig-paren">(</span><em>A</em>, <em>c_op_list=[]</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/steadystate.html#build_preconditioner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.steadystate.build_preconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a iLU preconditioner necessary for solving for
the steady state density matrix using the iterative linear solvers
in the 'steadystate' function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A Hamiltonian or Liouvillian operator.</p>
</dd>
<dt><strong>c_op_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of collapse operators.</p>
</dd>
<dt><strong>return_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = False</span></dt>
<dd><p class="first last">Return a dictionary of solver-specific infomation about the
solution and how it was obtained.</p>
</dd>
<dt><strong>use_rcm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = False</span></dt>
<dd><p class="first last">Use reverse Cuthill-Mckee reordering to minimize fill-in in the
LU factorization of the Liouvillian.</p>
</dd>
<dt><strong>use_wbm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool, optional, default = False</span></dt>
<dd><p class="first last">Use Weighted Bipartite Matching reordering to make the Liouvillian
diagonally dominant.  This is useful for iterative preconditioners
only, and is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default when finding a preconditioner.</p>
</dd>
<dt><strong>weight</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional</span></dt>
<dd><p class="first last">Sets the size of the elements used for adding the unity trace condition
to the linear solvers.  This is set to the average abs value of the
Liouvillian elements if not specified by the user.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, default = 'iterative'</span></dt>
<dd><p class="first last">Tells the preconditioner what type of Liouvillian to build for
iLU factorization.  For direct iterative methods use 'iterative'.
For power iterative methods use 'power'.</p>
</dd>
<dt><strong>permc_spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default='COLAMD'</span></dt>
<dd><p class="first last">Column ordering used internally by superLU for the
'direct' LU decomposition method. Options include 'COLAMD' and
'NATURAL'. If using RCM then this is set to 'NATURAL' automatically
unless explicitly specified.</p>
</dd>
<dt><strong>fill_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default = 100</span></dt>
<dd><p class="first last">Specifies the fill ratio upper bound (&gt;=1) of the iLU
preconditioner.  Lower values save memory at the cost of longer
execution times and a possible singular factorization.</p>
</dd>
<dt><strong>drop_tol</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default = 1e-4</span></dt>
<dd><p class="first last">Sets the threshold for the magnitude of preconditioner
elements that should be dropped.  Can be reduced for a courser
factorization at the cost of an increased number of iterations, and a
possible singular factorization.</p>
</dd>
<dt><strong>diag_pivot_thresh</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float, optional, default = None</span></dt>
<dd><p class="first last">Sets the threshold between [0,1] for which diagonal
elements are considered acceptable pivot points when using a
preconditioner.  A value of zero forces the pivot to be the diagonal
element.</p>
</dd>
<dt><strong>ILU_MILU</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional, default = 'smilu_2'</span></dt>
<dd><p class="first last">Selects the incomplete LU decomposition method algoithm used in
creating the preconditoner. Should only be used by advanced users.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>lu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">object</span></dt>
<dd><p class="first last">Returns a SuperLU object representing iLU preconditioner.</p>
</dd>
<dt><strong>info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict, optional</span></dt>
<dd><p class="first last">Dictionary containing solver-specific information.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.propagator">
<span id="propagators"></span><h3>Propagators<a class="headerlink" href="#module-qutip.propagator" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.propagator.propagator">
<code class="descclassname">qutip.propagator.</code><code class="descname">propagator</code><span class="sig-paren">(</span><em>H</em>, <em>t</em>, <em>c_op_list=[]</em>, <em>args={}</em>, <em>options=None</em>, <em>unitary_mode='batch'</em>, <em>parallel=False</em>, <em>progress_bar=None</em>, <em>_safe_mode=True</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/propagator.html#propagator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the propagator U(t) for the density matrix or wave function such
that <span class="math notranslate nohighlight">\(\psi(t) = U(t)\psi(0)\)</span> or
<span class="math notranslate nohighlight">\(\rho_{\mathrm vec}(t) = U(t) \rho_{\mathrm vec}(0)\)</span>
where <span class="math notranslate nohighlight">\(\rho_{\mathrm vec}\)</span> is the vector representation of the
density matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj or list</span></dt>
<dd><p class="first last">Hamiltonian as a Qobj instance of a nested list of Qobjs and
coefficients in the list-string or list-function format for
time-dependent Hamiltonians (see description in <a class="reference internal" href="#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve()</span></code></a>).</p>
</dd>
<dt><strong>t</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array-like</span></dt>
<dd><p class="first last">Time or list of times for which to evaluate the propagator.</p>
</dd>
<dt><strong>c_op_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of qobj collapse operators.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array/dictionary</span></dt>
<dd><p class="first last">Parameters to callback functions for time-dependent Hamiltonians and
collapse operators.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Options</span></code></span></dt>
<dd><p class="first last">with options for the ODE solver.</p>
</dd>
<dt><strong>unitary_mode = str ('batch', 'single')</strong></dt>
<dd><p class="first last">Solve all basis vectors simulaneously ('batch') or individually 
('single').</p>
</dd>
<dt><strong>parallel</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Run the propagator in parallel mode. This will override the 
unitary_mode settings if set to True.</p>
</dd>
<dt><strong>progress_bar: BaseProgressBar</strong></dt>
<dd><p class="first last">Optional instance of BaseProgressBar, or a subclass thereof, for
showing the progress of the simulation. By default no progress bar
is used, and if set to True a TextProgressBar will be used.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Instance representing the propagator <span class="math notranslate nohighlight">\(U(t)\)</span>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.propagator.propagator_steadystate">
<code class="descclassname">qutip.propagator.</code><code class="descname">propagator_steadystate</code><span class="sig-paren">(</span><em>U</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/propagator.html#propagator_steadystate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.propagator.propagator_steadystate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the steady state for successive applications of the propagator
<span class="math notranslate nohighlight">\(U\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Operator representing the propagator.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Instance representing the steady-state density matrix.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.rhs_generate">
<span id="time-dependent-problems"></span><h3>Time-dependent problems<a class="headerlink" href="#module-qutip.rhs_generate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.rhs_generate.rhs_generate">
<code class="descclassname">qutip.rhs_generate.</code><code class="descname">rhs_generate</code><span class="sig-paren">(</span><em>H</em>, <em>c_ops</em>, <em>args={}</em>, <em>options=&lt;qutip.solver.Options object&gt;</em>, <em>name=None</em>, <em>cleanup=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/rhs_generate.html#rhs_generate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_generate" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the Cython functions needed for solving the dynamics of a
given system using the mesolve function inside a parfor loop.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">System Hamiltonian.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of collapse operators.</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Arguments for time-dependent Hamiltonian and collapse operator terms.</p>
</dd>
<dt><strong>options</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Options</span></dt>
<dd><p class="first last">Instance of ODE solver options.</p>
</dd>
<dt><strong>name: str</strong></dt>
<dd><p class="first last">Name of generated RHS</p>
</dd>
<dt><strong>cleanup: bool</strong></dt>
<dd><p class="first last">Whether the generated cython file should be automatically removed or
not.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Using this function with any solver other than the mesolve function
will result in an error.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.rhs_generate.rhs_clear">
<code class="descclassname">qutip.rhs_generate.</code><code class="descname">rhs_clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/rhs_generate.html#rhs_clear"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.rhs_generate.rhs_clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the string-format time-dependent Hamiltonian parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Nothing, just clears data from internal config module.</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.scattering">
<span id="scattering-in-quantum-optical-systems"></span><h3>Scattering in Quantum Optical Systems<a class="headerlink" href="#module-qutip.scattering" title="Permalink to this headline">¶</a></h3>
<p>Photon scattering in quantum optical systems</p>
<p>This module includes a collection of functions for numerically computing photon
scattering in driven arbitrary systems coupled to some configuration of output
waveguides. The implementation of these functions closely follows the
mathematical treatment given in K.A. Fischer, et. al., Scattering of Coherent
Pulses from Quantum Optical Systems (2017, arXiv:1710.02875).</p>
<dl class="function">
<dt id="qutip.scattering.temporal_basis_vector">
<code class="descclassname">qutip.scattering.</code><code class="descname">temporal_basis_vector</code><span class="sig-paren">(</span><em>waveguide_emission_indices</em>, <em>n_time_bins</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/scattering.html#temporal_basis_vector"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.scattering.temporal_basis_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a temporal basis vector for emissions at specified time bins into
specified waveguides.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>waveguide_emission_indices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list or tuple</span></dt>
<dd><p class="first last">List of indices where photon emission occurs for each waveguide,
e.g. [[t1_wg1], [t1_wg2, t2_wg2], [], [t1_wg4, t2_wg4, t3_wg4]].</p>
</dd>
<dt><strong>n_time_bins</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of time bins; the range over which each index can vary.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>temporal_basis_vector</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj</span></dt>
<dd><p class="first last">A basis vector representing photon scattering at the specified indices.
If there are W waveguides, T times, and N photon emissions, then the
basis vector has dimensionality (W*T)^N.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.scattering.temporal_scattered_state">
<code class="descclassname">qutip.scattering.</code><code class="descname">temporal_scattered_state</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>n_emissions</em>, <em>c_ops</em>, <em>tlist</em>, <em>system_zero_state=None</em>, <em>construct_effective_hamiltonian=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/scattering.html#temporal_scattered_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.scattering.temporal_scattered_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the scattered n-photon state projected onto the temporal basis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj or list</span></dt>
<dd><p class="first last">System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from <cite>H</cite> and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of photon emissions to calculate.</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span></p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest.</p>
</dd>
<dt><strong>system_zero_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj</span></dt>
<dd><p class="first last">State representing zero excitations in the system. Defaults to
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span></p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether an effective Hamiltonian should be constructed from H and c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phi_n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj</span></dt>
<dd><p class="first last">The scattered bath state projected onto the temporal basis given by
tlist. If there are W waveguides, T times, and N photon emissions, then
the state is a tensor product state with dimensionality T^(W*N).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.scattering.scattering_probability">
<code class="descclassname">qutip.scattering.</code><code class="descname">scattering_probability</code><span class="sig-paren">(</span><em>H</em>, <em>psi0</em>, <em>n_emissions</em>, <em>c_ops</em>, <em>tlist</em>, <em>system_zero_state=None</em>, <em>construct_effective_hamiltonian=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/scattering.html#scattering_probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.scattering.scattering_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the integrated probability of scattering n photons in an arbitrary
system. This function accepts a nonlinearly spaced array of times.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj or list</span></dt>
<dd><p class="first last">System-waveguide(s) Hamiltonian or effective Hamiltonian in Qobj or
list-callback format. If construct_effective_hamiltonian is not
specified, an effective Hamiltonian is constructed from H and
<cite>c_ops</cite>.</p>
</dd>
<dt><strong>psi0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj</span></dt>
<dd><p class="first last">Initial state density matrix <span class="math notranslate nohighlight">\(\rho(t_0)\)</span> or state vector
<span class="math notranslate nohighlight">\(\psi(t_0)\)</span>.</p>
</dd>
<dt><strong>n_emissions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of photons emitted by the system (into any combination of
waveguides).</p>
</dd>
<dt><strong>c_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of collapse operators for each waveguide; these are assumed to
include spontaneous decay rates, e.g.
<span class="math notranslate nohighlight">\(\sigma = \sqrt \gamma \cdot a\)</span>.</p>
</dd>
<dt><strong>tlist</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">List of times for <span class="math notranslate nohighlight">\(\tau_i\)</span>. tlist should contain 0 and exceed
the pulse duration / temporal region of interest; tlist need not be
linearly spaced.</p>
</dd>
<dt><strong>system_zero_state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">:class: qutip.Qobj</span></dt>
<dd><p class="first last">State representing zero excitations in the system. Defaults to
<cite>basis(systemDims, 0)</cite>.</p>
</dd>
<dt><strong>construct_effective_hamiltonian</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether an effective Hamiltonian should be constructed from H and c_ops:
<span class="math notranslate nohighlight">\(H_{eff} = H - \frac{i}{2} \sum_n \sigma_n^\dagger \sigma_n\)</span>
Default: True.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>scattering_prob</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The probability of scattering n photons from the system over the time
range specified.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="visualization">
<h2>Visualization<a class="headerlink" href="#visualization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.wigner">
<span id="pseudoprobability-functions"></span><h3>Pseudoprobability Functions<a class="headerlink" href="#module-qutip.wigner" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.wigner.qfunc">
<code class="descclassname">qutip.wigner.</code><code class="descname">qfunc</code><span class="sig-paren">(</span><em>state</em>, <em>xvec</em>, <em>yvec</em>, <em>g=1.4142135623730951</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#qfunc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.qfunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-function of a given state vector or density matrix
at points <cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A state vector or density matrix.</p>
</dd>
<dt><strong>xvec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Values representing the Q-function calculated over the specified range
[xvec,yvec].</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.spin_q_function">
<code class="descclassname">qutip.wigner.</code><code class="descname">spin_q_function</code><span class="sig-paren">(</span><em>rho</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#spin_q_function"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.spin_q_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Husimi Q-function for spins.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">theta-coordinates at which to calculate the Q function.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">phi-coordinates at which to calculate the Q function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>Q, THETA, PHI</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2d-array</span></dt>
<dd><p class="first last">Values representing the spin Q function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.spin_wigner">
<code class="descclassname">qutip.wigner.</code><code class="descname">spin_wigner</code><span class="sig-paren">(</span><em>rho</em>, <em>theta</em>, <em>phi</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#spin_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.spin_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for spins on the Bloch sphere.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A state vector or density matrix for a spin-j quantum system.</p>
</dd>
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">theta-coordinates at which to calculate the Q function.</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">phi-coordinates at which to calculate the Q function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W, THETA, PHI</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2d-array</span></dt>
<dd><p class="first last">Values representing the spin Wigner function at the values specified
by THETA and PHI.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>Experimental.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.wigner.wigner">
<code class="descclassname">qutip.wigner.</code><code class="descname">wigner</code><span class="sig-paren">(</span><em>psi</em>, <em>xvec</em>, <em>yvec</em>, <em>method='clenshaw'</em>, <em>g=1.4142135623730951</em>, <em>sparse=False</em>, <em>parfor=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/wigner.html#wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.wigner.wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Wigner function for a state vector or density matrix at points
<cite>xvec + i * yvec</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>state</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">A state vector or density matrix.</p>
</dd>
<dt><strong>xvec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">x-coordinates at which to calculate the Wigner function.</p>
</dd>
<dt><strong>yvec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">y-coordinates at which to calculate the Wigner function.  Does not
apply to the 'fft' method.</p>
</dd>
<dt><strong>g</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'clenshaw', 'iterative', 'laguerre', 'fft'}</span></dt>
<dd><p class="first last">Select method 'clenshaw' 'iterative', 'laguerre', or 'fft', where 'clenshaw' 
and 'iterative' use an iterative method to evaluate the Wigner functions for density
matrices <span class="math notranslate nohighlight">\(|m&gt;&lt;n|\)</span>, while 'laguerre' uses the Laguerre polynomials
in scipy for the same task. The 'fft' method evaluates the Fourier
transform of the density matrix. The 'iterative' method is default, and
in general recommended, but the 'laguerre' method is more efficient for
very sparse density matrices (e.g., superpositions of Fock states in a
large Hilbert space). The 'clenshaw' method is the preferred method for
dealing with density matrices that have a large number of excitations
(&gt;~50). 'clenshaw' is a fast and numerically stable method.</p>
</dd>
<dt><strong>sparse</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Tells the default solver whether or not to keep the input density
matrix in sparse format.  As the dimensions of the density matrix
grow, setthing this flag can result in increased performance.</p>
</dd>
<dt><strong>parfor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Flag for calculating the Laguerre polynomial based Wigner function
method='laguerre' in parallel using the parfor function.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>W</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Values representing the Wigner function calculated over the specified
range [xvec,yvec].</p>
</dd>
<dt><strong>yvex</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">FFT ONLY. Returns the y-coordinate values calculated via the Fourier
transform.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The 'fft' method accepts only an xvec input for the x-coordinate.
The y-coordinates are calculated internally.</p>
<p class="rubric">References</p>
<p>Ulf Leonhardt,
Measuring the Quantum State of Light, (Cambridge University Press, 1997)</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.visualization">
<span id="graphs-and-visualization"></span><h3>Graphs and Visualization<a class="headerlink" href="#module-qutip.visualization" title="Permalink to this headline">¶</a></h3>
<p>Functions for visualizing results of quantum dynamics simulations,
visualizations of quantum states and processes.</p>
<dl class="function">
<dt id="qutip.visualization.hinton">
<code class="descclassname">qutip.visualization.</code><code class="descname">hinton</code><span class="sig-paren">(</span><em>rho</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>ax=None</em>, <em>cmap=None</em>, <em>label_top=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#hinton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.hinton" title="Permalink to this definition">¶</a></dt>
<dd><p>Draws a Hinton diagram for visualizing a density matrix or superoperator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Input density matrix or superoperator.</p>
</dd>
<dt><strong>xlabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings or False</span></dt>
<dd><p class="first last">list of x labels</p>
</dd>
<dt><strong>ylabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings or False</span></dt>
<dd><p class="first last">list of y labels</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">title of the plot (optional)</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib colormap instance</span></dt>
<dd><p class="first last">Color map to use when plotting.</p>
</dd>
<dt><strong>label_top</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">If True, x-axis labels will be placed on top, otherwise
they will appear below the plot.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">Input argument is not a quantum object.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram">
<code class="descclassname">qutip.visualization.</code><code class="descname">matrix_histogram</code><span class="sig-paren">(</span><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#matrix_histogram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the matrix M, with the given x and y labels and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrix of Qobj</span></dt>
<dd><p class="first last">The matrix to visualize</p>
</dd>
<dt><strong>xlabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">list of x labels</p>
</dd>
<dt><strong>ylabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">list of y labels</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">title of the plot (optional)</p>
</dd>
<dt><strong>limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array with two float numbers</span></dt>
<dd><p class="first last">The z-axis limits [min, max] (optional)</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">Input argument is not valid.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.matrix_histogram_complex">
<code class="descclassname">qutip.visualization.</code><code class="descname">matrix_histogram_complex</code><span class="sig-paren">(</span><em>M</em>, <em>xlabels=None</em>, <em>ylabels=None</em>, <em>title=None</em>, <em>limits=None</em>, <em>phase_limits=None</em>, <em>colorbar=True</em>, <em>fig=None</em>, <em>ax=None</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#matrix_histogram_complex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.matrix_histogram_complex" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a histogram for the amplitudes of matrix M, using the argument
of each element for coloring the bars, with the given x and y labels
and title.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>M</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Matrix of Qobj</span></dt>
<dd><p class="first last">The matrix to visualize</p>
</dd>
<dt><strong>xlabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">list of x labels</p>
</dd>
<dt><strong>ylabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">list of y labels</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">title of the plot (optional)</p>
</dd>
<dt><strong>limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array with two float numbers</span></dt>
<dd><p class="first last">The z-axis limits [min, max] (optional)</p>
</dd>
<dt><strong>phase_limits</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array with two float numbers</span></dt>
<dd><p class="first last">The phase-axis (colorbar) limits [min, max] (optional)</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt>
<dd><p class="first last">Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">Input argument is not valid.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_energy_levels">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_energy_levels</code><span class="sig-paren">(</span><em>H_list</em>, <em>N=0</em>, <em>labels=None</em>, <em>show_ylabels=False</em>, <em>figsize=(8</em>, <em>12)</em>, <em>fig=None</em>, <em>ax=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_energy_levels"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_energy_levels" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the energy level diagrams for a list of Hamiltonians. Include
up to N energy levels. For each element in H_list, the energy
levels diagram for the cummulative Hamiltonian sum(H_list[0:n]) is plotted,
where n is the index of an element in H_list.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj</span></dt>
<dd><blockquote class="first">
<div><p>A list of Hamiltonians.</p>
</div></blockquote>
<dl class="last docutils">
<dt>labels <span class="classifier-delimiter">:</span> <span class="classifier">List of string</span></dt>
<dd><p class="first last">A list of labels for each Hamiltonian</p>
</dd>
<dt>show_ylabels <span class="classifier-delimiter">:</span> <span class="classifier">Bool (default False)</span></dt>
<dd><p class="first last">Show y labels to the left of energy levels of the initial
Hamiltonian.</p>
</dd>
<dt>N <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The number of energy levels to plot</p>
</dd>
<dt>figsize <span class="classifier-delimiter">:</span> <span class="classifier">tuple (int,int)</span></dt>
<dd><p class="first last">The size of the figure (width, height).</p>
</dd>
<dt>fig <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt>ax <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>ValueError</strong></dt>
<dd><p class="first last">Input argument is not valid.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_fock_distribution">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_fock_distribution</code><span class="sig-paren">(</span><em>rho</em>, <em>offset=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>title=None</em>, <em>unit_y_range=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">An optional title for the figure.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner_fock_distribution">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_wigner_fock_distribution</code><span class="sig-paren">(</span><em>rho</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method='iterative'</em>, <em>projection='2d'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_wigner_fock_distribution"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner_fock_distribution" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the Fock distribution and the Wigner function for a density matrix
(or ket) that describes an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a list of two matplotlib axes instances</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib cmap instance</span></dt>
<dd><p class="first last">The colormap.</p>
</dd>
<dt><strong>alpha_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'iterative', 'laguerre', 'fft'}</span></dt>
<dd><p class="first last">The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {'2d', '3d'}</strong></dt>
<dd><p class="first last">Specify whether the Wigner function is to be plotted as a
contour graph ('2d') or surface plot ('3d').</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_wigner">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_wigner</code><span class="sig-paren">(</span><em>rho</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em>, <em>cmap=None</em>, <em>alpha_max=7.5</em>, <em>colorbar=False</em>, <em>method='clenshaw'</em>, <em>projection='2d'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the the Wigner function for a density matrix (or ket) that describes
an oscillator mode.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rho</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.qobj.Qobj</span></code></span></dt>
<dd><p class="first last">The density matrix (or ket) of the state to visualize.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
<dt><strong>cmap</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib cmap instance</span></dt>
<dd><p class="first last">The colormap.</p>
</dd>
<dt><strong>alpha_max</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The span of the x and y coordinates (both [-alpha_max, alpha_max]).</p>
</dd>
<dt><strong>colorbar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether (True) or not (False) a colorbar should be attached to the
Wigner function graph.</p>
</dd>
<dt><strong>method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string {'clenshaw', 'iterative', 'laguerre', 'fft'}</span></dt>
<dd><p class="first last">The method used for calculating the wigner function. See the
documentation for qutip.wigner for details.</p>
</dd>
<dt><strong>projection: string {'2d', '3d'}</strong></dt>
<dd><p class="first last">Specify whether the Wigner function is to be plotted as a
contour graph ('2d') or surface plot ('3d').</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.sphereplot">
<code class="descclassname">qutip.visualization.</code><code class="descname">sphereplot</code><span class="sig-paren">(</span><em>theta</em>, <em>phi</em>, <em>values</em>, <em>fig=None</em>, <em>ax=None</em>, <em>save=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#sphereplot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.sphereplot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle with respect to z-axis</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle in x-y plane</p>
</dd>
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Data set to be plotted</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>save</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False , True}</span></dt>
<dd><p class="first last">Whether to save the figure or not</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_schmidt">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_schmidt</code><span class="sig-paren">(</span><em>ket</em>, <em>splitting=None</em>, <em>labels_iteration=(3</em>, <em>2)</em>, <em>theme='light'</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_schmidt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_schmidt" title="Permalink to this definition">¶</a></dt>
<dd><p>Plotting scheme related to Schmidt decomposition.
Converts a state into a matrix (A_ij -&gt; A_i^j),
where rows are first particles and columns - last.</p>
<p>See also: plot_qubism with how='before_after' for a similar plot.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Pure state for plotting.</p>
</dd>
<dt><strong>splitting</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Plot for a number of first particles versus the rest.
If not given, it is (number of particles + 1) // 2.</p>
</dd>
<dt><strong>theme</strong> <span class="classifier-delimiter">:</span> <span class="classifier">'light' (default) or 'dark'</span></dt>
<dd><p class="first last">Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>labels_iteration</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or pair of ints (default (3,2))</span></dt>
<dd><p class="first last">Number of particles to be shown as tick labels,
for first (vertical) and last (horizontal) particles, respectively.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib figure instance</span></dt>
<dd><p class="first last">The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axis instance</span></dt>
<dd><p class="first last">The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_qubism">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_qubism</code><span class="sig-paren">(</span><em>ket</em>, <em>theme='light'</em>, <em>how='pairs'</em>, <em>grid_iteration=1</em>, <em>legend_iteration=0</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(6</em>, <em>6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_qubism"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_qubism" title="Permalink to this definition">¶</a></dt>
<dd><p>Qubism plot for pure states of many qudits.
Works best for spin chains, especially with even number of particles
of the same dimension.
Allows to see entanglement between first 2*k particles and the rest.</p>
<p>More information:</p>
<blockquote>
<div>J. Rodriguez-Laguna, P. Migdal,
M. Ibanez Berganza, M. Lewenstein, G. Sierra,
&quot;Qubism: self-similar visualization of many-body wavefunctions&quot;,
New J. Phys. 14 053028 (2012), arXiv:1112.3560,
http://dx.doi.org/10.1088/1367-2630/14/5/053028 (open access)</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ket</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Pure state for plotting.</p>
</dd>
<dt><strong>theme</strong> <span class="classifier-delimiter">:</span> <span class="classifier">'light' (default) or 'dark'</span></dt>
<dd><p class="first last">Set coloring theme for mapping complex values into colors.
See: complex_array_to_rgb.</p>
</dd>
<dt><strong>how</strong> <span class="classifier-delimiter">:</span> <span class="classifier">'pairs' (default), 'pairs_skewed' or 'before_after'</span></dt>
<dd><p class="first">Type of Qubism plotting.
Options:</p>
<blockquote class="last">
<div><p>'pairs' - typical coordinates,
'pairs_skewed' - for ferromagnetic/antriferromagnetic plots,
'before_after' - related to Schmidt plot (see also: plot_schmidt).</p>
</div></blockquote>
</dd>
<dt><strong>grid_iteration</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 1)</span></dt>
<dd><p class="first last">Helper lines to be drawn on plot.
Show tiles for 2*grid_iteration particles vs all others.</p>
</dd>
<dt><strong>legend_iteration</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int (default 0) or 'grid_iteration' or 'all'</span></dt>
<dd><p class="first">Show labels for first 2*legend_iteration particles.
Option 'grid_iteration' sets the same number of particles</p>
<blockquote>
<div><p>as for grid_iteration.</p>
</div></blockquote>
<p class="last">Option 'all' makes label for all particles.
Typically it should be 0, 1, 2 or perhaps 3.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib figure instance</span></dt>
<dd><p class="first last">The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axis instance</span></dt>
<dd><p class="first last">The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_expectation_values">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_expectation_values</code><span class="sig-paren">(</span><em>results</em>, <em>ylabels=[]</em>, <em>title=None</em>, <em>show_legend=False</em>, <em>fig=None</em>, <em>axes=None</em>, <em>figsize=(8</em>, <em>4)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_expectation_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_expectation_values" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the results (expectation values) for an evolution solver.
<cite>results</cite> is assumed to be an instance of Result, or a list of Result
instances.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>results</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(list of) <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a></span></dt>
<dd><p class="first last">List of results objects returned by any of the QuTiP evolution solvers.</p>
</dd>
<dt><strong>ylabels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of strings</span></dt>
<dd><p class="first last">The y-axis labels. List should be of the same length as <cite>results</cite>.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The title of the figure.</p>
</dd>
<dt><strong>show_legend</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Whether or not to show the legend.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib Figure instance</span></dt>
<dd><p class="first last">The Figure canvas in which the plot will be drawn.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axes instance</span></dt>
<dd><p class="first last">The axes context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_2d">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_spin_distribution_2d</code><span class="sig-paren">(</span><em>P</em>, <em>THETA</em>, <em>PHI</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>8)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_spin_distribution_2d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a spin distribution function (given as meshgrid data) with a 2D
projection where the surface of the unit sphere is mapped on the unit disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>P</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><p class="first last">Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><p class="first last">Meshgrid matrix for the theta coordinate.</p>
</dd>
<dt><strong>PHI</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><p class="first last">Meshgrid matrix for the phi coordinate.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib figure instance</span></dt>
<dd><p class="first last">The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axis instance</span></dt>
<dd><p class="first last">The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.visualization.plot_spin_distribution_3d">
<code class="descclassname">qutip.visualization.</code><code class="descname">plot_spin_distribution_3d</code><span class="sig-paren">(</span><em>P</em>, <em>THETA</em>, <em>PHI</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/visualization.html#plot_spin_distribution_3d"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.visualization.plot_spin_distribution_3d" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a matrix of values on a sphere</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>P</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><p class="first last">Distribution values as a meshgrid matrix.</p>
</dd>
<dt><strong>THETA</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><p class="first last">Meshgrid matrix for the theta coordinate.</p>
</dd>
<dt><strong>PHI</strong> <span class="classifier-delimiter">:</span> <span class="classifier">matrix</span></dt>
<dd><p class="first last">Meshgrid matrix for the phi coordinate.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib figure instance</span></dt>
<dd><p class="first last">The figure canvas on which the plot will be drawn.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a matplotlib axis instance</span></dt>
<dd><p class="first last">The axis context in which the plot will be drawn.</p>
</dd>
<dt><strong>figsize</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(width, height)</span></dt>
<dd><p class="first last">The size of the matplotlib figure (in inches) if it is to be created
(that is, if no 'fig' and 'ax' arguments are passed).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<span class="target" id="module-qutip.orbital"></span><dl class="function">
<dt id="qutip.orbital.orbital">
<code class="descclassname">qutip.orbital.</code><code class="descname">orbital</code><span class="sig-paren">(</span><em>theta</em>, <em>phi</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/orbital.html#orbital"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.orbital.orbital" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates an angular wave function on a sphere.
<code class="docutils literal notranslate"><span class="pre">psi</span> <span class="pre">=</span> <span class="pre">orbital(theta,phi,ket1,ket2,...)</span></code> calculates
the angular wave function on a sphere at the mesh of points
defined by theta and phi which is
<span class="math notranslate nohighlight">\(\sum_{lm} c_{lm} Y_{lm}(theta,phi)\)</span> where <span class="math notranslate nohighlight">\(C_{lm}\)</span> are the
coefficients specified by the list of kets. Each ket has 2l+1 components
for some integer l.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Polar angles</p>
</dd>
<dt><strong>phi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last">Azimuthal angles</p>
</dd>
<dt><strong>args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> of ket vectors.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>``array`` for angular wave function</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.tomography">
<span id="quantum-process-tomography"></span><h3>Quantum Process Tomography<a class="headerlink" href="#module-qutip.tomography" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.tomography.qpt">
<code class="descclassname">qutip.tomography.</code><code class="descname">qpt</code><span class="sig-paren">(</span><em>U</em>, <em>op_basis_list</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the quantum process tomography chi matrix for a given (possibly
nonunitary) transformation matrix U, which transforms a density matrix in
vector form according to:</p>
<blockquote>
<div><p>vec(rho) = U * vec(rho0)</p>
<p>or</p>
<p>rho = vec2mat(U * mat2vec(rho0))</p>
</div></blockquote>
<p>U can be calculated for an open quantum system using the QuTiP propagator
function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Transformation operator. Can be calculated using QuTiP propagator
function.</p>
</dd>
<dt><strong>op_basis_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A list of Qobj's representing the basis states.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>chi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">QPT chi matrix</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot">
<code class="descclassname">qutip.tomography.</code><code class="descname">qpt_plot</code><span class="sig-paren">(</span><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>axes=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt_plot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot the real and
imaginary parts separately.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Plot title.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">figure instance</span></dt>
<dd><p class="first last">User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>axes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of figure axis instance</span></dt>
<dd><p class="first last">User defined figure axis instance (list of two axes) used for
generating QPT plot.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.tomography.qpt_plot_combined">
<code class="descclassname">qutip.tomography.</code><code class="descname">qpt_plot_combined</code><span class="sig-paren">(</span><em>chi</em>, <em>lbls_list</em>, <em>title=None</em>, <em>fig=None</em>, <em>ax=None</em>, <em>figsize=(8</em>, <em>6)</em>, <em>threshold=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/tomography.html#qpt_plot_combined"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.tomography.qpt_plot_combined" title="Permalink to this definition">¶</a></dt>
<dd><p>Visualize the quantum process tomography chi matrix. Plot bars with
height and color corresponding to the absolute value and phase,
respectively.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>chi</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Input QPT chi matrix.</p>
</dd>
<dt><strong>lbls_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of labels for QPT plot axes.</p>
</dd>
<dt><strong>title</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Plot title.</p>
</dd>
<dt><strong>fig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">figure instance</span></dt>
<dd><p class="first last">User defined figure instance used for generating QPT plot.</p>
</dd>
<dt><strong>ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">figure axis instance</span></dt>
<dd><p class="first last">User defined figure axis instance used for generating QPT plot
(alternative to the fig argument).</p>
</dd>
<dt><strong>threshold: float (None)</strong></dt>
<dd><p class="first last">Threshold for when bars of smaller height should be transparent. If
not set, all bars are colored according to the color map.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fig, ax</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">A tuple of the matplotlib figure and axes instances used to produce
the figure.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="quantum-information-processing">
<span id="functions-qip"></span><h2>Quantum Information Processing<a class="headerlink" href="#quantum-information-processing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.qip.gates">
<span id="gates"></span><h3>Gates<a class="headerlink" href="#module-qutip.qip.gates" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.gates.rx">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">rx</code><span class="sig-paren">(</span><em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rx" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmax with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.ry">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">ry</code><span class="sig-paren">(</span><em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#ry"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.ry" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmay with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rz">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">rz</code><span class="sig-paren">(</span><em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rz" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator sigmaz with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtnot">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">sqrtnot</code><span class="sig-paren">(</span><em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit square root NOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object for operator describing the square root NOT gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.snot">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">snot</code><span class="sig-paren">(</span><em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#snot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.snot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SNOT (Hadamard) gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>snot_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of SNOT gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">snot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.j  0.70710678+0.j]</span>
<span class="go"> [ 0.70710678+0.j -0.70710678+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.phasegate">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">phasegate</code><span class="sig-paren">(</span><em>theta</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#phasegate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.phasegate" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Phase rotation angle.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phase_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of phase shift gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j          0.00000000+0.j        ]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cphase">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">cphase</code><span class="sig-paren">(</span><em>theta</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#cphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the controlled phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Phase rotation angle.</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the control qubit.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the target qubit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of controlled phase gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.cnot">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">cnot</code><span class="sig-paren">(</span><em>N=None</em>, <em>control=0</em>, <em>target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#cnot"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.cnot" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CNOT gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cnot_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of CNOT gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnot</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.csign">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">csign</code><span class="sig-paren">(</span><em>N=None</em>, <em>control=0</em>, <em>target=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#csign"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.csign" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the CSIGN gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>csign_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of CSIGN gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">csign</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  -1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.berkeley">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">berkeley</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#berkeley"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.berkeley" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Berkeley gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>berkeley_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of Berkeley gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">berkeley</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ cos(pi/8).+0.j  0.+0.j           0.+0.j           0.+sin(pi/8).j]</span>
<span class="go">     [ 0.+0.j          cos(3pi/8).+0.j  0.+sin(3pi/8).j  0.+0.j]</span>
<span class="go">     [ 0.+0.j          0.+sin(3pi/8).j  cos(3pi/8).+0.j  0.+0.j]</span>
<span class="go">     [ 0.+sin(pi/8).j  0.+0.j           0.+0.j           cos(pi/8).+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swapalpha">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">swapalpha</code><span class="sig-paren">(</span><em>alpha, N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#swapalpha"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swapalpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAPalpha gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>swapalpha_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of SWAPalpha gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swapalpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j                    0.+0.j                    0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 + exp(j*pi*alpha)  0.5*(1 - exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.5*(1 - exp(j*pi*alpha)  0.5*(1 + exp(j*pi*alpha)  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j                    0.+0.j                    1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.swap">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">swap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#swap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.swap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>swap_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of SWAP gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">swap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.iswap">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">iswap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#iswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.iswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>iswap_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of iSWAP gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+1.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+1.j  0.+0.j  0.+0.j]</span>
<span class="go"> [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtswap">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">sqrtswap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root SWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sqrtswap_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of square root SWAP gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.sqrtiswap">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">sqrtiswap</code><span class="sig-paren">(</span><em>N=None, targets=[0, 1]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#sqrtiswap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.sqrtiswap" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the square root iSWAP gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>sqrtiswap_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of square root iSWAP gate</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sqrtiswap</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2], [2, 2]], shape = [4, 4], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 1.00000000+0.j   0.00000000+0.j          0.00000000+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.70710678+0.j          0.00000000-0.70710678j  0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000-0.70710678j       0.70710678+0.j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j   0.00000000+0.j          0.00000000+0.j          1.00000000+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.fredkin">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">fredkin</code><span class="sig-paren">(</span><em>N=None, control=0, targets=[1, 2]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#fredkin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.fredkin" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Fredkin gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>fredkin_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of Fredkin gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">fredkin</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.toffoli">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">toffoli</code><span class="sig-paren">(</span><em>N=None, controls=[0, 1], target=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#toffoli"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.toffoli" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the Toffoli gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>toff_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of Toffoli gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">toffoli</span><span class="p">()</span>
<span class="go">Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = [8, 8], type = oper, isHerm = True</span>
<span class="go">Qobj data =</span>
<span class="go">    [[ 1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j  0.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j]</span>
<span class="go">     [ 0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  0.+0.j  1.+0.j  0.+0.j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.rotation">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">rotation</code><span class="sig-paren">(</span><em>op</em>, <em>phi</em>, <em>N=None</em>, <em>target=0</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#rotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.rotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Single-qubit rotation for operator op with angle phi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object for operator describing the rotation.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.controlled_gate">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">controlled_gate</code><span class="sig-paren">(</span><em>U</em>, <em>N=2</em>, <em>control=0</em>, <em>target=1</em>, <em>control_value=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#controlled_gate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.controlled_gate" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an N-qubit controlled gate from a single-qubit gate U with the given
control and target qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">Arbitrary single-qubit gate.</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the first control qubit.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the target qubit.</p>
</dd>
<dt><strong>control_value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer (1)</span></dt>
<dd><p class="first last">The state of the control qubit that activates the gate U.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representing the controlled-U gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.globalphase">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">globalphase</code><span class="sig-paren">(</span><em>theta</em>, <em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#globalphase"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.globalphase" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns quantum object representing the global phase shift gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>theta</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Phase rotation angle.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>phase_gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of global phase shift gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phasegate</span><span class="p">(</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
<span class="go">Quantum object: dims = [[2], [2]], shape = [2, 2], type = oper, isHerm = False</span>
<span class="go">Qobj data =</span>
<span class="go">[[ 0.70710678+0.70710678j          0.00000000+0.j]</span>
<span class="go"> [ 0.00000000+0.j          0.70710678+0.70710678j]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.hadamard_transform">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">hadamard_transform</code><span class="sig-paren">(</span><em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#hadamard_transform"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.hadamard_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum object representing the N-qubit Hadamard gate.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>q</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of the N-qubit Hadamard gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_sequence_product">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">gate_sequence_product</code><span class="sig-paren">(</span><em>U_list</em>, <em>left_to_right=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_sequence_product"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_sequence_product" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the overall unitary matrix for a given list of unitary operations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of gates implementing the quantum circuit.</p>
</dd>
<dt><strong>left_to_right</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Boolean</span></dt>
<dd><p class="first last">Check if multiplication is to be done from left to right.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_overall</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Overall unitary matrix of a given quantum circuit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_1toN">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">gate_expand_1toN</code><span class="sig-paren">(</span><em>U</em>, <em>N</em>, <em>target</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_1toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_1toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a one-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">The one-qubit gate</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of qubits in the target space.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the target qubit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_2toN">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">gate_expand_2toN</code><span class="sig-paren">(</span><em>U</em>, <em>N</em>, <em>control=None</em>, <em>target=None</em>, <em>targets=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_2toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_2toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a two-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">The two-qubit gate</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of qubits in the target space.</p>
</dd>
<dt><strong>control</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the control qubit.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the target qubit.</p>
</dd>
<dt><strong>targets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">List of target qubits.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.gates.gate_expand_3toN">
<code class="descclassname">qutip.qip.gates.</code><code class="descname">gate_expand_3toN</code><span class="sig-paren">(</span><em>U, N, controls=[0, 1], target=2</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/gates.html#gate_expand_3toN"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.gates.gate_expand_3toN" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a Qobj representing a three-qubit gate that act on a system with N
qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>U</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">The three-qubit gate</p>
</dd>
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The number of qubits in the target space.</p>
</dd>
<dt><strong>controls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The list of the control qubits.</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">The index of the target qubit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>gate</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj</span></dt>
<dd><p class="first last">Quantum object representation of N-qubit gate.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.qubits">
<span id="qubits"></span><h3>Qubits<a class="headerlink" href="#module-qutip.qip.qubits" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.qip.qubits.qubit_states">
<code class="descclassname">qutip.qip.qubits.</code><code class="descname">qubit_states</code><span class="sig-paren">(</span><em>N=1, states=[0]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/qubits.html#qubit_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.qubits.qubit_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to define initial state of the qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Integer</span></dt>
<dd><p class="first last">Number of qubits in the register.</p>
</dd>
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List</span></dt>
<dd><p class="first last">Initial state of each qubit.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qstates</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">List of qubits.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.qip.algorithms.qft">
<span id="algorithms"></span><h3>Algorithms<a class="headerlink" href="#module-qutip.qip.algorithms.qft" title="Permalink to this headline">¶</a></h3>
<p>This module provides the circuit implementation for Quantum Fourier Transform.</p>
<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft">
<code class="descclassname">qutip.qip.algorithms.qft.</code><code class="descname">qft</code><span class="sig-paren">(</span><em>N=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of qubits.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>QFT: qobj</strong></dt>
<dd><p class="first last">Quantum Fourier transform operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_steps">
<code class="descclassname">qutip.qip.algorithms.qft.</code><code class="descname">qft_steps</code><span class="sig-paren">(</span><em>N=1</em>, <em>swapping=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the individual
steps as unitary matrices operating from left to right.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N: int</strong></dt>
<dd><p class="first last">Number of qubits.</p>
</dd>
<dt><strong>swap: boolean</strong></dt>
<dd><p class="first last">Flag indicating sequence of swap gates to be applied at the end or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>U_step_list: list of qobj</strong></dt>
<dd><p class="first last">List of Hadamard and controlled rotation gates implementing QFT.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.qip.algorithms.qft.qft_gate_sequence">
<code class="descclassname">qutip.qip.algorithms.qft.</code><code class="descname">qft_gate_sequence</code><span class="sig-paren">(</span><em>N=1</em>, <em>swapping=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/qip/algorithms/qft.html#qft_gate_sequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.qip.algorithms.qft.qft_gate_sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantum Fourier Transform operator on N qubits returning the gate sequence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>N: int</strong></dt>
<dd><p class="first last">Number of qubits.</p>
</dd>
<dt><strong>swap: boolean</strong></dt>
<dd><p class="first last">Flag indicating sequence of swap gates to be applied at the end or not.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qc: instance of QubitCircuit</strong></dt>
<dd><p class="first last">Gate sequence of Hadamard and controlled rotation gates implementing
QFT.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="module-qutip.nonmarkov.transfertensor">
<span id="non-markovian-solvers"></span><span id="functions-non-markov"></span><h2>non-Markovian Solvers<a class="headerlink" href="#module-qutip.nonmarkov.transfertensor" title="Permalink to this headline">¶</a></h2>
<p>This module contains an implementation of the non-Markovian transfer tensor
method (TTM), introduced in [1].</p>
<p>[1] Javier Cerrillo and Jianshu Cao, Phys. Rev. Lett 112, 110401 (2014)</p>
<dl class="function">
<dt id="qutip.nonmarkov.transfertensor.ttmsolve">
<code class="descclassname">qutip.nonmarkov.transfertensor.</code><code class="descname">ttmsolve</code><span class="sig-paren">(</span><em>dynmaps</em>, <em>rho0</em>, <em>times</em>, <em>e_ops=[]</em>, <em>learningtimes=None</em>, <em>tensors=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/nonmarkov/transfertensor.html#ttmsolve"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.nonmarkov.transfertensor.ttmsolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve time-evolution using the Transfer Tensor Method, based on a set of
precomputed dynamical maps.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>dynmaps</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">List of precomputed dynamical maps (superoperators),
or a callback function that returns the
superoperator at a given time.</p>
</dd>
<dt><strong>rho0</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a></span></dt>
<dd><p class="first last">Initial density matrix or state vector (ket).</p>
</dd>
<dt><strong>times</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times <span class="math notranslate nohighlight">\(t_n\)</span> at which to compute <span class="math notranslate nohighlight">\(\rho(t_n)\)</span>.
Must be uniformily spaced.</p>
</dd>
<dt><strong>e_ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of <a class="reference internal" href="classes.html#qutip.Qobj" title="qutip.Qobj"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.Qobj</span></code></a> / callback function</span></dt>
<dd><p class="first last">single operator or list of operators for which to evaluate
expectation values.</p>
</dd>
<dt><strong>learningtimes</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">list of times <span class="math notranslate nohighlight">\(t_k\)</span> for which we have knowledge of the dynamical
maps <span class="math notranslate nohighlight">\(E(t_k)\)</span>.</p>
</dd>
<dt><strong>tensors</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">optional list of precomputed tensors <span class="math notranslate nohighlight">\(T_k\)</span></p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dictionary</span></dt>
<dd><p class="first last">Optional keyword arguments. See
<code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.nonmarkov.ttm.TTMSolverOptions</span></code>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output: :class:`qutip.solver.Result`</strong></dt>
<dd><p class="first last">An instance of the class <a class="reference internal" href="classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.control.pulseoptim">
<span id="optimal-control"></span><span id="functions-control"></span><h2>Optimal control<a class="headerlink" href="#module-qutip.control.pulseoptim" title="Permalink to this headline">¶</a></h2>
<p>Wrapper functions that will manage the creation of the objects,
build the configuration, and execute the algorithm required to optimise
a set of ctrl pulses for a given (quantum) system.
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.
The functions minimise this fidelity error wrt the piecewise control
amplitudes in the timeslots</p>
<p>There are currently two quantum control pulse optmisations algorithms
implemented in this library. There are accessible through the methods
in this module. Both the algorithms use the scipy.optimize methods
to minimise the fidelity error with respect to to variables that define
the pulse.</p>
<div class="section" id="grape">
<h3>GRAPE<a class="headerlink" href="#grape" title="Permalink to this headline">¶</a></h3>
<p>The default algorithm (as it was implemented here first) is GRAPE
GRadient Ascent Pulse Engineering [1][2]. It uses a gradient based method such
as BFGS to minimise the fidelity error. This makes convergence very quick
when an exact gradient can be calculated, but this limits the factors that can
taken into account in the fidelity.</p>
</div>
<div class="section" id="crab">
<h3>CRAB<a class="headerlink" href="#crab" title="Permalink to this headline">¶</a></h3>
<p>The CRAB [3][4] algorithm was developed at the University of Ulm.
In full it is the Chopped RAndom Basis algorithm.
The main difference is that it reduces the number of optimisation variables 
by defining the control pulses by expansions of basis functions, 
where the variables are the coefficients. Typically a Fourier series is chosen, 
i.e. the variables are the Fourier coefficients. 
Therefore it does not need to compute an explicit gradient. 
By default it uses the Nelder-Mead method for fidelity error minimisation.</p>
</div>
<div class="section" id="id41">
<h3>References<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li>N Khaneja et. al. 
Optimal control of coupled spin dynamics: Design of NMR pulse sequences 
by gradient ascent algorithms. J. Magn. Reson. 172, 296–305 (2005).</li>
<li>Shai Machnes et.al
DYNAMO - Dynamic Framework for Quantum Optimal Control
arXiv.1011.4874</li>
<li>Doria, P., Calarco, T. &amp; Montangero, S. 
Optimal Control Technique for Many-Body Quantum Dynamics. 
Phys. Rev. Lett. 106, 1–4 (2011).</li>
<li>Caneva, T., Calarco, T. &amp; Montangero, S. 
Chopped random-basis quantum optimization. 
Phys. Rev. A - At. Mol. Opt. Phys. 84, (2011).</li>
</ol>
<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse">
<code class="descclassname">qutip.control.pulseoptim.</code><code class="descname">optimize_pulse</code><span class="sig-paren">(</span><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg='GRAPE'</em>, <em>alg_params=None</em>, <em>optim_params=None</em>, <em>optim_method='DEF'</em>, <em>method_params=None</em>, <em>optim_alg=None</em>, <em>max_metric_corr=None</em>, <em>accuracy_factor=None</em>, <em>dyn_type='GEN_MAT'</em>, <em>dyn_params=None</em>, <em>prop_type='DEF'</em>, <em>prop_params=None</em>, <em>fid_type='DEF'</em>, <em>fid_params=None</em>, <em>phase_option=None</em>, <em>fid_err_scale_factor=None</em>, <em>tslot_type='DEF'</em>, <em>tslot_params=None</em>, <em>amp_update_mode=None</em>, <em>init_pulse_type='DEF'</em>, <em>init_pulse_params=None</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#optimize_pulse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, n_ctrls)] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>drift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or list of Qobj</span></dt>
<dd><p class="first last">the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt>
<dd><p class="first last">a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer or None</span></dt>
<dd><p class="first last">number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of floats or None</span></dt>
<dd><p class="first last">durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>mim_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote class="last">
<div><p>'GRAPE' (default) - GRadient Ascent Pulse Engineering
'CRAB' - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>optim_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards 
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote class="last">
<div><p>GRAPE - Default optim_method is FMIN_L_BFGS_B
CRAB - Default optim_method is FMIN</p>
</div></blockquote>
</dd>
<dt><strong>method_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the optim_method. 
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key 
that attribute. Otherwise, and in some case also, 
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Deprecated. Use method_params instead</p>
</dd>
<dt><strong>dyn_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>phase_option</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Pass in fid_params instead.</p>
</dd>
<dt><strong>fid_err_scale_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Deprecated. Use scale_factor key in fid_params instead.</p>
</dd>
<dt><strong>tslot_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Method for computing the dynamics generators, propagators and 
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>amp_update_mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">type / shape of pulse(s) used to initialise the
the control amplitudes. 
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW</p>
</div></blockquote>
<p class="last">DEF is RND
(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>pulse_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Type of pulse used to modulate the control pulse.
It's intended use for a ramping modulation, which is often required in 
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or None</span></dt>
<dd><p class="first last">files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OptimResult</span></dt>
<dd><p class="first last">Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.optimize_pulse_unitary">
<code class="descclassname">qutip.control.pulseoptim.</code><code class="descname">optimize_pulse_unitary</code><span class="sig-paren">(</span><em>H_d</em>, <em>H_c</em>, <em>U_0</em>, <em>U_targ</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg='GRAPE'</em>, <em>alg_params=None</em>, <em>optim_params=None</em>, <em>optim_method='DEF'</em>, <em>method_params=None</em>, <em>optim_alg=None</em>, <em>max_metric_corr=None</em>, <em>accuracy_factor=None</em>, <em>phase_option='PSU'</em>, <em>dyn_params=None</em>, <em>prop_params=None</em>, <em>fid_params=None</em>, <em>tslot_type='DEF'</em>, <em>tslot_params=None</em>, <em>amp_update_mode=None</em>, <em>init_pulse_type='DEF'</em>, <em>init_pulse_params=None</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#optimize_pulse_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.optimize_pulse_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes
Starting from an intital (typically random) pulse,
a multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The maximum fidelity for a unitary system is 1, i.e. when the
time evolution resulting from the pulse is equivalent to the target.
And therefore the fidelity error is 1 - fidelity</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or list of Qobj</span></dt>
<dd><p class="first last">Drift (aka system) the underlying Hamiltonian of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>H_c</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt>
<dd><p class="first last">a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>U_0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>U_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer or None</span></dt>
<dd><p class="first last">number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of floats or None</span></dt>
<dd><p class="first last">durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>mim_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote class="last">
<div><p>'GRAPE' (default) - GRadient Ascent Pulse Engineering
'CRAB' - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>optim_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards 
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote class="last">
<div><p>GRAPE - Default optim_method is FMIN_L_BFGS_B
CRAB - Default optim_method is FMIN</p>
</div></blockquote>
</dd>
<dt><strong>method_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the optim_method. 
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key 
that attribute. Otherwise, and in some case also, 
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Deprecated. Use method_params instead</p>
</dd>
<dt><strong>phase_option</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">determines how global phase is treated in fidelity
calculations (fid_type='UNIT' only). Options:</p>
<blockquote class="last">
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</dd>
<dt><strong>dyn_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>tslot_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Method for computing the dynamics generators, propagators and 
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>amp_update_mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">type / shape of pulse(s) used to initialise the
the control amplitudes. 
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p class="last">(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>pulse_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Type of pulse used to modulate the control pulse.
It's intended use for a ramping modulation, which is often required in 
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or None</span></dt>
<dd><p class="first last">files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OptimResult</span></dt>
<dd><p class="first last">Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.create_pulse_optimizer">
<code class="descclassname">qutip.control.pulseoptim.</code><code class="descname">create_pulse_optimizer</code><span class="sig-paren">(</span><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-10</em>, <em>min_grad=1e-10</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg='GRAPE'</em>, <em>alg_params=None</em>, <em>optim_params=None</em>, <em>optim_method='DEF'</em>, <em>method_params=None</em>, <em>optim_alg=None</em>, <em>max_metric_corr=None</em>, <em>accuracy_factor=None</em>, <em>dyn_type='GEN_MAT'</em>, <em>dyn_params=None</em>, <em>prop_type='DEF'</em>, <em>prop_params=None</em>, <em>fid_type='DEF'</em>, <em>fid_params=None</em>, <em>phase_option=None</em>, <em>fid_err_scale_factor=None</em>, <em>tslot_type='DEF'</em>, <em>tslot_params=None</em>, <em>amp_update_mode=None</em>, <em>init_pulse_type='DEF'</em>, <em>init_pulse_params=None</em>, <em>pulse_scaling=1.0</em>, <em>pulse_offset=0.0</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#create_pulse_optimizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.create_pulse_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate the objects of the appropriate subclasses
required for the pulse optmisation based on the parameters given
Note this method may be preferable to calling optimize_pulse
if more detailed configuration is required before running the
optmisation algorthim, or the algorithm will be run many times,
for instances when trying to finding global the optimum or
minimum time optimisation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>drift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or list of Qobj</span></dt>
<dd><p class="first last">the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt>
<dd><p class="first last">a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer or None</span></dt>
<dd><p class="first last">number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of floats or None</span></dt>
<dd><p class="first last">durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>mim_grad</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Minimum gradient. When the sum of the squares of the
gradients wrt to the control amplitudes falls below this
value, the optimisation terminates, assuming local minima</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum allowed elapsed time for the optimisation algorithm</p>
</dd>
<dt><strong>alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">Algorithm to use in pulse optimisation.
Options are:</p>
<blockquote class="last">
<div><p>'GRAPE' (default) - GRadient Ascent Pulse Engineering
'CRAB' - Chopped RAndom Basis</p>
</div></blockquote>
</dd>
<dt><strong>alg_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>optim_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">a scipy.optimize.minimize method that will be used to optimise
the pulse for minimum fidelity error
Note that FMIN, FMIN_BFGS &amp; FMIN_L_BFGS_B will all result
in calling these specific scipy.optimize methods
Note the LBFGSB is equivalent to FMIN_L_BFGS_B for backwards 
capatibility reasons.
Supplying DEF will given alg dependent result:</p>
<blockquote class="last">
<div><ul class="simple">
<li>GRAPE - Default optim_method is FMIN_L_BFGS_B</li>
<li>CRAB - Default optim_method is Nelder-Mead</li>
</ul>
</div></blockquote>
</dd>
<dt><strong>method_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the optim_method. 
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key 
that attribute. Otherwise, and in some case also, 
they are assumed to be method_options
for the scipy.optimize.minimize method.</p>
</dd>
<dt><strong>optim_alg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Use optim_method.</p>
</dd>
<dt><strong>max_metric_corr</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Deprecated. Use method_params instead</p>
</dd>
<dt><strong>accuracy_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Deprecated. Use method_params instead</p>
</dd>
<dt><strong>dyn_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>phase_option</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Pass in fid_params instead.</p>
</dd>
<dt><strong>fid_err_scale_factor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Deprecated. Use scale_factor key in fid_params instead.</p>
</dd>
<dt><strong>tslot_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Method for computing the dynamics generators, propagators and 
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>amp_update_mode</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Deprecated. Use tslot_type instead.</p>
</dd>
<dt><strong>init_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">type / shape of pulse(s) used to initialise the
the control amplitudes. 
Options (GRAPE) include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW
DEF is RND</p>
</div></blockquote>
<p class="last">(see PulseGen classes for details)
For the CRAB the this the guess_pulse_type.</p>
</dd>
<dt><strong>init_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the initial / guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>pulse_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for generated initial / guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear offset for the pulse. That is this value will be added
to any initial / guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Type of pulse used to modulate the control pulse.
It's intended use for a ramping modulation, which is often required in 
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>gen_stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Optimizer</span></dt>
<dd><p class="first last">Instance of an Optimizer, through which the
Config, Dynamics, PulseGen, and TerminationConditions objects
can be accessed as attributes.
The PropagatorComputer, FidelityComputer and TimeslotComputer objects
can be accessed as attributes of the Dynamics object, e.g. optimizer.dynamics.fid_computer
The optimisation can be run through the optimizer.run_optimization</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab">
<code class="descclassname">qutip.control.pulseoptim.</code><code class="descname">opt_pulse_crab</code><span class="sig-paren">(</span><em>drift</em>, <em>ctrls</em>, <em>initial</em>, <em>target</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-05</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg_params=None</em>, <em>num_coeffs=None</em>, <em>init_coeff_scaling=1.0</em>, <em>optim_params=None</em>, <em>optim_method='fmin'</em>, <em>method_params=None</em>, <em>dyn_type='GEN_MAT'</em>, <em>dyn_params=None</em>, <em>prop_type='DEF'</em>, <em>prop_params=None</em>, <em>fid_type='DEF'</em>, <em>fid_params=None</em>, <em>tslot_type='DEF'</em>, <em>tslot_params=None</em>, <em>guess_pulse_type=None</em>, <em>guess_pulse_params=None</em>, <em>guess_pulse_scaling=1.0</em>, <em>guess_pulse_offset=0.0</em>, <em>guess_pulse_action='MODULATE'</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#opt_pulse_crab"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error.
The dynamics of the system in any given timeslot are governed
by the combined dynamics generator,
i.e. the sum of the drift+ctrl_amp[j]*ctrls[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes.
The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>drift</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or list of Qobj</span></dt>
<dd><p class="first last">the underlying dynamics generator of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>ctrls</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt>
<dd><p class="first last">a list of control dynamics generators. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>initial</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer or None</span></dt>
<dd><p class="first last">number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of floats or None</span></dt>
<dd><p class="first last">durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>coeff_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for the random basis coefficients
By default these range from -1.0 to 1.0
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>num_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of coefficients used for each basis function
Note this is calculated automatically based on the dimension of the
dynamics if not given. It is crucial to the performane of the 
algorithm that it is set as low as possible, while still giving
high enough frequencies.
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>optim_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Multi-variable optimisation method
The only tested options are 'fmin' and 'Nelder-mead'
In theory any non-gradient method implemented in 
scipy.optimize.mininize could be used.</p>
</dd>
<dt><strong>method_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Parameters for the optim_method. 
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key 
that attribute. Otherwise, and in some case also, 
they are assumed to be method_options
for the scipy.optimize.minimize method.
The commonly used parameter are:</p>
<blockquote class="last">
<div><p>xtol - limit on variable change for convergence
ftol - limit on fidelity error change for convergence</p>
</div></blockquote>
</dd>
<dt><strong>dyn_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Dynamics type, i.e. the type of matrix used to describe
the dynamics. Options are UNIT, GEN_MAT, SYMPL
(see Dynamics classes for details)</p>
</dd>
<dt><strong>dyn_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Propagator type i.e. the method used to calculate the
propagtors and propagtor gradient for each timeslot
options are DEF, APPROX, DIAG, FRECHET, AUG_MAT
DEF will use the default for the specific dyn_type
(see PropagatorComputer classes for details)</p>
</dd>
<dt><strong>prop_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Fidelity error (and fidelity error gradient) computation method
Options are DEF, UNIT, TRACEDIFF, TD_APPROX
DEF will use the default for the specific dyn_type
(See FidelityComputer classes for details)</p>
</dd>
<dt><strong>fid_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>tslot_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Method for computing the dynamics generators, propagators and 
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">type / shape of pulse(s) used modulate the control amplitudes. 
Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN</p>
</div></blockquote>
<p class="last">Default is None</p>
</dd>
<dt><strong>guess_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_action</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Determines how the guess pulse is applied to the pulse generated
by the basis expansion.
Options are: MODULATE, ADD 
Default is MODULATE</p>
</dd>
<dt><strong>pulse_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for generated guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear offset for the pulse. That is this value will be added
to any guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Type of pulse used to modulate the control pulse.
It's intended use for a ramping modulation, which is often required in 
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or None</span></dt>
<dd><p class="first last">files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OptimResult</span></dt>
<dd><p class="first last">Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.control.pulseoptim.opt_pulse_crab_unitary">
<code class="descclassname">qutip.control.pulseoptim.</code><code class="descname">opt_pulse_crab_unitary</code><span class="sig-paren">(</span><em>H_d</em>, <em>H_c</em>, <em>U_0</em>, <em>U_targ</em>, <em>num_tslots=None</em>, <em>evo_time=None</em>, <em>tau=None</em>, <em>amp_lbound=None</em>, <em>amp_ubound=None</em>, <em>fid_err_targ=1e-05</em>, <em>max_iter=500</em>, <em>max_wall_time=180</em>, <em>alg_params=None</em>, <em>num_coeffs=None</em>, <em>init_coeff_scaling=1.0</em>, <em>optim_params=None</em>, <em>optim_method='fmin'</em>, <em>method_params=None</em>, <em>phase_option='PSU'</em>, <em>dyn_params=None</em>, <em>prop_params=None</em>, <em>fid_params=None</em>, <em>tslot_type='DEF'</em>, <em>tslot_params=None</em>, <em>guess_pulse_type=None</em>, <em>guess_pulse_params=None</em>, <em>guess_pulse_scaling=1.0</em>, <em>guess_pulse_offset=0.0</em>, <em>guess_pulse_action='MODULATE'</em>, <em>ramping_pulse_type=None</em>, <em>ramping_pulse_params=None</em>, <em>log_level=0</em>, <em>out_file_ext=None</em>, <em>gen_stats=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulseoptim.html#opt_pulse_crab_unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulseoptim.opt_pulse_crab_unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Optimise a control pulse to minimise the fidelity error, assuming that
the dynamics of the system are generated by unitary operators.
This function is simply a wrapper for optimize_pulse, where the
appropriate options for unitary dynamics are chosen and the parameter
names are in the format familiar to unitary dynamics
The dynamics of the system  in any given timeslot are governed
by the combined Hamiltonian,
i.e. the sum of the H_d + ctrl_amp[j]*H_c[j]
The control pulse is an [n_ts, n_ctrls] array of piecewise amplitudes</p>
<p>The CRAB algorithm uses basis function coefficents as the variables to
optimise. It does NOT use any gradient function.
A multivariable optimisation algorithm attempts to determines the
optimal values for the control pulse to minimise the fidelity error
The fidelity error is some measure of distance of the system evolution
from the given target evolution in the time allowed for the evolution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>H_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj or list of Qobj</span></dt>
<dd><p class="first last">Drift (aka system) the underlying Hamiltonian of the system
can provide list (of length num_tslots) for time dependent drift</p>
</dd>
<dt><strong>H_c</strong> <span class="classifier-delimiter">:</span> <span class="classifier">List of Qobj or array like [num_tslots, evo_time]</span></dt>
<dd><p class="first last">a list of control Hamiltonians. These are scaled by
the amplitudes to alter the overall dynamics
Array like imput can be provided for time dependent control generators</p>
</dd>
<dt><strong>U_0</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">starting point for the evolution.
Typically the identity matrix</p>
</dd>
<dt><strong>U_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Qobj</span></dt>
<dd><p class="first last">target transformation, e.g. gate or state, for the time evolution</p>
</dd>
<dt><strong>num_tslots</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer or None</span></dt>
<dd><p class="first last">number of timeslots.
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>evo_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or None</span></dt>
<dd><p class="first last">total time for the evolution
None implies that timeslots will be given in the tau array</p>
</dd>
<dt><strong>tau</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array[num_tslots] of floats or None</span></dt>
<dd><p class="first last">durations for the timeslots.
if this is given then num_tslots and evo_time are dervived
from it
None implies that timeslot durations will be equal and
calculated as evo_time/num_tslots</p>
</dd>
<dt><strong>amp_lbound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">lower boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>amp_ubound</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or list of floats</span></dt>
<dd><p class="first last">upper boundaries for the control amplitudes
Can be a scalar value applied to all controls
or a list of bounds for each control</p>
</dd>
<dt><strong>fid_err_targ</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Fidelity error target. Pulse optimisation will
terminate when the fidelity error falls below this value</p>
</dd>
<dt><strong>max_iter</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Maximum number of iterations of the optimisation algorithm</p>
</dd>
<dt><strong>max_wall_time</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Maximum allowed elapsed time for the  optimisation algorithm</p>
</dd>
<dt><strong>alg_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">options that are specific to the algorithm see above</p>
</dd>
<dt><strong>optim_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dictionary</span></dt>
<dd><p class="first last">The key value pairs are the attribute name and value
used to set attribute values
Note: attributes are created if they do not exist already,
and are overwritten if they do.
Note: method_params are applied afterwards and so may override these</p>
</dd>
<dt><strong>coeff_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for the random basis coefficients
By default these range from -1.0 to 1.0
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>num_coeffs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">Number of coefficients used for each basis function
Note this is calculated automatically based on the dimension of the
dynamics if not given. It is crucial to the performane of the 
algorithm that it is set as low as possible, while still giving
high enough frequencies.
Note this is overridden by alg_params (if given there)</p>
</dd>
<dt><strong>optim_method</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Multi-variable optimisation method
The only tested options are 'fmin' and 'Nelder-mead'
In theory any non-gradient method implemented in 
scipy.optimize.mininize could be used.</p>
</dd>
<dt><strong>method_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first">Parameters for the optim_method. 
Note that where there is an attribute of the
Optimizer object or the termination_conditions matching the key 
that attribute. Otherwise, and in some case also, 
they are assumed to be method_options
for the scipy.optimize.minimize method.
The commonly used parameter are:</p>
<blockquote class="last">
<div><p>xtol - limit on variable change for convergence
ftol - limit on fidelity error change for convergence</p>
</div></blockquote>
</dd>
<dt><strong>phase_option</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">determines how global phase is treated in fidelity
calculations (fid_type='UNIT' only). Options:</p>
<blockquote class="last">
<div><p>PSU - global phase ignored
SU - global phase included</p>
</div></blockquote>
</dd>
<dt><strong>dyn_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the Dynamics object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>prop_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the PropagatorComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>fid_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the FidelityComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>tslot_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Method for computing the dynamics generators, propagators and 
evolution in the timeslots.
Options: DEF, UPDATE_ALL, DYNAMIC
UPDATE_ALL is the only one that currently works
(See TimeslotComputer classes for details)</p>
</dd>
<dt><strong>tslot_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the TimeslotComputer object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first">type / shape of pulse(s) used modulate the control amplitudes. 
Options include:</p>
<blockquote>
<div><p>RND, LIN, ZERO, SINE, SQUARE, TRIANGLE, SAW, GAUSSIAN</p>
</div></blockquote>
<p class="last">Default is None</p>
</dd>
<dt><strong>guess_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the guess pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>guess_pulse_action</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Determines how the guess pulse is applied to the pulse generated
by the basis expansion.
Options are: MODULATE, ADD 
Default is MODULATE</p>
</dd>
<dt><strong>pulse_scaling</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear scale factor for generated guess pulses
By default initial pulses are generated with amplitudes in the
range (-1.0, 1.0). These will be scaled by this parameter</p>
</dd>
<dt><strong>pulse_offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Linear offset for the pulse. That is this value will be added
to any guess pulses generated.</p>
</dd>
<dt><strong>ramping_pulse_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">Type of pulse used to modulate the control pulse.
It's intended use for a ramping modulation, which is often required in 
experimental setups.
This is only currently implemented in CRAB.
GAUSSIAN_EDGE was added for this purpose.</p>
</dd>
<dt><strong>ramping_pulse_params</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Parameters for the ramping pulse generator object
The key value pairs are assumed to be attribute name value pairs
They applied after the object is created</p>
</dd>
<dt><strong>log_level</strong> <span class="classifier-delimiter">:</span> <span class="classifier">integer</span></dt>
<dd><p class="first last">level of messaging output from the logger.
Options are attributes of qutip.logging_utils,
in decreasing levels of messaging, are:
DEBUG_INTENSE, DEBUG_VERBOSE, DEBUG, INFO, WARN, ERROR, CRITICAL
Anything WARN or above is effectively 'quiet' execution,
assuming everything runs as expected.
The default NOTSET implies that the level will be taken from
the QuTiP settings file, which by default is WARN</p>
</dd>
<dt><strong>out_file_ext</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string or None</span></dt>
<dd><p class="first last">files containing the initial and final control pulse
amplitudes are saved to the current directory.
The default name will be postfixed with this extension
Setting this to None will suppress the output of files</p>
</dd>
<dt><strong>gen_stats</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">if set to True then statistics for the optimisation
run will be generated - accessible through attributes
of the stats object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>opt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OptimResult</span></dt>
<dd><p class="first last">Returns instance of OptimResult, which has attributes giving the
reason for termination, final fidelity error, final evolution
final amplitudes, statistics etc</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<span class="target" id="module-qutip.control.pulsegen"></span><p>Pulse generator - Generate pulses for the timeslots
Each class defines a gen_pulse function that produces a float array of
size num_tslots. Each class produces a differ type of pulse.
See the class and gen_pulse function descriptions for details</p>
<dl class="function">
<dt id="qutip.control.pulsegen.create_pulse_gen">
<code class="descclassname">qutip.control.pulsegen.</code><code class="descname">create_pulse_gen</code><span class="sig-paren">(</span><em>pulse_type='RND'</em>, <em>dyn=None</em>, <em>pulse_params=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/control/pulsegen.html#create_pulse_gen"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.control.pulsegen.create_pulse_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and return a pulse generator object matching the given type.
The pulse generators each produce a different type of pulse,
see the gen_pulse function description for details.
These are the random pulse options:</p>
<blockquote>
<div>RND - Independent random value in each timeslot
RNDFOURIER - Fourier series with random coefficients
RNDWAVES - Summation of random waves
RNDWALK1 - Random change in amplitude each timeslot
RNDWALK2 - Random change in amp gradient each timeslot</div></blockquote>
<p>These are the other non-periodic options:</p>
<blockquote>
<div>LIN - Linear, i.e. contant gradient over the time
ZERO - special case of the LIN pulse, where the gradient is 0</div></blockquote>
<p>These are the periodic options</p>
<blockquote>
<div>SINE - Sine wave
SQUARE - Square wave
SAW - Saw tooth wave
TRIANGLE - Triangular wave</div></blockquote>
<p>If a Dynamics object is passed in then this is used in instantiate
the PulseGen, meaning that some timeslot and amplitude properties
are copied over.</p>
</dd></dl>

</div>
<div class="section" id="utilitiy-functions">
<h2>Utilitiy Functions<a class="headerlink" href="#utilitiy-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-qutip.graph">
<span id="graph-theory-routines"></span><span id="functions-graph"></span><h3>Graph Theory Routines<a class="headerlink" href="#module-qutip.graph" title="Permalink to this headline">¶</a></h3>
<p>This module contains a collection of graph theory routines used mainly
to reorder matrices for iterative steady state solvers.</p>
<dl class="function">
<dt id="qutip.graph.breadth_first_search">
<code class="descclassname">qutip.graph.</code><code class="descname">breadth_first_search</code><span class="sig-paren">(</span><em>A</em>, <em>start</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#breadth_first_search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.breadth_first_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Breadth-First-Search (BFS) of a graph in CSR or CSC matrix format starting
from a given node (row).  Takes Qobjs and CSR or CSC matrices as inputs.</p>
<p>This function requires a matrix with symmetric structure.
Use A+trans(A) if original matrix is not symmetric or not sure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">csc_matrix, csr_matrix</span></dt>
<dd><p class="first last">Input graph in CSC or CSR matrix format</p>
</dd>
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Staring node for BFS traversal.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Order in which nodes are traversed from starting node.</p>
</dd>
<dt><strong>levels</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Level of the nodes in the order that they are traversed.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.graph_degree">
<code class="descclassname">qutip.graph.</code><code class="descname">graph_degree</code><span class="sig-paren">(</span><em>A</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#graph_degree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.graph_degree" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the degree for the nodes (rows) of a symmetric
graph in sparse CSR or CSC format, or a qobj.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">qobj, csr_matrix, csc_matrix</span></dt>
<dd><p class="first last">Input quantum object or csr_matrix.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>degree</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of integers giving the degree for each node (row).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.reverse_cuthill_mckee">
<code class="descclassname">qutip.graph.</code><code class="descname">reverse_cuthill_mckee</code><span class="sig-paren">(</span><em>A</em>, <em>sym=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#reverse_cuthill_mckee"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.reverse_cuthill_mckee" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the permutation array that orders a sparse CSR or CSC matrix
in Reverse-Cuthill McKee ordering. Since the input matrix must be
symmetric, this routine works on the matrix A+Trans(A) if the sym flag is
set to False (Default).</p>
<p>It is assumed by default (<em>sym=False</em>) that the input matrix is not
symmetric. This is because it is faster to do A+Trans(A) than it is to
check for symmetry for a generic matrix. If you are guaranteed that the
matrix is symmetric in structure (values of matrix element do not matter)
then set <em>sym=True</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">csc_matrix, csr_matrix</span></dt>
<dd><p class="first last">Input sparse CSC or CSR sparse matrix format.</p>
</dd>
<dt><strong>sym</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool {False, True}</span></dt>
<dd><p class="first last">Flag to set whether input matrix is symmetric.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of permuted row and column indices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This routine is used primarily for internal reordering of Lindblad
superoperators for use in iterative solver routines.</p>
<p class="rubric">References</p>
<p>E. Cuthill and J. McKee, &quot;Reducing the Bandwidth of Sparse Symmetric
Matrices&quot;, ACM '69 Proceedings of the 1969 24th national conference,
(1969).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.maximum_bipartite_matching">
<code class="descclassname">qutip.graph.</code><code class="descname">maximum_bipartite_matching</code><span class="sig-paren">(</span><em>A</em>, <em>perm_type='row'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#maximum_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.maximum_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row or column permutations that removes nonzero
elements from the diagonal of a nonsingular square CSC sparse matrix. Such
a permutation is always possible provided that the matrix is nonsingular.
This function looks at the structure of the matrix only.</p>
<p>The input matrix will be converted to CSC matrix format if
necessary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sparse matrix</span></dt>
<dd><p class="first last">Input matrix</p>
</dd>
<dt><strong>perm_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'row', 'column'}</span></dt>
<dd><p class="first last">Type of permutation to generate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of row or column permutations.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function relies on a maximum cardinality bipartite matching algorithm
based on a breadth-first search (BFS) of the underlying graph[1]_.</p>
<p class="rubric">References</p>
<p>I. S. Duff, K. Kaya, and B. Ucar, &quot;Design, Implementation, and
Analysis of Maximum Transversal Algorithms&quot;, ACM Trans. Math. Softw.
38, no. 2, (2011).</p>
</dd></dl>

<dl class="function">
<dt id="qutip.graph.weighted_bipartite_matching">
<code class="descclassname">qutip.graph.</code><code class="descname">weighted_bipartite_matching</code><span class="sig-paren">(</span><em>A</em>, <em>perm_type='row'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/graph.html#weighted_bipartite_matching"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.graph.weighted_bipartite_matching" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an array of row permutations that attempts to maximize
the product of the ABS values of the diagonal elements in
a nonsingular square CSC sparse matrix. Such a permutation is
always possible provided that the matrix is nonsingular.</p>
<p>This function looks at both the structure and ABS values of the
underlying matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>A</strong> <span class="classifier-delimiter">:</span> <span class="classifier">csc_matrix</span></dt>
<dd><p class="first last">Input matrix</p>
</dd>
<dt><strong>perm_type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'row', 'column'}</span></dt>
<dd><p class="first last">Type of permutation to generate.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>perm</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Array of row or column permutations.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>This function uses a weighted maximum cardinality bipartite matching
algorithm based on breadth-first search (BFS).  The columns are weighted
according to the element of max ABS value in the associated rows and
are traversed in descending order by weight.  When performing the BFS
traversal, the row associated to a given column is the one with maximum
weight. Unlike other techniques[1]_, this algorithm does not guarantee the
product of the diagonal is maximized.  However, this limitation is offset
by the substantially faster runtime of this method.</p>
<p class="rubric">References</p>
<p>I. S. Duff and J. Koster, &quot;The design and use of algorithms for
permuting large entries to the diagonal of sparse matrices&quot;, SIAM J.
Matrix Anal. and Applics. 20, no. 4, 889 (1997).</p>
</dd></dl>

</div>
<div class="section" id="module-qutip.utilities">
<span id="utility-functions"></span><span id="functions-utilities"></span><h3>Utility Functions<a class="headerlink" href="#module-qutip.utilities" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions that are commonly needed in other
qutip modules.</p>
<dl class="function">
<dt id="qutip.utilities.n_thermal">
<code class="descclassname">qutip.utilities.</code><code class="descname">n_thermal</code><span class="sig-paren">(</span><em>w</em>, <em>w_th</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#n_thermal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.n_thermal" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of photons in thermal equilibrium for an harmonic
oscillator mode with frequency 'w', at the temperature described by
'w_th' where <span class="math notranslate nohighlight">\(\omega_{\rm th} = k_BT/\hbar\)</span>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>w</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>float</em> or <em>array</em></span></dt>
<dd><p class="first last">Frequency of the oscillator.</p>
</dd>
<dt><strong>w_th</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>float</em></span></dt>
<dd><p class="first last">The temperature in units of frequency (or the same units as <cite>w</cite>).</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>n_avg</strong> <span class="classifier-delimiter">:</span> <span class="classifier"><em>float</em> or <em>array</em></span></dt>
<dd><p class="first last">Return the number of average photons in thermal equilibrium for a
an oscillator with the given frequency and temperature.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.linspace_with">
<code class="descclassname">qutip.utilities.</code><code class="descname">linspace_with</code><span class="sig-paren">(</span><em>start</em>, <em>stop</em>, <em>num=50</em>, <em>elems=[]</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#linspace_with"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.linspace_with" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an array of numbers sampled over specified interval
with additional elements added.</p>
<p>Returns <cite>num</cite> spaced array with elements from <cite>elems</cite> inserted
if not already included in set.</p>
<p>Returned sample array is not evenly spaced if addtional elements
are added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>start</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The starting value of the sequence.</p>
</dd>
<dt><strong>stop</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">The stoping values of the sequence.</p>
</dd>
<dt><strong>num</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Number of samples to generate.</p>
</dd>
<dt><strong>elems</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/ndarray, optional</span></dt>
<dd><p class="first last">Requested elements to include in array</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>samples</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ndadrray</span></dt>
<dd><p class="first last">Original equally spaced sample array with additional
elements added.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.clebsch">
<code class="descclassname">qutip.utilities.</code><code class="descname">clebsch</code><span class="sig-paren">(</span><em>j1</em>, <em>j2</em>, <em>j3</em>, <em>m1</em>, <em>m2</em>, <em>m3</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#clebsch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.clebsch" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the Clebsch-Gordon coefficient
for coupling (j1,m1) and (j2,m2) to give (j3,m3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>j1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total angular momentum 1.</p>
</dd>
<dt><strong>j2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total angular momentum 2.</p>
</dd>
<dt><strong>j3</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Total angular momentum 3.</p>
</dd>
<dt><strong>m1</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">z-component of angular momentum 1.</p>
</dd>
<dt><strong>m2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">z-component of angular momentum 2.</p>
</dd>
<dt><strong>m3</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">z-component of angular momentum 3.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>cg_coeff</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Requested Clebsch-Gordan coefficient.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.utilities.convert_unit">
<code class="descclassname">qutip.utilities.</code><code class="descname">convert_unit</code><span class="sig-paren">(</span><em>value</em>, <em>orig='meV'</em>, <em>to='GHz'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/utilities.html#convert_unit"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.utilities.convert_unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert an energy from unit <cite>orig</cite> to unit <cite>to</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float / array</span></dt>
<dd><p class="first last">The energy in the old unit.</p>
</dd>
<dt><strong>orig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the original unit (&quot;J&quot;, &quot;eV&quot;, &quot;meV&quot;, &quot;GHz&quot;, &quot;mK&quot;)</p>
</dd>
<dt><strong>to</strong> <span class="classifier-delimiter">:</span> <span class="classifier">string</span></dt>
<dd><p class="first last">The name of the new unit (&quot;J&quot;, &quot;eV&quot;, &quot;meV&quot;, &quot;GHz&quot;, &quot;mK&quot;)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>value_new_unit</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float / array</span></dt>
<dd><p class="first last">The energy in the new unit.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.fileio">
<span id="file-i-o-functions"></span><span id="functions-fileio"></span><h3>File I/O Functions<a class="headerlink" href="#module-qutip.fileio" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.fileio.file_data_read">
<code class="descclassname">qutip.fileio.</code><code class="descname">file_data_read</code><span class="sig-paren">(</span><em>filename</em>, <em>sep=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#file_data_read"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_read" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves an array of data from the requested file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of file containing reqested data.</p>
</dd>
<dt><strong>sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Seperator used to store data.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array_like</span></dt>
<dd><p class="first last">Data from selected file.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.file_data_store">
<code class="descclassname">qutip.fileio.</code><code class="descname">file_data_store</code><span class="sig-paren">(</span><em>filename</em>, <em>data</em>, <em>numtype='complex'</em>, <em>numformat='decimal'</em>, <em>sep='</em>, <em>'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#file_data_store"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.file_data_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores a matrix of data to a file to be read by an external program.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of data file to be stored, including extension.</p>
</dd>
<dt><strong>data: array_like</strong></dt>
<dd><p class="first last">Data to be written to file.</p>
</dd>
<dt><strong>numtype</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'complex, 'real'}</span></dt>
<dd><p class="first last">Type of numerical data.</p>
</dd>
<dt><strong>numformat</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str {'decimal','exp'}</span></dt>
<dd><p class="first last">Format for written data.</p>
</dd>
<dt><strong>sep</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Single-character field seperator.  Usually a tab, space, comma,
or semicolon.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qload">
<code class="descclassname">qutip.fileio.</code><code class="descname">qload</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#qload"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qload" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads data file from file named 'filename.qu' in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of data file to be loaded.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>qobject</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance / array_like</span></dt>
<dd><p class="first last">Object retrieved from requested file.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.fileio.qsave">
<code class="descclassname">qutip.fileio.</code><code class="descname">qsave</code><span class="sig-paren">(</span><em>data</em>, <em>name='qutip_data'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/fileio.html#qsave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.fileio.qsave" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves given data to file named 'filename.qu' in current directory.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">instance/array_like</span></dt>
<dd><p class="first last">Input Python object to be stored.</p>
</dd>
<dt><strong>filename</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of output data file.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.parallel">
<span id="parallelization"></span><span id="functions-parallel"></span><h3>Parallelization<a class="headerlink" href="#module-qutip.parallel" title="Permalink to this headline">¶</a></h3>
<p>This function provides functions for parallel execution of loops and function
mappings, using the builtin Python module multiprocessing.</p>
<dl class="function">
<dt id="qutip.parallel.parfor">
<code class="descclassname">qutip.parallel.</code><code class="descname">parfor</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes a multi-variable function in parallel on the local machine.</p>
<p>Parallel execution of a for-loop over function <cite>func</cite> for multiple input
arguments and keyword arguments.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">From QuTiP 3.1, we recommend to use <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel_map()</span></code>
instead of this function.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>func</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function_type</span></dt>
<dd><p class="first last">A function to run in parallel on the local machine. The function 'func'
accepts a series of arguments that are passed to the function as
variables. In general, the function can have multiple input variables,
and these arguments must be passed in the same order as they are
defined in the function definition.  In addition, the user can pass
multiple keyword arguments to the function.</p>
</dd>
<dt><strong>The following keyword argument is reserved:</strong></dt>
<dd></dd>
<dt><strong>num_cpus</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of CPU's to use.  Default uses maximum number of CPU's.
Performance degrades if num_cpus is larger than the physical CPU
count of your machine.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">A <code class="docutils literal notranslate"><span class="pre">list</span></code> with length equal to number of input parameters
containing the output from <cite>func</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.parallel_map">
<code class="descclassname">qutip.parallel.</code><code class="descname">parallel_map</code><span class="sig-paren">(</span><em>task</em>, <em>values</em>, <em>task_args=()</em>, <em>task_kwargs={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel execution of a mapping of <cite>values</cite> to the function <cite>task</cite>. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>task</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a Python function</span></dt>
<dd><p class="first last">The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array / list</span></dt>
<dd><p class="first last">The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list / dictionary</span></dt>
<dd><p class="first last">The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list / dictionary</span></dt>
<dd><p class="first last">The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>progress_bar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ProgressBar</span></dt>
<dd><p class="first last">Progress bar class instance for showing progress.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The result list contains the value of 
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for 
each value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.parallel.serial_map">
<code class="descclassname">qutip.parallel.</code><code class="descname">serial_map</code><span class="sig-paren">(</span><em>task</em>, <em>values</em>, <em>task_args=()</em>, <em>task_kwargs={}</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/parallel.html#serial_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.parallel.serial_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Serial mapping function with the same call signature as parallel_map, for
easy switching between serial and parallel execution. This
is functionally equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">task</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">*</span><span class="n">task_args</span><span class="p">,</span> <span class="o">**</span><span class="n">task_kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
</pre></div>
</div>
<p>This function work as a drop-in replacement of <code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.parallel_map()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>task</strong> <span class="classifier-delimiter">:</span> <span class="classifier">a Python function</span></dt>
<dd><p class="first last">The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">array / list</span></dt>
<dd><p class="first last">The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list / dictionary</span></dt>
<dd><p class="first last">The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list / dictionary</span></dt>
<dd><p class="first last">The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>progress_bar</strong> <span class="classifier-delimiter">:</span> <span class="classifier">ProgressBar</span></dt>
<dd><p class="first last">Progress bar class instance for showing progress.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*task_args,</span> <span class="pre">**task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip.ipynbtools">
<span id="ipython-notebook-tools"></span><span id="functions-ipython"></span><h3>IPython Notebook Tools<a class="headerlink" href="#module-qutip.ipynbtools" title="Permalink to this headline">¶</a></h3>
<p>This module contains utility functions for using QuTiP with IPython notebooks.</p>
<dl class="function">
<dt id="qutip.ipynbtools.parfor">
<code class="descclassname">qutip.ipynbtools.</code><code class="descname">parfor</code><span class="sig-paren">(</span><em>task</em>, <em>task_vec</em>, <em>args=None</em>, <em>client=None</em>, <em>view=None</em>, <em>show_scheduling=False</em>, <em>show_progressbar=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#parfor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parfor" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">tast</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">args)</span></code> or <code class="docutils literal notranslate"><span class="pre">task(value)</span></code> if <code class="docutils literal notranslate"><span class="pre">args=None</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>task: a Python function</strong></dt>
<dd><p class="first last">The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>task_vec: array / list</strong></dt>
<dd><p class="first last">The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>args: list / dictionary</strong></dt>
<dd><p class="first last">The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function. For example
a dictionary with parameter values.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt>
<dd><p class="first last">The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt>
<dd><p class="first last">The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt>
<dd><p class="first last">Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt>
<dd><p class="first last">Display a HTML-based progress bar duing the execution of the parfor
loop.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The result list contains the value of <code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">args)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>, that is, it should be equivalent to
<code class="docutils literal notranslate"><span class="pre">[task(v,</span> <span class="pre">args)</span> <span class="pre">for</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">task_vec]</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.parallel_map">
<code class="descclassname">qutip.ipynbtools.</code><code class="descname">parallel_map</code><span class="sig-paren">(</span><em>task</em>, <em>values</em>, <em>task_args=None</em>, <em>task_kwargs=None</em>, <em>client=None</em>, <em>view=None</em>, <em>progress_bar=None</em>, <em>show_scheduling=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#parallel_map"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.parallel_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the function <code class="docutils literal notranslate"><span class="pre">task</span></code> for each value in <code class="docutils literal notranslate"><span class="pre">values</span></code> using a cluster
of IPython engines. The function <code class="docutils literal notranslate"><span class="pre">task</span></code> should have the signature
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">client</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code> are the IPython.parallel client and
load-balanced view that will be used in the parfor execution. If these
are <code class="docutils literal notranslate"><span class="pre">None</span></code>, new instances will be created.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>task: a Python function</strong></dt>
<dd><p class="first last">The function that is to be called for each value in <code class="docutils literal notranslate"><span class="pre">task_vec</span></code>.</p>
</dd>
<dt><strong>values: array / list</strong></dt>
<dd><p class="first last">The list or array of values for which the <code class="docutils literal notranslate"><span class="pre">task</span></code> function is to be
evaluated.</p>
</dd>
<dt><strong>task_args: list / dictionary</strong></dt>
<dd><p class="first last">The optional additional argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>task_kwargs: list / dictionary</strong></dt>
<dd><p class="first last">The optional additional keyword argument to the <code class="docutils literal notranslate"><span class="pre">task</span></code> function.</p>
</dd>
<dt><strong>client: IPython.parallel.Client</strong></dt>
<dd><p class="first last">The IPython.parallel Client instance that will be used in the
parfor execution.</p>
</dd>
<dt><strong>view: a IPython.parallel.Client view</strong></dt>
<dd><p class="first last">The view that is to be used in scheduling the tasks on the IPython
cluster. Preferably a load-balanced view, which is obtained from the
IPython.parallel.Client instance client by calling,
view = client.load_balanced_view().</p>
</dd>
<dt><strong>show_scheduling: bool {False, True}, default False</strong></dt>
<dd><p class="first last">Display a graph showing how the tasks (the evaluation of <code class="docutils literal notranslate"><span class="pre">task</span></code> for
for the value in <code class="docutils literal notranslate"><span class="pre">task_vec1</span></code>) was scheduled on the IPython engine
cluster.</p>
</dd>
<dt><strong>show_progressbar: bool {False, True}, default False</strong></dt>
<dd><p class="first last">Display a HTML-based progress bar during the execution of the parfor
loop.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>result</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list</span></dt>
<dd><p class="first last">The result list contains the value of
<code class="docutils literal notranslate"><span class="pre">task(value,</span> <span class="pre">task_args,</span> <span class="pre">task_kwargs)</span></code> for each
value in <code class="docutils literal notranslate"><span class="pre">values</span></code>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="qutip.ipynbtools.version_table">
<code class="descclassname">qutip.ipynbtools.</code><code class="descname">version_table</code><span class="sig-paren">(</span><em>verbose=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/ipynbtools.html#version_table"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.ipynbtools.version_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Print an HTML-formatted table with version numbers for QuTiP and its
dependencies. Use it in a IPython notebook to show which versions of
different packages that were used to run the notebook. This should make it
possible to reproduce the environment and the calculation later on.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>version_table: string</strong></dt>
<dd><p class="first last">Return an HTML-formatted string containing version information for
QuTiP dependencies.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-qutip">
<span id="miscellaneous"></span><span id="functions-misc"></span><h3>Miscellaneous<a class="headerlink" href="#module-qutip" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="qutip.about">
<code class="descclassname">qutip.</code><code class="descname">about</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/about.html#about"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.about" title="Permalink to this definition">¶</a></dt>
<dd><p>About box for QuTiP. Gives version numbers for
QuTiP, NumPy, SciPy, Cython, and MatPlotLib.</p>
</dd></dl>

<dl class="function">
<dt id="qutip.simdiag">
<code class="descclassname">qutip.</code><code class="descname">simdiag</code><span class="sig-paren">(</span><em>ops</em>, <em>evals=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qutip/simdiag.html#simdiag"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qutip.simdiag" title="Permalink to this definition">¶</a></dt>
<dd><p>Simultaneous diagonalization of commuting Hermitian matrices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>ops</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list/array</span></dt>
<dd><p class="first last"><code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">array</span></code> of qobjs representing commuting Hermitian
operators.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>eigs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Tuple of arrays representing eigvecs and eigvals of quantum objects
corresponding to simultaneous eigenvectors and eigenvalues for each
operator.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../changelog.html" class="btn btn-neutral float-right" title="Change Log" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>