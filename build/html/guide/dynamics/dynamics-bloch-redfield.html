

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="None" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="None" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Bloch-Redfield master equation &mdash; QuTiP: Quantum Toolbox in Python 4.2.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Floquet Formalism" href="dynamics-floquet.html" />
    <link rel="prev" title="Solving Problems with Time-dependent Hamiltonians" href="dynamics-time.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> QuTiP: Quantum Toolbox in Python
          

          
          </a>

          
            
            
              <div class="version">
                4.2
              </div>
            
          

            
            
              <div class="isa_warning">
                <i class="fa fa-warning"></i>
              Update QuTiP to the latest version and check out the latest documentation
              here.
            </div>
            

            
          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
          
          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../frontmatter.html">Frontmatter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../guide.html">Users Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../guide-overview.html">Guide Overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-basics.html">Basic Operations on Quantum Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-states.html">Manipulating States and Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-tensor.html">Using Tensor Products and Partial Traces</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="dynamics-data.html">Dynamics Simulation Results</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-master.html">Lindblad Master Equation Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-monte.html">Monte Carlo Solver</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-time.html">Solving Problems with Time-dependent Hamiltonians</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Bloch-Redfield master equation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l4"><a class="reference internal" href="#brief-derivation-and-definitions">Brief Derivation and Definitions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#bloch-redfield-master-equation-in-qutip">Bloch-Redfield master equation in QuTiP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#time-dependent-bloch-redfield-dynamics">Time-dependent Bloch-Redfield Dynamics</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-floquet.html">Floquet Formalism</a></li>
<li class="toctree-l3"><a class="reference internal" href="dynamics-options.html">Setting Options for the Dynamics Solvers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../guide-steady.html">Solving for Steady-State Solutions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-eseries.html">An Overview of the Eseries Class</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-correlation.html">Two-time correlation functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-control.html">Quantum Optimal Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-bloch.html">Plotting on the Bloch Sphere</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-visualization.html">Visualization of quantum states and processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-parfor.html">Parallel computation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-saving.html">Saving QuTiP Objects and Data Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-random.html">Generating Random Quantum States &amp; Operators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../guide-settings.html">Modifying Internal QuTiP Settings</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../apidoc/apidoc.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Change Log</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributors.html">Developers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../biblio.html">Bibliography</a></li>
</ul>

            

          

        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">QuTiP: Quantum Toolbox in Python</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../guide.html">Users Guide</a> &raquo;</li>
        
          <li><a href="../guide-dynamics.html">Time Evolution and Quantum System Dynamics</a> &raquo;</li>
        
      <li>Bloch-Redfield master equation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/guide/dynamics/dynamics-bloch-redfield.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="bloch-redfield-master-equation">
<span id="bloch-redfield"></span><h1>Bloch-Redfield master equation<a class="headerlink" href="#bloch-redfield-master-equation" title="Permalink to this headline">¶</a></h1>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qutip</span> <span class="kn">import</span> <span class="o">*</span>
       <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
</pre></div>
</div>
<div class="section" id="introduction">
<span id="bloch-redfield-intro"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.</p>
<p>However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.</p>
<p>The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust -- it always results in a physical density matrix -- although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. <a class="reference internal" href="../../biblio.html#coh92" id="id1">[Coh92]</a> or <a class="reference internal" href="../../biblio.html#bre02" id="id2">[Bre02]</a>. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP.</p>
</div>
<div class="section" id="brief-derivation-and-definitions">
<span id="bloch-redfield-derivation"></span><h2>Brief Derivation and Definitions<a class="headerlink" href="#brief-derivation-and-definitions" title="Permalink to this headline">¶</a></h2>
<p>The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): <span class="math notranslate nohighlight">\(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\)</span>, where <span class="math notranslate nohighlight">\(H\)</span> is the total system+bath Hamiltonian, <span class="math notranslate nohighlight">\(H_{\rm S}\)</span> and <span class="math notranslate nohighlight">\(H_{\rm B}\)</span> are the system and bath Hamiltonians, respectively, and <span class="math notranslate nohighlight">\(H_{\rm I}\)</span> is the interaction Hamiltonian.</p>
<p>The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (<span class="math notranslate nohighlight">\(\dot\rho = -i\hbar^{-1}[H, \rho]\)</span>). In the interaction picture the result is</p>
<div class="math notranslate nohighlight" id="equation-br-nonmarkovian-form-one">
<span class="eqno">(1)<a class="headerlink" href="#equation-br-nonmarkovian-form-one" title="Permalink to this equation">¶</a></span>\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\;  {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]</div>
<p>where the additional assumption that the total system-bath density matrix can be factorized as <span class="math notranslate nohighlight">\(\rho(t) \approx \rho_S(t) \otimes \rho_B\)</span>. This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. <em>It is justified for weak system-bath interaction.</em></p>
<p>The master equation <a class="reference internal" href="#equation-br-nonmarkovian-form-one">(1)</a> is non-Markovian, i.e., the change in the density matrix at a time <span class="math notranslate nohighlight">\(t\)</span> depends on states at all times <span class="math notranslate nohighlight">\(\tau &lt; t\)</span>, making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which <span class="math notranslate nohighlight">\(\rho(s)\)</span> is replaced by <span class="math notranslate nohighlight">\(\rho(t)\)</span> in Eq. <a class="reference internal" href="#equation-br-nonmarkovian-form-one">(1)</a>. The result is the Redfield equation</p>
<div class="math notranslate nohighlight" id="equation-br-nonmarkovian-form-two">
<span class="eqno">(2)<a class="headerlink" href="#equation-br-nonmarkovian-form-two" title="Permalink to this equation">¶</a></span>\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]</div>
<p>which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting <span class="math notranslate nohighlight">\(\tau \rightarrow t-\tau\)</span>, a fully Markovian master equation is obtained:</p>
<div class="math notranslate nohighlight" id="equation-br-markovian-form">
<span class="eqno">(3)<a class="headerlink" href="#equation-br-markovian-form" title="Permalink to this equation">¶</a></span>\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]</div>
<p>The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a &quot;short-memory&quot; bath, which results in Markovian system dynamics).</p>
<p>The master equation <a class="reference internal" href="#equation-br-markovian-form">(3)</a> is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form <span class="math notranslate nohighlight">\(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\)</span> and where <span class="math notranslate nohighlight">\(A_\alpha\)</span> are system operators and <span class="math notranslate nohighlight">\(B_\alpha\)</span> are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{d}{dt}\rho_S(t) =
-\hbar^{-2}
\sum_{\alpha\beta}
\int_0^\infty d\tau\;
\left\{
g_{\alpha\beta}(\tau) \left[A_\alpha(t)A_\beta(t-\tau)\rho_S(t) - A_\alpha(t-\tau)\rho_S(t)A_\beta(t)\right]
\right. \nonumber\\
\left.
g_{\alpha\beta}(-\tau) \left[\rho_S(t)A_\alpha(t-\tau)A_\beta(t) - A_\alpha(t)\rho_S(t)A_\beta(t-\tau)\right]
\right\},\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(g_{\alpha\beta}(\tau) = {\rm Tr}_B\left[B_\alpha(t)B_\beta(t-\tau)\rho_B\right] = \left&lt;B_\alpha(\tau)B_\beta(0)\right&gt;\)</span>, since the bath state <span class="math notranslate nohighlight">\(\rho_B\)</span> is a steady state.</p>
<p>In the eigenbasis of the system Hamiltonian, where <span class="math notranslate nohighlight">\(A_{mn}(t) = A_{mn} e^{i\omega_{mn}t}\)</span>, <span class="math notranslate nohighlight">\(\omega_{mn} = \omega_m - \omega_n\)</span> and <span class="math notranslate nohighlight">\(\omega_m\)</span> are the eigenfrequencies corresponding the eigenstate <span class="math notranslate nohighlight">\(\left|m\right&gt;\)</span>, we obtain in matrix form in the Schrödinger picture</p>
<div class="math notranslate nohighlight">
\[\begin{split}\frac{d}{dt}\rho_{ab}(t)
=
-i\omega_{ab}\rho_{ab}(t)
-\hbar^{-2}
\sum_{\alpha,\beta}
\sum_{c,d}^{\rm sec}
\int_0^\infty d\tau\;
\left\{
g_{\alpha\beta}(\tau)
\left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}
-
A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}
\right]
\right. \nonumber\\
+
\left.
g_{\alpha\beta}(-\tau)
\left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}
-
A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}
\right]
\right\} \rho_{cd}(t),
\nonumber\\\end{split}\]</div>
<p>where the &quot;sec&quot; above the summation symbol indicate summation of the secular terms which satisfy <span class="math notranslate nohighlight">\(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\)</span>. This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function <span class="math notranslate nohighlight">\(g(\tau)\)</span> in terms of the noise-power spectrum of the environment <span class="math notranslate nohighlight">\(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\)</span>:</p>
<div class="math notranslate nohighlight" id="equation-br-nonmarkovian-form-four">
<span class="eqno">(4)<a class="headerlink" href="#equation-br-nonmarkovian-form-four" title="Permalink to this equation">¶</a></span>\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]</div>
<p>where <span class="math notranslate nohighlight">\(\lambda_{ab}(\omega)\)</span> is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is</p>
<div class="math notranslate nohighlight" id="equation-br-final">
<span class="eqno">(5)<a class="headerlink" href="#equation-br-final" title="Permalink to this equation">¶</a></span>\[\frac{d}{dt}\rho_{ab}(t)
=
-i\omega_{ab}\rho_{ab}(t)
+
\sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]</div>
<p>where</p>
<div class="math notranslate nohighlight" id="equation-br-nonmarkovian-form-five">
<span class="eqno">(6)<a class="headerlink" href="#equation-br-nonmarkovian-form-five" title="Permalink to this equation">¶</a></span>\[\begin{split} R_{abcd} =  -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}
 \left\{
 \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn})
 -
 A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca})
 \right. \nonumber\\
 +
 \left.
 \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn})
 -
 A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db})
 \right\},\end{split}\]</div>
<p>is the Bloch-Redfield tensor.</p>
<p>The Bloch-Redfield master equation in the form Eq. <a class="reference internal" href="#equation-br-final">(5)</a> is suitable for numerical implementation. The input parameters are the system Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>, the system operators through which the environment couples to the system <span class="math notranslate nohighlight">\(A_\alpha\)</span>, and the noise-power spectrum <span class="math notranslate nohighlight">\(S_{\alpha\beta}(\omega)\)</span> associated with each system-environment interaction term.</p>
<p>To simplify the numerical implementation we assume that <span class="math notranslate nohighlight">\(A_\alpha\)</span> are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is</p>
<div class="math notranslate nohighlight" id="equation-br-tensor">
<span class="eqno">(7)<a class="headerlink" href="#equation-br-tensor" title="Permalink to this equation">¶</a></span>\[\begin{split} R_{abcd} =  -\frac{\hbar^{-2}}{2} \sum_{\alpha}
 \left\{
 \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn})
 -
 A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca})
 \right. \nonumber\\
 +
 \left.
 \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn})
 -
 A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db})
 \right\}.\end{split}\]</div>
</div>
<div class="section" id="bloch-redfield-master-equation-in-qutip">
<span id="bloch-redfield-qutip"></span><h2>Bloch-Redfield master equation in QuTiP<a class="headerlink" href="#bloch-redfield-master-equation-in-qutip" title="Permalink to this headline">¶</a></h2>
<p>In QuTiP, the Bloch-Redfield tensor Eq. <a class="reference internal" href="#equation-br-tensor">(7)</a> can be calculated using the function <a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.bloch_redfield_tensor()</span></code></a>. It takes two mandatory arguments: The system Hamiltonian <span class="math notranslate nohighlight">\(H\)</span>, a nested list of operator  <span class="math notranslate nohighlight">\(A_\alpha\)</span>, spectral density functions <span class="math notranslate nohighlight">\(S_\alpha(\omega)\)</span> pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument.</p>
<p>To illustrate how to calculate the Bloch-Redfield tensor, let's consider a two-level atom</p>
<div class="math notranslate nohighlight" id="equation-qubit">
<span class="eqno">(8)<a class="headerlink" href="#equation-qubit" title="Permalink to this equation">¶</a></span>\[ H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z\]</div>
<p>that couples to an Ohmic bath through the <span class="math notranslate nohighlight">\(\sigma_x\)</span> operator. The corresponding Bloch-Redfield tensor can be calculated in QuTiP using the following code</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">delta</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span> <span class="n">eps0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">;</span> <span class="n">gamma1</span> <span class="o">=</span> <span class="mf">0.5</span>

<span class="n">H</span> <span class="o">=</span> <span class="o">-</span> <span class="n">delta</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigmax</span><span class="p">()</span> <span class="o">-</span> <span class="n">eps0</span><span class="o">/</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">sigmaz</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">ohmic_spectrum</span><span class="p">(</span><span class="n">w</span><span class="p">):</span>
  <span class="o">...</span><span class="p">:</span>     <span class="k">if</span> <span class="n">w</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span> <span class="c1"># dephasing inducing noise</span>
  <span class="o">...</span><span class="p">:</span>         <span class="k">return</span> <span class="n">gamma1</span>
  <span class="o">...</span><span class="p">:</span>     <span class="k">else</span><span class="p">:</span> <span class="c1"># relaxation inducing noise</span>
  <span class="o">...</span><span class="p">:</span>         <span class="k">return</span> <span class="n">gamma1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="n">R</span><span class="p">,</span> <span class="n">ekets</span> <span class="o">=</span> <span class="n">bloch_redfield_tensor</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">[[</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">ohmic_spectrum</span><span class="p">]])</span>

<span class="n">R</span>
</pre></div>
</div>
<p>Note that it is also possible to add Lindblad dissipation superoperators in the Bloch-Refield tensor by passing the operators via the <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> keyword argument like you would in the <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve()</span></code></a> or <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve()</span></code></a> functions. For convenience, the function <a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.bloch_redfield_tensor" title="qutip.bloch_redfield.bloch_redfield_tensor"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.bloch_redfield_tensor()</span></code></a> also returns a list of eigenkets <cite>ekets</cite>, since they are calculated in the process of calculating the Bloch-Redfield tensor <cite>R</cite>, and the <cite>ekets</cite> are usually needed again later when transforming operators between the computational basis and the eigenbasis.</p>
<p>The evolution of a wavefunction or density matrix, according to the Bloch-Redfield master equation <a class="reference internal" href="#equation-br-final">(5)</a>, can be calculated using the QuTiP function <a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.bloch_redfield_solve" title="qutip.bloch_redfield.bloch_redfield_solve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.bloch_redfield_solve()</span></code></a>. It takes five mandatory arguments: the Bloch-Redfield tensor <code class="docutils literal notranslate"><span class="pre">R</span></code>, the list of eigenkets <code class="docutils literal notranslate"><span class="pre">ekets</span></code>, the initial state <code class="docutils literal notranslate"><span class="pre">psi0</span></code> (as a ket or density matrix), a list of times <code class="docutils literal notranslate"><span class="pre">tlist</span></code> for which to evaluate the expectation values, and a list of operators <code class="docutils literal notranslate"><span class="pre">e_ops</span></code> for which to evaluate the expectation values at each time step defined by <cite>tlist</cite>. For example, to evaluate the expectation values of the <span class="math notranslate nohighlight">\(\sigma_x\)</span>, <span class="math notranslate nohighlight">\(\sigma_y\)</span>, and <span class="math notranslate nohighlight">\(\sigma_z\)</span> operators for the example above, we can use the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

 <span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">15.0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

 <span class="n">psi0</span> <span class="o">=</span> <span class="n">rand_ket</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

 <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">sigmax</span><span class="p">(),</span> <span class="n">sigmay</span><span class="p">(),</span> <span class="n">sigmaz</span><span class="p">()]</span>

 <span class="n">expt_list</span> <span class="o">=</span> <span class="n">bloch_redfield_solve</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">ekets</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">)</span>

 <span class="n">sphere</span> <span class="o">=</span> <span class="n">Bloch</span><span class="p">()</span>

 <span class="n">sphere</span><span class="o">.</span><span class="n">add_points</span><span class="p">([</span><span class="n">expt_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">expt_list</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">expt_list</span><span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

 <span class="n">sphere</span><span class="o">.</span><span class="n">vector_color</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">]</span>

 <span class="n">sphere</span><span class="o">.</span><span class="n">add_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">delta</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">eps0</span><span class="p">])</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">delta</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">eps0</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>

 <span class="n">sphere</span><span class="o">.</span><span class="n">make_sphere</span><span class="p">()</span>

<span class="nd">@savefig</span> <span class="n">guide</span><span class="o">-</span><span class="n">brmesolve</span><span class="o">-</span><span class="n">dynamics</span><span class="o">.</span><span class="n">png</span> <span class="n">width</span><span class="o">=</span><span class="mf">4.0</span><span class="ow">in</span> <span class="n">align</span><span class="o">=</span><span class="n">center</span>
 <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function <a class="reference internal" href="../../apidoc/functions.html#qutip.bloch_redfield.brmesolve" title="qutip.bloch_redfield.brmesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.bloch_redfield.brmesolve()</span></code></a>, which takes same arguments as <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mesolve" title="qutip.mesolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mesolve()</span></code></a> and <a class="reference internal" href="../../apidoc/functions.html#module-qutip.mcsolve" title="qutip.mcsolve"><code class="xref py py-func docutils literal notranslate"><span class="pre">qutip.mcsolve()</span></code></a>, save for the additional nested list of operator-spectrum pairs that is called <code class="docutils literal notranslate"><span class="pre">a_ops</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">output</span> <span class="o">=</span> <span class="n">brmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">a_ops</span><span class="o">=</span><span class="p">[[</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">ohmic_spectrum</span><span class="p">]],</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">)</span>
</pre></div>
</div>
<p>where the resulting <cite>output</cite> is an instance of the class <a class="reference internal" href="../../apidoc/classes.html#qutip.solver.Result" title="qutip.solver.Result"><code class="xref py py-class docutils literal notranslate"><span class="pre">qutip.solver.Result</span></code></a>.</p>
</div>
<div class="section" id="time-dependent-bloch-redfield-dynamics">
<span id="td-bloch-redfield"></span><h2>Time-dependent Bloch-Redfield Dynamics<a class="headerlink" href="#time-dependent-bloch-redfield-dynamics" title="Permalink to this headline">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">New in QuTiP 4.2.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem.  Therefore,
if you are doing repeated simulations by varying parameters, then it is best to pass
<code class="docutils literal notranslate"><span class="pre">options</span> <span class="pre">=</span> <span class="pre">Options(rhs_reuse=True)</span></code> to the solver.</p>
</div>
<p>If you have not done so already, please read the section: <a class="reference internal" href="dynamics-time.html#time"><span class="std std-ref">Solving Problems with Time-dependent Hamiltonians</span></a>.</p>
<p>As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian.  For time-independent systems, this transformation need only be done once.  However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics.  In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method.  Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.</p>
<p>The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation.  As such, all the time-dependent terms, and noise power spectra must be expressed in the string format.  To begin, lets consider the previous example, but formatted to call the time-dependent solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ohmic</span> <span class="o">=</span> <span class="s2">&quot;{gamma1} / 2.0 * (w / (2 * pi)) * (w &gt; 0.0)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">gamma1</span><span class="o">=</span><span class="n">gamma1</span><span class="p">)</span>

<span class="n">output</span> <span class="o">=</span> <span class="n">brmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">a_ops</span><span class="o">=</span><span class="p">[[</span><span class="n">sigmax</span><span class="p">(),</span><span class="n">ohmic</span><span class="p">]],</span> <span class="n">e_ops</span><span class="o">=</span><span class="n">e_ops</span><span class="p">)</span>
</pre></div>
</div>
<p>Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode.  The string is nearly identical to the Python function format, except that we replaced <code class="docutils literal notranslate"><span class="pre">np.pi</span></code> with <code class="docutils literal notranslate"><span class="pre">pi</span></code> to avoid calling Python in our Cython code, and we have hard coded the <code class="docutils literal notranslate"><span class="pre">gamma1</span></code> argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.</p>
<p>For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further.  Instead, here the focus is on time-dependent bath coupling terms.  To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time <span class="math notranslate nohighlight">\(\kappa(t) = \kappa(0)\exp(-t)\)</span>.  In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list <code class="docutils literal notranslate"><span class="pre">c_ops</span> <span class="pre">=</span> <span class="pre">[[a,</span> <span class="pre">'sqrt(kappa*exp(-t))']]</span></code>.  In the Bloch-Redfield solver, the bath coupling terms must be Hermitian.  As such, in this example, our coupling operator is the position operator <code class="docutils literal notranslate"><span class="pre">a+a.dag()</span></code>.  In addition, we do not need the <code class="docutils literal notranslate"><span class="pre">sqrt</span></code> operation that occurs in the <code class="docutils literal notranslate"><span class="pre">c_ops</span></code> definition.  The complete example, and comparison to the analytic expression is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># number of basis states to consider</span>

 <span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

 <span class="n">H</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span>

 <span class="n">psi0</span> <span class="o">=</span> <span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>  <span class="c1"># initial state</span>

 <span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.2</span>  <span class="c1"># coupling to oscillator</span>

 <span class="n">a_ops</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a</span><span class="o">+</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">(),</span> <span class="s1">&#39;{kappa}*exp(-t)*(w&gt;=0)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kappa</span><span class="o">=</span><span class="n">kappa</span><span class="p">)]]</span>

 <span class="n">tlist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>

 <span class="n">out</span> <span class="o">=</span> <span class="n">brmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">tlist</span><span class="p">,</span> <span class="n">a_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="o">=</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">])</span>

 <span class="n">actual_answer</span> <span class="o">=</span> <span class="mf">9.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">kappa</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">tlist</span><span class="p">)))</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">tlist</span><span class="p">,</span> <span class="n">actual_answer</span><span class="p">)</span>

<span class="nd">@savefig</span> <span class="n">guide</span><span class="o">-</span><span class="n">brmesolve</span><span class="o">-</span><span class="n">td1</span><span class="o">.</span><span class="n">png</span> <span class="n">width</span><span class="o">=</span><span class="mf">5.0</span><span class="ow">in</span> <span class="n">align</span><span class="o">=</span><span class="n">center</span>
 <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>In many cases, the bath-coupling operators can take the form <span class="math notranslate nohighlight">\(A = f(t)a + f(t)^* a^{+}\)</span>.  In this case, the above format for inputting the <code class="docutils literal notranslate"><span class="pre">a_ops</span></code> is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence.  For example consider a white-noise bath that is coupled to an operator of the form <code class="docutils literal notranslate"><span class="pre">exp(1j*t)*a</span> <span class="pre">+</span> <span class="pre">exp(-1j*t)*</span> <span class="pre">a.dag()</span></code>.  In this example, the <code class="docutils literal notranslate"><span class="pre">a_ops</span></code> list would be:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a_ops</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="p">(</span><span class="s1">&#39;{0} * (w &gt;= 0)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kappa</span><span class="p">),</span> <span class="s1">&#39;exp(1j*t)&#39;</span><span class="p">,</span> <span class="s1">&#39;exp(-1j*t)&#39;</span><span class="p">)</span> <span class="p">]</span> <span class="p">]</span>
</pre></div>
</div>
<p>where the first tuple element <code class="docutils literal notranslate"><span class="pre">(a,</span> <span class="pre">a.dag())</span></code> tells the solver which operators make up the full Hermitian coupling operator.  The second tuple <code class="docutils literal notranslate"><span class="pre">('{0}</span> <span class="pre">*</span> <span class="pre">(w</span> <span class="pre">&gt;=</span> <span class="pre">0)'.format(kappa),</span> <span class="pre">'exp(1j*t)',</span> <span class="pre">'exp(-1j*t)')</span></code>, gives the noise power spectrum, and time-dependence of each operator.  Note that the noise spectrum must always come first in this second tuple. A full example is:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span> <span class="n">N</span> <span class="o">=</span> <span class="mi">10</span>

 <span class="n">w0</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

 <span class="n">g</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">w0</span>

 <span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.15</span>

 <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>

 <span class="n">a</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

 <span class="n">H</span> <span class="o">=</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">())</span>

 <span class="n">psi0</span> <span class="o">=</span> <span class="n">ket2dm</span><span class="p">((</span><span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">basis</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">unit</span><span class="p">())</span>

 <span class="n">a_ops</span> <span class="o">=</span> <span class="p">[[</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()),</span> <span class="p">(</span><span class="s1">&#39;{0} * (w &gt;= 0)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">kappa</span><span class="p">),</span> <span class="s1">&#39;exp(1j*t)&#39;</span><span class="p">,</span> <span class="s1">&#39;exp(-1j*t)&#39;</span><span class="p">)</span> <span class="p">]]</span>

 <span class="n">e_ops</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">dag</span><span class="p">()]</span>

 <span class="n">res_brme</span> <span class="o">=</span> <span class="n">brmesolve</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">psi0</span><span class="p">,</span> <span class="n">times</span><span class="p">,</span> <span class="n">a_ops</span><span class="p">,</span> <span class="n">e_ops</span><span class="p">)</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span><span class="n">res_brme</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$a^{+}a$&#39;</span><span class="p">)</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span><span class="n">res_brme</span><span class="o">.</span><span class="n">expect</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">r</span><span class="s1">&#39;$a+a^{+}$&#39;</span><span class="p">)</span>

 <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="nd">@savefig</span> <span class="n">guide</span><span class="o">-</span><span class="n">brmesolve</span><span class="o">-</span><span class="n">td2</span><span class="o">.</span><span class="n">png</span> <span class="n">width</span><span class="o">=</span><span class="mf">5.0</span><span class="ow">in</span> <span class="n">align</span><span class="o">=</span><span class="n">center</span>
 <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="dynamics-floquet.html" class="btn btn-neutral float-right" title="Floquet Formalism" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dynamics-time.html" class="btn btn-neutral float-left" title="Solving Problems with Time-dependent Hamiltonians" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, P.D. Nation, J.R. Johansson, A.J.G. Pitchford, C. Granade, and A.L. Grimsmo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>